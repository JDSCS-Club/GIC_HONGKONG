//*****************************************************************************************
//	LIC-A0
//	Program By : 연준상
//	
//	버젼
//	1) Ver 1.00:2010/3/2 -> 
//							- 처음시작
//	2) Ver 1.01:2010/4/29 -> 
//							- LIC <-> PAC간 통신추가(PAC(SDR) <-> LIC(SD)), 미국가서 장덕수가 추가(뭐 추가했는지 모름)
//	3) Ver 1.02:2010/10/15 -> 
//							- 버젼이 추가되어 수정(with LON(에버론), On philadelphia)
//							- All door close관련하여 추가 및 확인(with LON(에버론), On philadelphia)
//							- UART통신 1체널의 전송 버퍼를 조정(On philadelphia)
//							- 덕수가 주석 처리해놓은 디버그용 루틴 복원
//	4) Ver 1.031:2010/11/29 ->
//							- 버젼을 3자리에서 4자리로 수정, "m_pBoardIdInfo" 테이블 내에서 수정
//							- LIC <-> PAC간 LIC버젼전송되었는 소스부분을 접점신호(DOOR)로 변경, "user_WithPacRs485Loop()" 함수 내에서 수정
//							- 버젼을 CNCS에서 수신하면 실시간으로 시간&빌드데이트를 업데이트 한다.
//
//
//
//
//*****************************************************************************************

#include "stdio.h"
#include "string.h"
#include "stdarg.h"
#include "def.h"
#include "debug3x.h"
#include "xr16l784.h"
#include "ds1647.h"
#include "main.h"
#include "user.h"

//*****************************************************************************************
//	변수 정의
//*****************************************************************************************

UINT m_nDebug1msTimer = 0;
int m_nDebugCnt = 0;

const char *m_pBoardIdInfo[] =
{
	"Firmware:LIC-A0",
	"Version:1.031", // 버젼, 프로그램의 모든 부분에 참조, 반드시 버젼만 수정할 것
	"Date:2010/11/29",
	NULL
};

//*****************************************************************************************
//	메인 함수
//*****************************************************************************************
void main(void)
{
	int i;
	DATE_TIME_TYPE tmBuf;
	
	DINT;
	WDI_ACT;
	DspInit();
	Debug3xInit(TMS320C31);
	XR16L784_TXDIS(XR16L784_1CHL);
	XR16L784_TXDIS(XR16L784_2CHL);
	XR16L784_TXDIS(XR16L784_3CHL);
	XR16L784_TXDIS(XR16L784_4CHL);
	xr16l784_Init(XR16L784_1CHL,38400,XR16L784_DATA8,XR16L784_NONEPARITY,XR16L784_1STOPBIT); // 디버그용
	xr16l784_Init(XR16L784_2CHL,38400,XR16L784_DATA8,XR16L784_NONEPARITY,XR16L784_1STOPBIT); // LIC <-> CNCS
	xr16l784_Init(XR16L784_3CHL,19200,XR16L784_DATA8,XR16L784_NONEPARITY,XR16L784_1STOPBIT); // LIC <-> PAC
	xr16l784_Init(XR16L784_4CHL,19200,XR16L784_DATA8,XR16L784_NONEPARITY,XR16L784_1STOPBIT); // LIC <-> PAC
	//timeStart();
	EINT;
	user_Init();
	
	/*
	tmBuf.second = 0x30;
	tmBuf.minute = 0x28;
	tmBuf.hour = 0x15;
	tmBuf.day = 0x5;
	tmBuf.month = 0x3;
	tmBuf.year = 0x10;
	tmBuf.weekday = 5;
	//timeStSet(tmBuf);
	*/
	while(1)
	{
		user_Loop();
		xr16l784_Loop();

		if(!XR16L784_INT_ST) xr16l784_Isr();
		
		if(m_nDebug1msTimer > 500)
		{
			m_nDebug1msTimer = 0;
		}
		
		m_nDebugCnt++;
	}
}


//*****************************************************************************************
//	MPU설정
//*****************************************************************************************
void DspInit(void)
{
	PRIMBUSREG = 0x10A8;
	EN_CACHE;

	// Timer 0
	TMR0_CTRL = 0x2c0 ; // 내부 클럭
	TMR0_PERD = 25000; // 100,000,000MHz / 4 / 25000(x) = 1000Hz(1000us)

	INT0_VECT			= OP_BR | (int)c_int01; // Ext Int 0	
	INT1_VECT			= OP_BR | (int)c_int02; // Ext Int 1	
	TINT0_VECT			= OP_BR | (int)c_int10; // Timer 0	
	
	//EI_INT0;
	EI_INT1;
	EI_TINT0;
	
	// XF0, XF1 출력 모드
	asm(" LDI 0066h,IOF");	
	
	BOOT2INT;
}


//*****************************************************************************************
//	ASC를 HEX로 바꾼다.
//*****************************************************************************************
UCHAR ConvAsc2Hex(char chDat)
{
	int nBuf = 0;	
	if(chDat >= '0' && chDat <= '9') nBuf = chDat-'0';		
	else
	if(chDat >= 'a' && chDat <= 'f') nBuf = ((chDat-'a') + 10);		
	else
	if(chDat >= 'A' && chDat <= 'F') nBuf = ((chDat-'A') + 10);
	
	return nBuf;
}

//*****************************************************************************************
//	여러개의 ASC를 HEX로 바꾼다.
//*****************************************************************************************
int FunConvAscHex(char *InchData,UCHAR *OuthexData,int Len)
{
	int i;
	int sCnt = 0;
	for(i=0;i<Len; )
	{
		OuthexData[sCnt] = (ConvAsc2Hex(InchData[i++])<<4)&0xF0;
		OuthexData[sCnt] |= ConvAsc2Hex(InchData[i++])&0x0F;

		sCnt++;
	}
	return sCnt;
}

//*****************************************************************************************
//	숫자 ASC인가?
//*****************************************************************************************
BOOL IsNumAsc(char nCh)
{
	if(nCh >= '0' && nCh <= '9') return TRUE;
	return FALSE;
}

//*****************************************************************************************
//	ASC를 DEC로 바꾼다.
//*****************************************************************************************
int ConvAsc2Dec(char nCh)
{
	int nBuf = 0;	
	if(nCh >= '0' && nCh <= '9') nBuf = nCh-'0';		
	return nBuf;
}

//*****************************************************************************************
//	HEX를 ASC로 바꾼다.
//*****************************************************************************************
char ConvHex2Asc(UCHAR btCh)
{
	char chBuf = '0';
	if(btCh >= 0 && btCh <= 9) chBuf = btCh+'0';
	else if(btCh >= 10 && btCh <= 15) chBuf = (btCh-10)+'A';
	return chBuf;
}


int FunConvHexAsc(UCHAR *InhexData,char *OUTAscData,int Len)
{
	int i;
	int sCnt = 0;
	for(i=0;i<Len;i++)
	{
		OUTAscData[sCnt++] = ConvHex2Asc(BYTE_H(InhexData[i]));
		OUTAscData[sCnt++] = ConvHex2Asc(BYTE_L(InhexData[i]));
	}
	return sCnt;
}
//*****************************************************************************************
// Decimal의 10자리 문자로 바꾼다.
//*****************************************************************************************
void Dec2Str(char *pBuf,int nDat)
{
	int i;
	int nPos;
	char szBuf[32];
	
	nPos=0;
	szBuf[nPos++] = (nDat/1000000000%10)+'0';
	szBuf[nPos++] = (nDat/100000000%10)+'0';
	szBuf[nPos++] = (nDat/10000000%10)+'0';
	szBuf[nPos++] = (nDat/1000000%10)+'0';
	szBuf[nPos++] = (nDat/100000%10)+'0';
	szBuf[nPos++] = (nDat/10000%10)+'0';
	szBuf[nPos++] = (nDat/1000%10)+'0';
	szBuf[nPos++] = (nDat/100%10)+'0';
	szBuf[nPos++] = (nDat/10%10)+'0';
	szBuf[nPos++] = (nDat%10)+'0';
	szBuf[nPos] = NULL;
	
	for(i=0;i<nPos;i++) if(szBuf[i]!='0') break;
	i = MIN(i,nPos-1);
	
	StrCpy(pBuf,&szBuf[i]);
}

//*****************************************************************************************
//	문자를 뒤에 붙인다.
//*****************************************************************************************
void StrCat(char *dest, const char *src)
{
   char *r1 = dest - 1;
   while (*++r1);
   while ((*r1++ = *src++) != 0);
}

//*****************************************************************************************
//	문자 길이 구하기
//*****************************************************************************************
int StrLen(const char *string)
{
   const char *r1 = string - 1;
   while (*++r1);
   return r1 - string;
}

//*****************************************************************************************
//	문자 복사
//*****************************************************************************************
void StrCpy(char *dest, const char *src)
{
   char *result = dest;
   while ((*dest++ = *src++) != 0);
}

//*****************************************************************************************
//	문자 비교
//*****************************************************************************************
int StrCmp(const char *string1, const char *string2)
{
   char *r1 = (char *)string1 - 1;
   char *r2 = (char *)string2 - 1;
   char cp = TRUE;

   while ( (*++r2 == (cp = *++r1)) && cp );

   return *r1 - *r2;
}

//**************************************************************************************
//  디버깅용 전송
//**************************************************************************************
void MyPrintf(char * format, ... )
{
	va_list args;
	char szBuf[256];

	va_start(args, format);
	vsprintf(szBuf, format, args);
	
	xr16l784_Send(XR16L784_1CHL,(UCHAR *)szBuf,strlen(szBuf));
}

//*****************************************************************************************
// Firmware 버젼 String를 비교하여 맞는지 검사
//*****************************************************************************************
BOOL FirmwareVersionStrCmp(char *pObj,char *pSrc,int nLen)
{
	int i;
	BOOL bFlag = TRUE;
	for(i=0;i<nLen;i++) if(pObj[i] != pSrc[i]) {bFlag = FALSE; break;}
	return bFlag;
}

//*****************************************************************************************
//	Version찾아서 버젼값으로 얻기
//  nVerBuildData = 1 //버전 정보
//  nVerBuildData = 2 //날짜 정보
//*****************************************************************************************
int GetFirmwareVersion(UCHAR nVerBuildData)
{
	int i;
	int nVer = 100;
	char *pVersionString;

	for(i=0;i<128;i++)
	{
		pVersionString = (char *)m_pBoardIdInfo[i];
		if(pVersionString == NULL) break;

		if(WORD_L(nVerBuildData) == 1)
		{
			if(FirmwareVersionStrCmp("Version",pVersionString,7))
			{
				nVer = ConvAsc2Dec(pVersionString[8])*1000+ConvAsc2Dec(pVersionString[10])*100+ConvAsc2Dec(pVersionString[11])*10+ConvAsc2Dec(pVersionString[12]);
				break;
			}
		}
		else if(WORD_L(nVerBuildData) == 2)
		{
			if(FirmwareVersionStrCmp("Date",pVersionString,4))
			{
				nVer = ConvAsc2Dec(pVersionString[7])*100000+ConvAsc2Dec(pVersionString[8])*10000+ConvAsc2Dec(pVersionString[10])*1000+
				       ConvAsc2Dec(pVersionString[11])*100+ConvAsc2Dec(pVersionString[13])*10+ConvAsc2Dec(pVersionString[14]);
				break;
			}
		}
	}
	
	return nVer;
}

//**********************************************************************************
//	1Byte BCC 체크를 만든다.
//**********************************************************************************
UCHAR Make1ByteBcc(UCHAR *pDat,int nLen)
{
	int i;
	UCHAR btBcc = 0x00;
	for(i=0;i<nLen;i++)	btBcc ^= pDat[i];
	return btBcc;
}

//*****************************************************************************************
//	BCC 체크를 만든다. BCC를 만들어 pDat에 저장한다.
//*****************************************************************************************
void MakeBcc(UCHAR *pDat,int nLen)
{
	int i;
	
	pDat[nLen] = pDat[nLen+1] = 0x00;

	for(i=0;i<nLen;i++)	pDat[nLen + (i&0x01)] ^= pDat[i];
}

//*****************************************************************************************
//	BCC가 정상적으로 되었는가 검사
//	return : OK : TRUE, NG : FALSE
//*****************************************************************************************
int IsBccOk(UCHAR *pDat,int nLen)
{	
	int i;
	UCHAR nBCC[2];
	
	nBCC[0] = nBCC[1] = 0x00;

	for(i=0;i<nLen;i++)
	{
		nBCC[(i&0x01)] ^= WORD_L(pDat[i]);
	}
	
	if(nBCC[0] != WORD_L(pDat[nLen]) || nBCC[1] != WORD_L(pDat[nLen+1]))
	{
		return FALSE;
	}
	else
	{
		return TRUE;
	}
}

//*******************************************************************************************
//	인천 MMI에서 사용
//	초로환산한 시간을 년/월/일/시/분/초로 바꿔준다.
//*******************************************************************************************
BOOL gm_SysTimeToRtc(DATE_TIME_PTR pTime,UINT nSysTime)
{
	BOOL bSec;
	int days[] = { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }; 
	int nTemp;
	unsigned int nDays,nTotalSecond = nSysTime,nFrontSec,nRearSec;
	int nBaseYear = 2000;

	bSec = FALSE;
	nRearSec = nFrontSec = 0;
	for(nTemp = nBaseYear; nTemp <= 2245 ;nTemp++)
	{
		nDays = 365;
		if((!(nTemp % 4) && (nTemp % 100)) || !(nTemp % 400)) nDays += 1;
		nRearSec = nFrontSec;
		nFrontSec += nDays*24*60*60;
		if(ISRANGE_LOW(nTotalSecond,nRearSec,nFrontSec))
		{
			pTime->year = BIN2BCD(nTemp-nBaseYear);
			nTotalSecond -= nRearSec;
			bSec = TRUE;
			break;
		}
	}

	if(!bSec) return FALSE;

	bSec = FALSE;
	nDays = 0;
	nRearSec = nFrontSec = 0;
	for(nTemp=0;nTemp<11;nTemp++) 
	{
		nDays += days[nTemp];
		nRearSec = nFrontSec;
		nFrontSec = nDays*24*60*60;
		if(ISRANGE_LOW(nTotalSecond,nRearSec,nFrontSec))
		{
			pTime->month = BIN2BCD(nTemp+1);
			nTotalSecond -= nRearSec;
			bSec = TRUE;
			break;
		}
	}

	if(!bSec) return FALSE;

	nTemp = nTotalSecond/(24*60*60);
	pTime->day = BIN2BCD(nTemp+1);
	nTotalSecond %= (24*60*60);

	nTemp = nTotalSecond/(60*60);
	pTime->hour = BIN2BCD(nTemp);
	nTotalSecond %= (60*60);

	nTemp = nTotalSecond/60;
	pTime->minute = BIN2BCD(nTemp);
	nTotalSecond %= 60;

	pTime->second = BIN2BCD(nTotalSecond);
	
	return TRUE;
}


//*****************************************************************************************
//	지연
//*****************************************************************************************
int Delay(int nCnt)
{
	while(nCnt--) WDI_ACT;	
}

//*****************************************************************************************
//	Interrupt 0
//*****************************************************************************************
void c_int01()
{
	xr16l784_Isr();
}

//*****************************************************************************************
//	Interrupt 1
//*****************************************************************************************
void c_int02()
{
	user_LonWorkRead();
}

//*****************************************************************************************
//	Timer0(1ms)
//*****************************************************************************************
void c_int10(void)
{
	static int nRunLedCnt=0;
	
	xr16l784_1msLoop();
	user_1msLoop();
	
	m_nDebug1msTimer++;

	WDI_ACT;
	RUN_LED(nRunLedCnt&0x40 ? 0 : 1);
	ERR_LED(nRunLedCnt&0x40 ? 1 : 0);
	nRunLedCnt++;
}