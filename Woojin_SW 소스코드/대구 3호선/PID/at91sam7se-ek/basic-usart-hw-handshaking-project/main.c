/* ----------------------------------------------------------------------------
 *         ATMEL Microcontroller Software Support 
 * ----------------------------------------------------------------------------
 * Copyright (c) 2008, Atmel Corporation
 *
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * - Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the disclaimer below.
 *
 * Atmel's name may not be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
 * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * ----------------------------------------------------------------------------
 */

//------------------------------------------------------------------------------
/// \dir "Basic USART Hardware Handshaking Project"
///
/// !!!Purpose
///
/// This example demonstrates the hardware handshaking mode (i.e. RTS/CTS)
/// provided by the USART peripherals on AT91 microcontrollers. The practical
/// use of hardware handshaking is that it allows to stop transfer on the USART
/// without losing any data in the process. This is very useful for applications
/// that need to program slow memories for example.
///
/// !!!Requirements
///
/// This example can be used on any AT91 evaluation kit, except when they do
/// not provide an USART serial port (i.e. on AT91SAM9261-EK, AT91SAM7L-EK and
/// AT91SAM7L-STK).
///
/// !!!Description
///
/// The provided program uses hardware handshaking mode to regulate the data
/// rate of an incoming file transfer. A terminal application, such as
/// hyperterminal, is used to send a text file to the device (without any
/// protocol such as X-modem). The device will enforce the configured
/// bytes per second (bps) rate with its Request To Send (RTS) line.
///
/// Whenever the data rate meet or exceed the configurable threshold, the device
/// stops receiving data on the USART. Since no buffer is provided to the PDC,
/// this will set the RTS line, telling the computer to stop sending data. Each
/// second, the current data rate and total number of bytes received are
/// displayed; the transfer is also restarted.
///
/// Note that the device may receive slightly less bytes than the actual file
/// size, depending on the nature of the file. This does NOT mean that bytes
/// have been lost: this is simply an issue with how line breaks are transmitted
/// by the terminal. It is therefore better to use binary files, as they most
/// often do not contain line breaks. For example, send one of the object files
/// generated by the compiler.
///
/// !!!Usage
///
/// -# Build the program and download it inside the evaluation board. Please
///    refer to the <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6224.pdf">SAM-BA User Guide</a>,
///    the <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6310.pdf">GNU-Based Software Development</a>
///    application note or to the <a href="ftp://ftp.iar.se/WWWfiles/arm/Guides/EWARM_UserGuide.ENU.pdf">IAR EWARM User Guide</a>,
///    depending on your chosen solution.
/// -# Connect a serial cable to the USART0 port on the evaluation kit. It will
///    most often be labeled "RS232 COM port".
/// -# On the computer, open and configure a terminal application (e.g.
///    HyperTerminal on Microsoft Windows) with these settings:
///       - 115200 bauds
///       - 8 data bits
///       - No parity
///       - 1 stop bit
///       - Hardware flow control (RTS/CTS)
/// -# Start the application. The following traces shall appear on the terminal:
///    \code
///    -- Basic USART Hardware Handshaking Project xxx --
///    -- AT91xxxxxx-xx
///    -- Compiled: xxx xx xxxx xx:xx:xx --
///    Bps:    0; Tot:      0
///    \endcode
/// -# Send a file in text format to the device. On HyperTerminal, this is done
///    by selecting "Transfer -> Send Text File" (this does not prevent you from
///    sending binary files). The transfer will start and the device will update
///    the bps and total counts on the terminal.
/// -# Whenever the transfer is complete, the total number of bytes received
///    should match the size of the sent file (unless it is a text file, see
///    explanation in description section).
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
//         Headers
//------------------------------------------------------------------------------

#include <board.h>
#include <pio/pio.h>
#include <usart/usart.h>
#include <tc/tc.h>
#include <aic/aic.h>
#include <pmc/pmc.h>
#include <utility/trace.h>
#include <pit/pit.h>
#include <utility/math.h>
#include <board_memories.h>
#include <utility/assert.h>
#include <memories/norflash/NorFlashCFI.h>
#include <memories/norflash/NorFlashApi.h>
#include <memories/spi-flash/at26.h>

#include <spi/spi.h>


#include <stdio.h>

#include "UART.h"
#include "main.h"
#include "NorFlash.h"
#include "Download.h"
#include "LED_Display.h"

#include "SPI_FUN.h"


extern SCC_INIT_SHAPE SCC1_Init_AChl; // 85C30의 송수신 버퍼 및 플래그

//------------------------------------------------------------------------------
//         Local variables - nandflash memory 변수 
//------------------------------------------------------------------------------

/// Norflash device structure.
struct NorFlash norFlash;

//------------------------------------------------------------------------------
//         Local definition
//------------------------------------------------------------------------------

#ifndef AT91C_ID_TC0
#if defined(AT91C_ID_TC012)
    #define AT91C_ID_TC0 AT91C_ID_TC012
#elif defined(AT91C_ID_TC)
    #define AT91C_ID_TC0 AT91C_ID_TC
#else
    #error Pb define ID_TC
#endif
#endif

/// Maximum Bytes Per Second (BPS) rate that will be forced using the CTS pin.
#define MAX_BPS             550

/// Size of the receive buffer used by the PDC, in bytes.
#define BUFFER_SIZE         1

/// PIT period value (useconds)
#define PIT_PERIOD        1000
/// Delay for pushbutton debouncing (ms)
#define DEBOUNCE_TIME       10


// Pio HexSwitch Read 
#define HEX_SW_ADD1_1 {1 << 19, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
#define HEX_SW_ADD1_2 {1 << 20, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
#define HEX_SW_ADD1_3 {1 << 21, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
#define HEX_SW_ADD1_4 {1 << 22, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}

#define HEX_SW_ADD2_1 {1 << 28, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
#define HEX_SW_ADD2_2 {1 << 29, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
#define HEX_SW_ADD2_3 {1 << 30, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
#define HEX_SW_ADD2_4 {1 << 31, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}

#define ARM_RUN_LED_OUT {1 << 3, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_0,PIO_DEFAULT}


#define BUFFER_ADDRESS (AT91C_EBI_SDRAM)


unsigned int SPI_PDC_sandframe(char *pBUFFER, unsigned int szBUFFER, char *pNEXTBUFFER, unsigned int szNEXTBUFFER);

extern  At26 at26;
//------------------------------------------------------------------------------
//         Local variables
//------------------------------------------------------------------------------

/// Pins to configure for the application.
const Pin pins[] = {
    PINS_DBGU,
    PIN_USART0_RXD,
    PIN_USART0_TXD,
    PIN_USART0_CTS,
    PIN_USART0_RTS,
    
    HEX_SW_ADD1_1,
    HEX_SW_ADD1_2,
    HEX_SW_ADD1_3,
    HEX_SW_ADD1_4,
    
    HEX_SW_ADD2_1,
    HEX_SW_ADD2_2,
    HEX_SW_ADD2_3,
    HEX_SW_ADD2_4,
    PINS_NORFLASH,
    ARM_RUN_LED_OUT
};

/// Number of bytes received between two timer ticks.
volatile unsigned int bytesReceived = 0;

/// Receive buffer.
unsigned char pBuffer[BUFFER_SIZE];

/// String buffer.
char pString[24];

//타이머 1ms 
volatile unsigned int mTimerFlag = 0;
volatile unsigned int mTimerDebugCnt = 0;


unsigned int RxTimerCnt = 0;
unsigned int RxTimerBuf[100];
unsigned int RxTimerBufCnt = 0;


UCHAR mHexSwitchAdd = 0;



extern int mScanVidioFlag;
extern int CHACK_DATA;

//------------------------------------------------------------------------------
//         Local functions
//------------------------------------------------------------------------------

//------------------------------------------------------------------------------
/// Interrupt handler for USART0. Increments the number of bytes received in the
/// current second and starts another transfer if the desired bps has not been
/// met yet.
//------------------------------------------------------------------------------

void ISR_Usart0(void)
{
    unsigned int status;

    // Read USART status
    status = AT91C_BASE_US0->US_CSR;
    
    //AT91C_US_TXBUFE

    // Receive buffer is full
    if ((status & AT91C_US_RXBUFF) == AT91C_US_RXBUFF) {

        bytesReceived += BUFFER_SIZE;

        // Restart transfer if BPS is not high enough
        if (bytesReceived < MAX_BPS) {

            USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
            
            SCC_ISR(pBuffer[0]);
            
        }
        // Otherwise disable interrupt
        else {

            AT91C_BASE_US0->US_IDR = AT91C_US_RXBUFF;
        }
    }
}

//------------------------------------------------------------------------------
/// Interrupt handler for TC0. Displays the number of bytes received during the
/// last second and the total number of bytes received, then restarts a read
/// transfer on the USART if it was stopped.
//------------------------------------------------------------------------------

UINT mTc1_Cnt = 0;
void ISR_Tc0(void)
{
    unsigned int status;
    static unsigned int bytesTotal = 0;

    // Read TC0 status
    status = AT91C_BASE_TC0->TC_SR;

    // RC compare
    if ((status & AT91C_TC_CPCS) == AT91C_TC_CPCS) {
  
        // Display info
        bytesTotal += bytesReceived;
        //sprintf(pString, "Bps: %4u; Tot: %6u\r", bytesReceived, bytesTotal);
        //USART_WriteBuffer(AT91C_BASE_US0, pString, sizeof(pString));
        bytesReceived = 0;

        // 통신 수신 인터럽트가 발생 하였는지 다시 한번 확인 하는 부분.
        // Resume transfer if needed
        if (AT91C_BASE_US0->US_RCR == 0) {
            USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
            AT91C_BASE_US0->US_IER = AT91C_US_RXBUFF;
        }
    }
}
/****************************************************************************/
// 1 = RED : 2 = GREEN : 3 = AMBER
// 
/****************************************************************************/


void ISR_Tc1(void)
{
   unsigned int status;
   static UINT sLineCnt = 15;
   static UINT sLineCnt2 = 0;
   UCHAR *pVd = (UCHAR *)DOT_VIDEO;
   static UINT sScreenSize = 224;
   
    // Read TC0 status
    status = AT91C_BASE_TC1->TC_SR;
    
    
    //if( ADD_CHECK() == 0x0F || ADD_CHECK() == 0x1F ){ sScreenSize = 96;}
    //else {sScreenSize = 224;}
      
    // RC compare
    
    if (((status & AT91C_TC_CPCS) == AT91C_TC_CPCS))
    {
         // Module Data Tx Enable

          if(mScanVidioFlag || sLineCnt2 != 0)
          {
                  *(char *)0x30400000 = 0x00; // OE_Off
                  *(char *)0x30400000 = 0x03; // OE_ON
                   
                  *(char *)0x30600000 = 0x00; // LT_Off
                  *(char *)0x30600000 = 0x03; // LT_On
                  
                  *(char *)0x30600000 = 0x00; // LT_off 
                  *(char *)0x30400000 = 0x00; // OE_off
                  
                 *(char *)0x30000000 = (sLineCnt); // addres
                 
                  AT26_Write(&at26,&pVd[((sLineCnt2)*sScreenSize)], (sScreenSize+1), 0);
                  
                  sLineCnt++;
                  sLineCnt = sLineCnt%16;
                  
                  sLineCnt2++;
                  sLineCnt2 = sLineCnt2%16;
          }
    }
 
}

//------------------------------------------------------------------------------
/// Configures USART0 in hardware handshaking mode, asynchronous, 8 bits, 1 stop
/// bit, no parity, 115200 bauds and enables its transmitter and receiver.
//------------------------------------------------------------------------------
void ConfigureUsart0(void)
{
    unsigned int mode = //AT91C_US_USMODE_HWHSH
                          AT91C_US_USMODE_RS485
                        | AT91C_US_CLKS_CLOCK
                        | AT91C_US_CHRL_8_BITS
                        | AT91C_US_PAR_NONE
                        | AT91C_US_NBSTOP_1_BIT
                        | AT91C_US_CHMODE_NORMAL;

    // Enable the peripheral clock in the PMC
    PMC_EnablePeripheral(AT91C_ID_US0);

    // Configure the USART in the desired mode @115200 bauds
    USART_Configure(AT91C_BASE_US0, mode, 9600, BOARD_MCK);

    // Configure the RXBUFF interrupt
    AIC_ConfigureIT(AT91C_ID_US0, 0, ISR_Usart0);
    AIC_EnableIT(AT91C_ID_US0);

    // Enable receiver & transmitter
    USART_SetTransmitterEnabled(AT91C_BASE_US0, 1);
    USART_SetReceiverEnabled(AT91C_BASE_US0, 1);
}

//------------------------------------------------------------------------------
/// Configures Timer Counter 0 (TC0) to generate an interrupt every second. This
/// interrupt will be used to display the number of bytes received on the USART.
//------------------------------------------------------------------------------

void ConfigureTc0(void)
{
	unsigned int div, tcclks;
	//------------------------------------------------------------//
	// Enable TC0 peripheral clock
	PMC_EnablePeripheral(AT91C_ID_TC0);
   
	/// Configure TC for a 1s (= 1Hz) tick
	TC_FindMckDivisor(1, BOARD_MCK, &div, &tcclks);
	TC_Configure(AT91C_BASE_TC0, tcclks | AT91C_TC_CPCTRG);
	AT91C_BASE_TC0->TC_RC = (BOARD_MCK / (2 * div)); //500ms

	// Configure interrupt on RC compare
	AIC_ConfigureIT(AT91C_ID_TC0, 0, ISR_Tc0);
	AT91C_BASE_TC0->TC_IER = AT91C_TC_CPCS;
	AIC_EnableIT(AT91C_ID_TC0);
}

void ConfigureTc1(void)
{
	unsigned int div, tcclks;
   
	PMC_EnablePeripheral(AT91C_ID_TC1);
   
	TC_FindMckDivisor(1, BOARD_MCK, &div, &tcclks);
	TC_Configure(AT91C_BASE_TC1, tcclks | AT91C_TC_CPCTRG);
	AT91C_BASE_TC1->TC_RC = (BOARD_MCK / (2100 * div)); // 약 235마이크로 동작 속도
   
	AIC_ConfigureIT(AT91C_ID_TC1, 0, ISR_Tc1);
	AT91C_BASE_TC1->TC_IER = AT91C_TC_CPCS;
	AIC_EnableIT(AT91C_ID_TC1);

}

//------------------------------------------------------------------------------
/// Interrupt service routine for the PIT. Debounces the wake-up pin input.
//------------------------------------------------------------------------------
static void ISR_Pit(void)
{
    unsigned long pisr = 0;

    // Read the PISR
    pisr = PIT_GetStatus() & AT91C_PITC_PITS;

    if (pisr != 0) {

        // Read the PIVR. It acknowledges the IT
        PIT_GetPIVR();
        
         mTimerFlag = TRUE;
    }

}

//------------------------------------------------------------------------------
/// Configures the PIT to generate 1ms ticks. 
//------------------------------------------------------------------------------
static void ConfigurePit(void)
{
    // Initialize and enable the PIT
    PIT_Init(PIT_PERIOD, BOARD_MCK / 1000000);

    // Disable the interrupt on the interrupt controller
    AIC_DisableIT(AT91C_ID_SYS);

    // Configure the AIC for PIT interrupts
    AIC_ConfigureIT(AT91C_ID_SYS, 0, ISR_Pit);

    // Enable the interrupt on the interrupt controller
    AIC_EnableIT(AT91C_ID_SYS);

    // Enable the interrupt on the pit
    PIT_EnableIT();

    // Enable the pit
    PIT_Enable();
}

//------------------------------------------------------------------------------
//         SW_TIMER (1ms)
//------------------------------------------------------------------------------
void SW_TIMER(void)
{
	static int sSw_Timer_Cnt = 0; 
  
	mTimerDebugCnt++;
	SCC_ISR_Timer(); // 통신 함수 타이머 
  
	if(!(mTimerDebugCnt%100))
	{
		sSw_Timer_Cnt++;
		AT91C_BASE_PIOA->PIO_ODSR ^= AT91C_PIO_PA3;	//해당핀을 출력 토글	
    
	}
}

//**********************************************************************************
//	HEXA 값을 읽어 온다..
//**********************************************************************************
unsigned char ChackHexa(void)
{
	unsigned char H_Add_Buff=0;
	unsigned char L_Add_Buff=0;        

	H_Add_Buff  = PIO_Get(&pins[5])<<3;
	H_Add_Buff |= PIO_Get(&pins[6])<<2;
	H_Add_Buff |= PIO_Get(&pins[7])<<1;
	H_Add_Buff |= PIO_Get(&pins[8])&0x01;      

	L_Add_Buff  = PIO_Get(&pins[9])<<3;
	L_Add_Buff |= PIO_Get(&pins[10])<<2;
	L_Add_Buff |= PIO_Get(&pins[11])<<1;
	L_Add_Buff |= PIO_Get(&pins[12])&0x01;       
          
	return ~((H_Add_Buff<<4)|L_Add_Buff);
}

//**********************************************************************************
//	ADD_CHECK
//**********************************************************************************
int ADD_CHECK(void)
{
	// 장치 어드레스 인식 부분,
	if(!mHexSwitchAdd)
	{
		mHexSwitchAdd = ChackHexa();
	}
	return mHexSwitchAdd;
}
//**********************************************************************************
//	MODE_SET
//**********************************************************************************
void MODE_SET(void)
{
        AT91C_BASE_PIOA->PIO_OER   = AT91C_PIO_PA3;	//출력 버퍼 ENABLE
	AT91C_BASE_PIOA->PIO_PER   = AT91C_PIO_PA3;	//IO 포트로 사용
	AT91C_BASE_PIOA->PIO_PPUDR = AT91C_PIO_PA3;	//각 핀을 풀업하지 않음
	AT91C_BASE_PIOA->PIO_OWER  = AT91C_PIO_PA3;	//각 핀을 IO 동시 출력으로 설정함    
	AT91C_BASE_PIOA->PIO_BSR= ((unsigned int) AT91C_PA20_NCS2_CFCS1);
	AT91C_BASE_PIOA->PIO_PDR =((unsigned int) AT91C_PA20_NCS2_CFCS1); 	
}

//------------------------------------------------------------------------------
/// Application entry point. Configures USART0 in hardware handshaking mode and
/// Timer Counter 0 to generate an interrupt every second. Then, starts the first
/// transfer on the USART and wait in an endless loop.
/// \return Unused.
//------------------------------------------------------------------------------
UCHAR TextBuf[1024];
UCHAR TextBuf_2[1024];


int main(void)
{
    
  
    //unsigned int i = 0;
    
    *AT91C_RSTC_RMR=0xA5000A01;//Reset Enable

    unsigned char *pSRamBuffer = (unsigned char *) AT91C_EBI_SDRAM;
    
       /* nandflash memory 변수 */ 
    unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
    unsigned char testFailed;
    const unsigned char busWidth[3] = {FLASH_CHIP_WIDTH_8BITS, FLASH_CHIP_WIDTH_16BITS, FLASH_CHIP_WIDTH_32BITS};
    
   
    // Configure pins
    PIO_Configure(pins, PIO_LISTSIZE(pins));
    
        //SDRAM 설정 
    BOARD_ConfigureSdram(BOARD_SDRAM_BUSWIDTH);
    
     /************ TCO(통신 수신 확인) 설정 및 통신 설정.***************************/
    ConfigureUsart0(); // 통신 설정.
    ConfigureTc0();    // 타이머 설정.
    
     // Start receiving data and start timer
    USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
    AT91C_BASE_US0->US_IER = AT91C_US_RXBUFF;
    
    TC_Start(AT91C_BASE_TC0); // 타이머 시작 
    
     /***********SPI 설정. ***************************/
    SPI_Init(); //1Byte 1마이크로 
    
    
    //LED Display Timer 설정.
    ConfigureTc1();
    
    
    //TC_Stop(AT91C_BASE_TC1);

    // 타이머 설정 1ms
    ConfigurePit();
   
    memcpy(RxTimerBuf,0x00,sizeof(RxTimerBuf));
    //memset(TextBuf,0x11,5000);
    
    MODE_SET();
    
    SCC_Init(); // 통신 함수 초기화 부분.
    
    
    
    TC_Start(AT91C_BASE_TC1);
    
    ////////////////////////////////////////////////

    norFlash.norFlashInfo.baseAddress = BOARD_NORFLASH_ADDR;

    BOARD_ConfigureNorFlash48MHz(FLASH_CHIP_WIDTH_8BITS * 8);
    NorFlash_CFI_Detect(&norFlash, FLASH_CHIP_WIDTH_8BITS);
        
       
    Display_Init();
   
    /// Infinite loop
    while (1)
    {
      
        if(mTimerFlag) // 1ms OP 
        {
          mTimerFlag = FALSE;
          SW_TIMER();
          
          ADD_CHECK(); // PCB ADD Check

          Down_int09();

          LED_Display_c_int10();
        }
        
          if(SCC1_Init_AChl.RxDownloadStart){ Download_main();}
          else 
          {
            Display_main();
            
          }
        
      
    }

    
}

