###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     02/Sep/2014  08:12:09 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\Down #
#                    load.c                                                   #
#    Command line =  "C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\Down #
#                    load.c" -D at91sam7se512 -D sdram -D TRACE_LEVEL=4 -lC   #
#                    "C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_sdram\List\" --remarks --diag_suppress     #
#                    Pe826,Pe1375 -o "C:\Users\JDS_Retina\Dropbox\회사\JDS_PR #
#                    O\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512 #
#                    _Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-proje #
#                    ct\ewp\at91sam7se512_sdram\Obj\" --no_cse --no_unroll    #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/peripherals\" -I                        #
#                    "C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib\" -I "C:\Users\JDS_Retina\Dropbox\회사\ #
#                    JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam #
#                    7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking #
#                    -project\ewp\..\..\..\at91lib/components\" -I            #
#                    "C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/boards/at91sam7se-ek\" --interwork      #
#                    --cpu_mode arm -Oh --use_c++_inline                      #
#    List file    =  C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_sdram\List\Download.lst                    #
#    Object file  =  C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_sdram\Obj\Download.o                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c
      1          #include <stdio.h>
      2          #include "Download.h"

  #endif
        ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.h",44  Remark[Pe001]: 
          last line of file ends without a newline

  #endif
        ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.h",32  Remark[Pe001]: 
          last line of file ends without a newline
      3          #include "LED_Display.h"

  #endif
        ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\UART.h",43  Remark[Pe001]: 
          last line of file ends without a newline

  #endif
        ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\LED_Display.h",121  Remark[Pe001]: 
          last line of file ends without a newline
      4          #include "main.h"
      5          #include "UART.h"
      6          #include <board.h>
      7          #include <usart/usart.h>
      8          #include <memories/norflash/NorFlashCFI.h>
      9          #include <memories/norflash/NorFlashApi.h>
     10          
     11          #define VERSION 0x10 // 버젼
     12          
     13          #define SCC_DOWNLOAD_CODE 0x13 // 다운로드 하기
     14          #define SCC_ERASE_CODE 0x01 // Flash 메모리 지우기
     15          #define SCC_DOWNLOAD_START_CODE 0x1F // 다운로드를 시작한다.
     16          #define SCC_STATUS_REQ 0x07 // 상태요구
     17          #define SCC_STATUS_RLY 0x08 // 상태요구응답
     18          
     19          #define TX_ENABLE_TIME 20 // 데이터를 전송하기전에 지연시간
     20          #define TX_DISABLE_TIME 5 // 데이터를 전송후 지연시간
     21          
     22          #define IDD 0xF1 // 차내
     23          #define FDD 0xF5 // 정면
     24          #define SDD 0xF6 // 측면
     25          #define TN  0xF7 // 열번
     26          #define LDD 0xF9 // 노선
     27          #define HDD 0xF4 // 호차
     28          
     29          #define IS_IDD_NO(x) (x >= 1 && x <= 4)
     30          #define IS_FDD_NO(x) (x == 0x0F)
     31          #define IS_SDD_NO(x) (x == 0x0A || x == 0x0B)
     32          #define IS_TN_NO(x) (x == 0x0D)
     33          #define IS_LDD_NO(x) (x >= 5 && x <= 8)
     34          #define IS_HDD_NO(x) (x == 0x09 || x == 0x0E)
     35          
     36          #define MEMORY_ERASE_OK 0x10 // 메모리 ERASE OK
     37          #define MEMORY_ERASE_NG 0x11 // 메모리 ERASE NG
     38          
     39          #define OK 0 // OK
     40          #define NG 1 // NG
     41          
     42          #define MEM_RECORD_SIZE 128 // 다운로드시 한 레코드 크기
     43          
     44          #define FIRMWARE_EXECUTION_TIME 10000 // 2000ms
     45          
     46          #define SCREEN_CENTER_POS ((SCREEN_WIDTH_MAX / 2)-16)
     47          

   \                                 In section .bss, align 4
     48          int mBlackChick[100]; // 삭제 블럭 사이즈 리턴.
   \                     mBlackChick:
   \   00000000                      DS8 400

   \                                 In section .bss, align 4
     49          int mBlockSize = 0;
   \                     mBlockSize:
   \   00000000                      DS8 4
     50          
     51          

   \                                 In section .data, align 4
     52          DWORD gVerName[16]=
   \                     gVerName:
   \   00000000   0x00000000         DC32 0, 262148, 545537924, 545522748, 545524228, 545526020, 1065619716
   \              0x00040004   
   \              0x20843F84   
   \              0x2084043C   
   \              0x20840A04   
   \              0x20841104   
   \              0x3F841104   
   \   0000001C   0x20BC20BC         DC32 549200060, 545529988, 545521668, 545521664, 545529856, 545529856
   \              0x20842084   
   \              0x20840004   
   \              0x20840000   
   \              0x20842000   
   \              0x20842000   
   \   00000034   0x3F842000         DC32 1065623552, 278524, 0
   \              0x00043FFC   
   \              0x00000000   
     53          {
     54          	0x00000000,
     55          	0x00040004,
     56          	0x20843F84,
     57          	0x2084043C,
     58          	0x20840A04,
     59          	0x20841104,
     60          	0x3F841104,
     61          	0x20BC20BC,
     62          	0x20842084,
     63          	0x20840004,
     64          	0x20840000,
     65          	0x20842000,
     66          	0x20842000,
     67          	0x3F842000,
     68          	0x00043FFC,
     69          	0x00000000
     70          };
     71          

   \                                 In section .data, align 4
     72          UCHAR gDigitName[16*16]=
   \                     gDigitName:
   \   00000000   0x00 0x00          DC8 0, 0, 124, 98, 99, 115, 123, 123, 111, 103, 103, 99, 35, 31, 0, 0
   \              0x7C 0x62    
   \              0x63 0x73    
   \              0x7B 0x7B    
   \              0x6F 0x67    
   \              0x67 0x63    
   \              0x23 0x1F    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 24, 60, 108, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0
   \              0x18 0x3C    
   \              0x6C 0x0C    
   \              0x0C 0x0C    
   \              0x0C 0x0C    
   \              0x0C 0x0C    
   \              0x0C 0x0C    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000022   0x7C 0x62          DC8 124, 98, 99, 99, 103, 14, 28, 56, 112, 96, 96, 127, 0, 0, 0, 0, 124
   \              0x63 0x63    
   \              0x67 0x0E    
   \              0x1C 0x38    
   \              0x70 0x60    
   \              0x60 0x7F    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x7C         
   \   00000033   0x62 0x63          DC8 98, 99, 3, 3, 30, 3, 3, 99, 99, 35, 31, 0, 0, 0, 0, 24, 60, 102
   \              0x03 0x03    
   \              0x1E 0x03    
   \              0x03 0x63    
   \              0x63 0x23    
   \              0x1F 0x00    
   \              0x00 0x00    
   \              0x00 0x18    
   \              0x3C 0x66    
   \   00000045   0x66 0x66          DC8 102, 102, 102, 102, 102, 102, 127, 6, 6, 0, 0, 0, 0, 126, 96, 96
   \              0x66 0x66    
   \              0x66 0x66    
   \              0x7F 0x06    
   \              0x06 0x00    
   \              0x00 0x00    
   \              0x00 0x7E    
   \              0x60 0x60    
   \   00000055   0x60 0x60          DC8 96, 96, 127, 3, 3, 99, 99, 35, 31, 0, 0, 0, 0, 124, 98, 99, 96, 96
   \              0x7F 0x03    
   \              0x03 0x63    
   \              0x63 0x23    
   \              0x1F 0x00    
   \              0x00 0x00    
   \              0x00 0x7C    
   \              0x62 0x63    
   \              0x60 0x60    
   \   00000067   0x7F 0x63          DC8 127, 99, 99, 99, 99, 35, 31, 0, 0, 0, 0, 124, 2, 3, 3, 3, 3, 3, 3
   \              0x63 0x63    
   \              0x63 0x23    
   \              0x1F 0x00    
   \              0x00 0x00    
   \              0x00 0x7C    
   \              0x02 0x03    
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03         
   \   0000007A   0x03 0x03          DC8 3, 3, 3, 3, 0, 0, 0, 0, 124, 98, 99, 99, 99, 62, 99, 99, 99, 99, 35
   \              0x03 0x03    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x7C 0x62    
   \              0x63 0x63    
   \              0x63 0x3E    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x23         
   \   0000008D   0x1F 0x00          DC8 31, 0, 0, 0, 0, 124, 98, 99, 99, 99, 99, 127, 3, 3, 99, 35, 31, 0
   \              0x00 0x00    
   \              0x00 0x7C    
   \              0x62 0x63    
   \              0x63 0x63    
   \              0x63 0x7F    
   \              0x03 0x03    
   \              0x63 0x23    
   \              0x1F 0x00    
   \   0000009F   0x00 0x00          DC8 0, 0, 0, 124, 102, 99, 99, 99, 99, 127, 99, 99, 99, 99, 99, 0, 0, 0
   \              0x00 0x7C    
   \              0x66 0x63    
   \              0x63 0x63    
   \              0x63 0x7F    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x63 0x00    
   \              0x00 0x00    
   \   000000B1   0x00 0x78          DC8 0, 120, 108, 108, 108, 108, 127, 99, 99, 99, 99, 99, 127, 0, 0, 0
   \              0x6C 0x6C    
   \              0x6C 0x6C    
   \              0x7F 0x63    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x7F 0x00    
   \              0x00 0x00    
   \   000000C1   0x00 0x7C          DC8 0, 124, 102, 99, 97, 96, 96, 96, 96, 96, 96, 96, 127, 0, 0, 0, 0
   \              0x66 0x63    
   \              0x61 0x60    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x7F 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000D2   0x78 0x6C          DC8 120, 108, 102, 99, 99, 99, 99, 99, 99, 99, 99, 127, 0, 0, 0, 0, 124
   \              0x66 0x63    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x63 0x7F    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x7C         
   \   000000E3   0x60 0x60          DC8 96, 96, 96, 96, 126, 96, 96, 96, 96, 96, 127, 0, 0, 0, 0, 124, 96
   \              0x60 0x60    
   \              0x7E 0x60    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x7F 0x00    
   \              0x00 0x00    
   \              0x00 0x7C    
   \              0x60         
   \   000000F4   0x60 0x60          DC8 96, 96, 96, 126, 96, 96, 96, 96, 96, 96, 0, 0
   \              0x60 0x7E    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x00 0x00    
     73          {
     74          	0x00,0x00,0x7C,0x62,0x63,0x73,0x7B,0x7B,0x6F,0x67,0x67,0x63,0x23,0x1F,0x00,0x00,
     75          	0x00,0x00,0x18,0x3C,0x6C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x00,0x00,
     76          	0x00,0x00,0x7C,0x62,0x63,0x63,0x67,0x0E,0x1C,0x38,0x70,0x60,0x60,0x7F,0x00,0x00,
     77          	0x00,0x00,0x7C,0x62,0x63,0x03,0x03,0x1E,0x03,0x03,0x63,0x63,0x23,0x1F,0x00,0x00,
     78          	0x00,0x00,0x18,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x7F,0x06,0x06,0x00,0x00,
     79          	0x00,0x00,0x7E,0x60,0x60,0x60,0x60,0x7F,0x03,0x03,0x63,0x63,0x23,0x1F,0x00,0x00,
     80          	0x00,0x00,0x7C,0x62,0x63,0x60,0x60,0x7F,0x63,0x63,0x63,0x63,0x23,0x1F,0x00,0x00,
     81          	0x00,0x00,0x7C,0x02,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,
     82          	0x00,0x00,0x7C,0x62,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x23,0x1F,0x00,0x00,
     83          	0x00,0x00,0x7C,0x62,0x63,0x63,0x63,0x63,0x7F,0x03,0x03,0x63,0x23,0x1F,0x00,0x00,
     84          	0x00,0x00,0x7C,0x66,0x63,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x63,0x63,0x00,0x00,
     85          	0x00,0x00,0x78,0x6C,0x6C,0x6C,0x6C,0x7F,0x63,0x63,0x63,0x63,0x63,0x7F,0x00,0x00,
     86          	0x00,0x00,0x7C,0x66,0x63,0x61,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7F,0x00,0x00,
     87          	0x00,0x00,0x78,0x6C,0x66,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x7F,0x00,0x00,
     88          	0x00,0x00,0x7C,0x60,0x60,0x60,0x60,0x7E,0x60,0x60,0x60,0x60,0x60,0x7F,0x00,0x00,
     89          	0x00,0x00,0x7C,0x60,0x60,0x60,0x60,0x7E,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00
     90          };
     91          
     92          
     93          extern SCC_INIT_SHAPE SCC1_Init_AChl; // 85C30의 송수신 버퍼 및 플래그
     94          extern struct NorFlash norFlash;
     95          
     96          extern int mScanVidioFlag;
     97          /***********************************************************************
     98          	변수 정의
     99          ************************************************************************/
    100          //int glDebugCnt = 0;
    101          
    102          typedef struct
    103          {
    104          	int nComm;
    105          	int nErase;
    106          	int nDownload;
    107          } STATUS_FLAG;
    108          

   \                                 In section .bss, align 4
    109          int gTxEnableTimerCnt = 0; // 전송하기전 몇 ms는 기다림
   \                     gTxEnableTimerCnt:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    110          int gTxDisableTimerCnt = 0; // 전송후 몇 ms 기다리고 RTS닫음
   \                     gTxDisableTimerCnt:
   \   00000000                      DS8 4
    111          

   \                                 In section .bss, align 4
    112          int gVersionPrintFlag = FALSE;
   \                     gVersionPrintFlag:
   \   00000000                      DS8 4
    113          

   \                                 In section .data, align 4
    114          int SCREEN_WIDTH_MAX = 128; // 가로 쩜의 갯수
   \                     SCREEN_WIDTH_MAX:
   \   00000000   0x00000080         DC32 128
    115          

   \                                 In section .bss, align 4
    116          int gFirmWareExeTime = 0;
   \                     gFirmWareExeTime:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
    117          int gFirmWareExeFlag = TRUE;
   \                     gFirmWareExeFlag:
   \   00000000   0x00000001         DC32 1
    118          

   \                                 In section .bss, align 4
    119          UINT gERASE_OkFlag = 0;
   \                     gERASE_OkFlag:
   \   00000000                      DS8 4
    120          
    121          
    122          

   \                                 In section .text, align 4, keep-with-next
    123          void Download_Init(void)
    124          {
    125          
    126          }
   \                     Download_Init:
   \   00000000   0xE12FFF1E         BX       LR               ;; return
    127          /***********************************************************************
    128          	메인 프로그램
    129          ************************************************************************/
    130          

   \                                 In section .text, align 4, keep-with-next
    131          void Download_main(void)
    132          {
    133          	int i,j,blockSize,pageSize;
    134          	UINT nLen;
    135          	UINT nCrc;
    136          	int nOkPtcCnt;
    137          	int nOkPtcOldCnt;
    138          	UCHAR pText[200];
    139          	UCHAR *pNorFlshAddr = (UCHAR *)(BOARD_NORFLASH_ADDR);
    140          	UCHAR *pNorFlshProgAddr = (UCHAR *)(BOARD_NORFLASH_ADDR + 0x3C0000);
    141          	UCHAR *pVideoMem = (UCHAR *)DOT_VIDEO_DATA;
    142          
    143          	UINT nFlshWrAddr;
    144                  
    145                  /*
    146          	ScreenWidth();
    147                  VersionImagePut();
    148          
    149          	//memset(&pVideoMem[0],NG,512*1024); // Erase&Program 상태 NG 초기화
    150          	
    151          	
    152          	//nOkPtcCnt = nOkPtcOldCnt = 0;
    153          	
    154          	//gFirmWareExeTime = 0; // 2초 안에 다운로드 시작 프로토콜이 안들어오면 표시기 Firmware 수행
    155          	//gFirmWareExeFlag = TRUE;
    156          
    157          
    158          	// 처음엔 버젼을 출력하지않는다.
    159          	//gVersionPrintFlag = FALSE;
    160          	// 다운로드 준비이면 화면에 버젼을 출력한다.
    161          	//VersionImagePut();
    162          
    163          	//while(SCC1_Init_AChl.RxDownloadStart)
    164          	//{
    165          
    166          		/*
                 		^
Warning[Pe009]: nested comment is not allowed
    167          		if((gFirmWareExeTime >= FIRMWARE_EXECUTION_TIME) && (gFirmWareExeFlag == TRUE))
    168          		{
    169          			
    170          			if((WORD_L(pNorFlshProgAddr[0]) != 0xFF)) // 프로그램 영역이 전부 지워졌다면 수행하지 않는다.
    171          			{
    172          				// Video Memory에 전송되어진 데이터를 0x00를 쓴다.
    173          				memset(DOT_VIDEO,0x00,0x1000);
    174                                          SCC1_Init_AChl.RxDownloadStart = FALSE;
    175          	
    176          			}			
    177          		}
    178          
    179                  */
    180          		// 전부 수신되었다면..
    181          		if(SCC1_Init_AChl.RxOK == TRUE)
   \                     Download_main:
   \   00000000   0x........         LDR      R0,??DataTable4
   \   00000004   0xE5900018         LDR      R0,[R0, #+24]
   \   00000008   0xE3500001         CMP      R0,#+1
   \   0000000C   0x0A000000         BEQ      ??Download_main_0
    182          		{
    183                                  TC_Stop(AT91C_BASE_TC1);
                                         ^
Warning[Pe223]: function "TC_Stop" declared implicitly
   \   00000010   0xE12FFF1E         BX       LR
   \                     ??Download_main_0:
   \   00000014   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000018   0xE24DD0CC         SUB      SP,SP,#+204
   \   0000001C   0x........         LDR      R0,??DataTable4_1  ;; 0xfffa0040
   \   00000020   0x........         BL       TC_Stop
    184                                  
    185          			SCC1_Init_AChl.RxOK = FALSE;			
   \   00000024   0x........         LDR      R0,??DataTable4
   \   00000028   0xE3A01000         MOV      R1,#+0
   \   0000002C   0xE5801018         STR      R1,[R0, #+24]
    186          			
    187          			//pText = &SCC1_Init_AChl.pRxBufferBackup[7]; 
    188                                  
    189                                  memcpy(pText,&SCC1_Init_AChl.pRxBufferBackup[7],SCC1_Init_AChl.RxOKDataLen+3);
                                         ^
Warning[Pe223]: function "memcpy" declared implicitly

  	int i,j,blockSize,pageSize;
  	      ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",133  Warning[Pe177]: 
          variable "j" was declared but never referenced

  	int i,j,blockSize,pageSize;
  	                  ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",133  Warning[Pe550]: 
          variable "pageSize" was set but never used

  	UINT nLen;
  	     ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",134  Warning[Pe177]: 
          variable "nLen" was declared but never referenced

  	UINT nCrc;
  	     ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",135  Warning[Pe177]: 
          variable "nCrc" was declared but never referenced

  	int nOkPtcCnt;
  	    ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",136  Warning[Pe550]: 
          variable "nOkPtcCnt" was set but never used

  	UCHAR *pNorFlshProgAddr = (UCHAR *)(BOARD_NORFLASH_ADDR + 0x3C0000);
  	       ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",140  Warning[Pe177]: 
          variable "pNorFlshProgAddr" was declared but never referenced
   \   00000030   0xE5900020         LDR      R0,[R0, #+32]
   \   00000034   0xE2802003         ADD      R2,R0,#+3
   \   00000038   0x........         LDR      R0,??DataTable4
   \   0000003C   0xE5900030         LDR      R0,[R0, #+48]
   \   00000040   0xE2801007         ADD      R1,R0,#+7
   \   00000044   0xE1A0000D         MOV      R0,SP
   \   00000048   0x........         BL       memcpy
    190          				
    191          			// 통신을 받을때마다 LED를 하나씩 켠다.
    192                                  /*
    193          			switch(pText[2])
    194          			{
    195          			case SCC_DOWNLOAD_START_CODE:
    196          			case SCC_ERASE_CODE:
    197          			case SCC_DOWNLOAD_CODE:				
    198          				if(IsDisplayAddressOk(pText[0]) == FALSE) break; // 원하는 표시기 종류가 아니면 리턴
    199          
    200          				PixelPut(SCREEN_CENTER_POS + nOkPtcOldCnt%32,nOkPtcOldCnt/32 + 16,0);
    201          				nOkPtcOldCnt = nOkPtcCnt;
    202          					
    203          				PixelPut(SCREEN_CENTER_POS + nOkPtcCnt%32,nOkPtcCnt/32 + 16,3);
    204          				nOkPtcCnt = (nOkPtcCnt + 1) % (32*16);
    205          				break;
    206          					
    207          			case SCC_STATUS_REQ:
    208          				if((UCHAR )ADD_CHECK() != pText[0]) break;// 나의 상태를 요구하는것인지 체크
    209          				
    210          				PixelPut(SCREEN_CENTER_POS + nOkPtcOldCnt%32,nOkPtcOldCnt/32 + 16,0);
    211          				nOkPtcOldCnt = nOkPtcCnt;
    212          					
    213          				PixelPut(SCREEN_CENTER_POS + nOkPtcCnt%32,nOkPtcCnt/32 + 16,3);
    214          				nOkPtcCnt = (nOkPtcCnt + 1) % (32*16);
    215          				break;
    216          			}
    217                                  */
    218          				
    219          							
    220          			// Text의 위치를 가르킨다.				
    221          			switch(pText[2])
   \   0000004C   0xE5DD0002         LDRB     R0,[SP, #+2]
   \   00000050   0xE3500001         CMP      R0,#+1
   \   00000054   0x0A000019         BEQ      ??Download_main_1
   \   00000058   0xE3500007         CMP      R0,#+7
   \   0000005C   0x0A00008A         BEQ      ??Download_main_2
   \   00000060   0xE3500013         CMP      R0,#+19
   \   00000064   0x0A00004D         BEQ      ??Download_main_3
   \   00000068   0xE350001F         CMP      R0,#+31
   \   0000006C   0x1A000093         BNE      ??Download_main_4
    222          			{
    223          			// 다운로드 시작.
    224          			case SCC_DOWNLOAD_START_CODE:
    225                                    
    226          
    227          				if(IsDisplayAddressOk(pText[0]) == FALSE) break; // 원하는 표시기 종류가 아니면 리턴
   \   00000070   0xE5DD0000         LDRB     R0,[SP, #+0]
   \   00000074   0x........         BL       IsDisplayAddressOk
   \   00000078   0xE3500000         CMP      R0,#+0
   \   0000007C   0x0A00008F         BEQ      ??Download_main_4
    228          
    229                                          mBlockSize =0; // 
   \   00000080   0x........         LDR      R0,??DataTable4_2
   \   00000084   0xE3A01000         MOV      R1,#+0
   \   00000088   0xE5801000         STR      R1,[R0, #+0]
    230          
    231          				nOkPtcCnt = nOkPtcOldCnt = 0;
    232          				PixelPut(SCREEN_CENTER_POS + nOkPtcOldCnt%32,nOkPtcOldCnt/32 + 16,0);
   \   0000008C   0x........         LDR      R0,??DataTable4_3
   \   00000090   0xE5900000         LDR      R0,[R0, #+0]
   \   00000094   0xE3A02000         MOV      R2,#+0
   \   00000098   0xE3A01010         MOV      R1,#+16
   \   0000009C   0xE0800FA0         ADD      R0,R0,R0, LSR #+31
   \   000000A0   0xE2613000         RSB      R3,R1,#+0
   \   000000A4   0xE08300C0         ADD      R0,R3,R0, ASR #+1
   \   000000A8   0x........         BL       PixelPut
    233          
    234          				gFirmWareExeFlag = FALSE; // 2초후 자동으로 수행하지 못하도록 한다.
   \   000000AC   0x........         LDR      R0,??DataTable4_4
   \   000000B0   0xE3A01000         MOV      R1,#+0
   \   000000B4   0xE5801000         STR      R1,[R0, #+0]
    235          					
    236          				VersionImagePut();
   \   000000B8   0x........         BL       VersionImagePut
    237          				gVersionPrintFlag = IsPrintOfVersion();
   \   000000BC   0xEA00007C         B        ??Download_main_5
    238          				break;
    239          					
    240          			// 특정 메모리를 지움.
    241          			case SCC_ERASE_CODE:
    242          				if(IsDisplayAddressOk(pText[0]) == FALSE) break; // 원하는 표시기 종류가 아니면 리턴
   \                     ??Download_main_1:
   \   000000C0   0xE5DD0000         LDRB     R0,[SP, #+0]
   \   000000C4   0x........         BL       IsDisplayAddressOk
   \   000000C8   0xE3500000         CMP      R0,#+0
   \   000000CC   0x0A00007B         BEQ      ??Download_main_4
    243          				
    244                                          blockSize =  NorFlash_GetDeviceBlockSize(&(norFlash.norFlashInfo), (UINT)WORD_L(pText[5])); // 현재 블럭 사이즈를 리턴한다.
   \   000000D0   0xE5DD1005         LDRB     R1,[SP, #+5]
   \   000000D4   0x........         LDR      R0,??DataTable4_5
   \   000000D8   0x........         BL       NorFlash_GetDeviceBlockSize
   \   000000DC   0xE1A04000         MOV      R4,R0
    245                                          
    246                                          pageSize = NorFlash_GetDeviceNumOfBlocks(&(norFlash.norFlashInfo)); // 전체 블럭 사이즈를 지정
   \   000000E0   0x........         LDR      R0,??DataTable4_5
   \   000000E4   0x........         BL       NorFlash_GetDeviceNumOfBlocks
    247                                          
    248                                          
    249                                          for(i=0;i<(65536/blockSize);i++)
   \   000000E8   0xE3A00B40         MOV      R0,#+65536
   \   000000EC   0xE1A01004         MOV      R1,R4
   \   000000F0   0x........         BL       __aeabi_idiv
   \   000000F4   0xE3500001         CMP      R0,#+1
   \   000000F8   0xBA000015         BLT      ??Download_main_6
   \   000000FC   0xE3A00B40         MOV      R0,#+65536
   \   00000100   0xE1A01004         MOV      R1,R4
   \   00000104   0x........         BL       __aeabi_idiv
   \   00000108   0xE1A05000         MOV      R5,R0
    250                                          {
    251                                                  NORFLASH_EraseSector(&norFlash, NorFlash_GetDeviceSectorAddress(&(norFlash.norFlashInfo),mBlockSize));
   \                     ??Download_main_7:
   \   0000010C   0x........         LDR      R0,??DataTable4_2
   \   00000110   0xE5901000         LDR      R1,[R0, #+0]
   \   00000114   0x........         LDR      R0,??DataTable4_5
   \   00000118   0x........         BL       NorFlash_GetDeviceSectorAddress
   \   0000011C   0xE1A01000         MOV      R1,R0
   \   00000120   0x........         LDR      R0,??DataTable4_6
   \   00000124   0x........         BL       NORFLASH_EraseSector
    252                                                  mBlackChick[mBlockSize] = blockSize;
   \   00000128   0x........         LDR      R0,??DataTable4_2
   \   0000012C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000130   0x........         LDR      R1,??DataTable4_7
   \   00000134   0xE7814100         STR      R4,[R1, +R0, LSL #+2]
    253                                                  mBlockSize++;
   \   00000138   0x........         LDR      R0,??DataTable4_2
   \   0000013C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000140   0xE2800001         ADD      R0,R0,#+1
   \   00000144   0x........         LDR      R1,??DataTable4_2
   \   00000148   0xE5810000         STR      R0,[R1, #+0]
    254                                          }
   \   0000014C   0xE2555001         SUBS     R5,R5,#+1
   \   00000150   0x1AFFFFED         BNE      ??Download_main_7
    255          
    256          				// 메모리를 소거했으므로 소거된 부분의 다운로드 플래그는 NG시킨다.
    257          				for(i=0;i<(pText[5]*64*1024)/MEM_RECORD_SIZE;i++)
   \                     ??Download_main_6:
   \   00000154   0xE3A00000         MOV      R0,#+0
   \   00000158   0xE3A03001         MOV      R3,#+1
   \   0000015C   0xEA000008         B        ??Download_main_8
    258          				{
    259          					pVideoMem[(pText[5]*64*1024)/MEM_RECORD_SIZE + i] = NG;
   \                     ??Download_main_9:
   \   00000160   0xE5DD1005         LDRB     R1,[SP, #+5]
   \   00000164   0xE1A01801         LSL      R1,R1,#+16
   \   00000168   0xE1A02341         ASR      R2,R1,#+6
   \   0000016C   0xE0811CA2         ADD      R1,R1,R2, LSR #+25
   \   00000170   0xE08013C1         ADD      R1,R0,R1, ASR #+7
   \   00000174   0xE3E024DF         MVN      R2,#-553648128
   \   00000178   0xE3C228FE         BIC      R2,R2,#0xFE0000
   \   0000017C   0xE7C13002         STRB     R3,[R1, +R2]
    260          				}
   \   00000180   0xE2800001         ADD      R0,R0,#+1
   \                     ??Download_main_8:
   \   00000184   0xE5DD1005         LDRB     R1,[SP, #+5]
   \   00000188   0xE1A01801         LSL      R1,R1,#+16
   \   0000018C   0xE1A02341         ASR      R2,R1,#+6
   \   00000190   0xE0811CA2         ADD      R1,R1,R2, LSR #+25
   \   00000194   0xE15003C1         CMP      R0,R1, ASR #+7
   \   00000198   0xBAFFFFF0         BLT      ??Download_main_9
    261          
    262          				gFirmWareExeFlag = FALSE; // 2초후 자동으로 수행하지 못하도록 한다.
   \   0000019C   0xEA000041         B        ??Download_main_10
    263          
    264          				gVersionPrintFlag = IsPrintOfVersion();
    265                                          
    266          				break;
    267          				
    268          			// 데이터를 다운로드.
    269          			case SCC_DOWNLOAD_CODE:	
    270          				if(IsDisplayAddressOk(pText[0]) == FALSE) break; // 원하는 표시기 종류가 아니면 리턴
   \                     ??Download_main_3:
   \   000001A0   0xE5DD0000         LDRB     R0,[SP, #+0]
   \   000001A4   0x........         BL       IsDisplayAddressOk
   \   000001A8   0xE3500000         CMP      R0,#+0
   \   000001AC   0x0A000043         BEQ      ??Download_main_4
    271          
    272          				nFlshWrAddr = MAKE_WORD(pText[4],pText[5]);
   \   000001B0   0xE5DD0004         LDRB     R0,[SP, #+4]
   \   000001B4   0xE5DD1005         LDRB     R1,[SP, #+5]
   \   000001B8   0xE1814400         ORR      R4,R1,R0, LSL #+8
    273          	
    274                                          
    275          				// 전부 지워졌는지 검사한다.				
    276          				for(i=0;i<MEM_RECORD_SIZE;i++)
   \   000001BC   0xE3A00000         MOV      R0,#+0
   \   000001C0   0xE1A01384         LSL      R1,R4,#+7
   \   000001C4   0xE2811540         ADD      R1,R1,#+268435456
    277          				{
    278          					if(WORD_L(pNorFlshAddr[(nFlshWrAddr*MEM_RECORD_SIZE) + i]) != 0xFF) break;
   \                     ??Download_main_11:
   \   000001C8   0xE4D12001         LDRB     R2,[R1], #+1
   \   000001CC   0xE35200FF         CMP      R2,#+255
   \   000001D0   0x1A000002         BNE      ??Download_main_12
    279          				}
   \   000001D4   0xE2800001         ADD      R0,R0,#+1
   \   000001D8   0xE3500080         CMP      R0,#+128
   \   000001DC   0xBAFFFFF9         BLT      ??Download_main_11
    280          					
    281          				if(i != MEM_RECORD_SIZE)
   \                     ??Download_main_12:
   \   000001E0   0xE3500080         CMP      R0,#+128
   \   000001E4   0x0A000011         BEQ      ??Download_main_13
    282          				{
    283          					// 지워지지 않았다면 잘 써졌있는지 검사한다.
    284          					for(i=0;i<MEM_RECORD_SIZE;i++)
   \   000001E8   0xE3A00000         MOV      R0,#+0
   \   000001EC   0xE1A01384         LSL      R1,R4,#+7
   \   000001F0   0xE2811540         ADD      R1,R1,#+268435456
   \   000001F4   0xE28D2006         ADD      R2,SP,#+6
    285          					{
    286          						if(WORD_L(pNorFlshAddr[(nFlshWrAddr*MEM_RECORD_SIZE) + i]) != WORD_L(pText[6 + i])) break;
   \                     ??Download_main_14:
   \   000001F8   0xE4D13001         LDRB     R3,[R1], #+1
   \   000001FC   0xE4D2C001         LDRB     R12,[R2], #+1
   \   00000200   0xE153000C         CMP      R3,R12
   \   00000204   0x1A000002         BNE      ??Download_main_15
    287          					}
   \   00000208   0xE2800001         ADD      R0,R0,#+1
   \   0000020C   0xE3500080         CMP      R0,#+128
   \   00000210   0xBAFFFFF8         BLT      ??Download_main_14
    288          						
    289          					// 다운로드가 정상적으로 되었다면 비디오 메모리에 0으로쓰고 아니면 1을 쓴다.
    290          					pVideoMem[nFlshWrAddr] = (i == MEM_RECORD_SIZE) ? OK : NG;
   \                     ??Download_main_15:
   \   00000214   0xE3500080         CMP      R0,#+128
   \   00000218   0x03A00000         MOVEQ    R0,#+0
   \   0000021C   0x13A00001         MOVNE    R0,#+1
   \   00000220   0xE3E014DF         MVN      R1,#-553648128
   \   00000224   0xE3C118FE         BIC      R1,R1,#0xFE0000
   \   00000228   0xE7C40001         STRB     R0,[R4, +R1]
    291          						
    292          					break;
   \   0000022C   0x........         B        ?Subroutine0
    293          				}
    294          					
    295          				
    296          
    297          				NORFLASH_WriteData(&norFlash, (nFlshWrAddr*MEM_RECORD_SIZE), &pText[6], MEM_RECORD_SIZE);
   \                     ??Download_main_13:
   \   00000230   0xE3A03080         MOV      R3,#+128
   \   00000234   0xE28D2006         ADD      R2,SP,#+6
   \   00000238   0xE1A01384         LSL      R1,R4,#+7
   \   0000023C   0x........         LDR      R0,??DataTable4_6
   \   00000240   0x........         BL       NORFLASH_WriteData
    298          					
    299                                          
    300          				// 잘 써졌는지 검사한다.
    301          				for(i=0;i<MEM_RECORD_SIZE;i++)
   \   00000244   0xE3A00000         MOV      R0,#+0
   \   00000248   0xE1A01384         LSL      R1,R4,#+7
   \   0000024C   0xE2811540         ADD      R1,R1,#+268435456
   \   00000250   0xE28D2006         ADD      R2,SP,#+6
    302          				{
    303          					if(WORD_L(pNorFlshAddr[(nFlshWrAddr*MEM_RECORD_SIZE) + i]) != WORD_L(pText[6 + i])) break;
   \                     ??Download_main_16:
   \   00000254   0xE4D13001         LDRB     R3,[R1], #+1
   \   00000258   0xE4D2C001         LDRB     R12,[R2], #+1
   \   0000025C   0xE153000C         CMP      R3,R12
   \   00000260   0x1A000002         BNE      ??Download_main_17
    304          				}
   \   00000264   0xE2800001         ADD      R0,R0,#+1
   \   00000268   0xE3500080         CMP      R0,#+128
   \   0000026C   0xBAFFFFF8         BLT      ??Download_main_16
    305          				
    306          				// 다운로드가 정상적으로 되었다면 비디오 메모리에 0으로쓰고 아니면 1을 쓴다.
    307          				pVideoMem[nFlshWrAddr] = (i == MEM_RECORD_SIZE) ?  OK : NG;					
   \                     ??Download_main_17:
   \   00000270   0xE3500080         CMP      R0,#+128
   \   00000274   0x03A00000         MOVEQ    R0,#+0
   \   00000278   0x13A00001         MOVNE    R0,#+1
   \   0000027C   0xE3E014DF         MVN      R1,#-553648128
   \   00000280   0xE3C118FE         BIC      R1,R1,#0xFE0000
   \   00000284   0xE7C40001         STRB     R0,[R4, +R1]
    308          
    309          				gFirmWareExeFlag = FALSE; // 2초후 자동으로 수행하지 못하도록 한다.
   \   00000288   0xEA000006         B        ??Download_main_10
    310                                          
    311                                        
    312          				gVersionPrintFlag = IsPrintOfVersion();
    313          				break;				
    314          		
    315          			// 상태를 요구.
    316          			case SCC_STATUS_REQ:
    317          				if((UCHAR)ADD_CHECK() != pText[0]) break; // 나의 상태를 요구하는것인지 체크
   \                     ??Download_main_2:
   \   0000028C   0x........         BL       ADD_CHECK
   \   00000290   0xE5DD1000         LDRB     R1,[SP, #+0]
   \   00000294   0xE1A00C00         MOV      R0,R0, LSL #+24
   \   00000298   0xE1510C20         CMP      R1,R0, LSR #+24
   \   0000029C   0x1A000007         BNE      ??Download_main_4
    318          
    319          				SendStatusReq(pText);
   \   000002A0   0xE1A0000D         MOV      R0,SP
   \   000002A4   0x........         BL       SendStatusReq
    320          				gFirmWareExeFlag = FALSE; // 2초후 자동으로 수행하지 못하도록 한다.						
   \                     ??Download_main_10:
   \   000002A8   0x........         LDR      R0,??DataTable4_4
   \   000002AC   0xE3A01000         MOV      R1,#+0
   \   000002B0   0xE5801000         STR      R1,[R0, #+0]
    321          				gVersionPrintFlag = IsPrintOfVersion();
   \                     ??Download_main_5:
   \   000002B4   0x........         BL       IsPrintOfVersion
   \   000002B8   0x........         LDR      R1,??DataTable4_8
   \   000002BC   0xE5810000         STR      R0,[R1, #+0]
    322          				break;
    323          				
    324          			// 상태 응답 프로토콜을 무시한다.
    325          			case SCC_STATUS_RLY:
    326          				break;
    327          				
    328          			// 아무런 해당사항이 없는 프로토콜이면 본 프로그램을 수행
    329          			default:
    330          					
    331          				break;
    332          			}
    333          			
    334          		}
    335          
    336          		//glDebugCnt++;
    337          	//}	
    338          }
   \                     ??Download_main_4:
   \   000002C0                      REQUIRE ?Subroutine0
   \   000002C0                      ;; // Fall through to label ?Subroutine0

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE28DD0CC         ADD      SP,SP,#+204      ;; stack cleaning
   \   00000004   0xE8BD4030         POP      {R4,R5,LR}
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    339          
    340          /***********************************************************************
    341          	화면의 중앙을 계산한다.
    342          ************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    343          void ScreenWidth()
    344          {
   \                     ScreenWidth:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    345          	if(IS_IDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 224; // 차내표시기
   \   00000004   0x........         BL       ADD_CHECK
   \   00000008   0xE200000F         AND      R0,R0,#0xF
   \   0000000C   0xE3500001         CMP      R0,#+1
   \   00000010   0xBA000004         BLT      ??ScreenWidth_0
   \   00000014   0x........         BL       ADD_CHECK
   \   00000018   0xE200000F         AND      R0,R0,#0xF
   \   0000001C   0xE3500005         CMP      R0,#+5
   \   00000020   0xB3A000E0         MOVLT    R0,#+224
   \   00000024   0xBA000025         BLT      ??ScreenWidth_1
    346          	else
    347          	if(IS_FDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 96; // 정면 표시기
   \                     ??ScreenWidth_0:
   \   00000028   0x........         BL       ADD_CHECK
   \   0000002C   0xE200000F         AND      R0,R0,#0xF
   \   00000030   0xE350000F         CMP      R0,#+15
   \   00000034   0x0A000007         BEQ      ??ScreenWidth_2
    348          	else
    349          	if(IS_SDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 96; // 측면 표시기
   \   00000038   0x........         BL       ADD_CHECK
   \   0000003C   0xE200000F         AND      R0,R0,#0xF
   \   00000040   0xE350000A         CMP      R0,#+10
   \   00000044   0x0A000003         BEQ      ??ScreenWidth_2
   \   00000048   0x........         BL       ADD_CHECK
   \   0000004C   0xE200000F         AND      R0,R0,#0xF
   \   00000050   0xE350000B         CMP      R0,#+11
   \   00000054   0x1A000001         BNE      ??ScreenWidth_3
   \                     ??ScreenWidth_2:
   \   00000058   0xE3A00060         MOV      R0,#+96
   \   0000005C   0xEA000017         B        ??ScreenWidth_1
    350          	else
    351          	if(IS_TN_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 64; // 열차번호
   \                     ??ScreenWidth_3:
   \   00000060   0x........         BL       ADD_CHECK
   \   00000064   0xE200000F         AND      R0,R0,#0xF
   \   00000068   0xE350000D         CMP      R0,#+13
   \   0000006C   0x03A00040         MOVEQ    R0,#+64
   \   00000070   0x0A000012         BEQ      ??ScreenWidth_1
    352          	else
    353          	if(IS_LDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 0; // 노선
   \   00000074   0x........         BL       ADD_CHECK
   \   00000078   0xE200000F         AND      R0,R0,#0xF
   \   0000007C   0xE3500005         CMP      R0,#+5
   \   00000080   0xBA000003         BLT      ??ScreenWidth_4
   \   00000084   0x........         BL       ADD_CHECK
   \   00000088   0xE200000F         AND      R0,R0,#0xF
   \   0000008C   0xE3500009         CMP      R0,#+9
   \   00000090   0xBA000009         BLT      ??ScreenWidth_5
    354          	else
    355          	if(IS_HDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 16; // 호차 표시기
   \                     ??ScreenWidth_4:
   \   00000094   0x........         BL       ADD_CHECK
   \   00000098   0xE200000F         AND      R0,R0,#0xF
   \   0000009C   0xE3500009         CMP      R0,#+9
   \   000000A0   0x0A000003         BEQ      ??ScreenWidth_6
   \   000000A4   0x........         BL       ADD_CHECK
   \   000000A8   0xE200000F         AND      R0,R0,#0xF
   \   000000AC   0xE350000E         CMP      R0,#+14
   \   000000B0   0x1A000001         BNE      ??ScreenWidth_5
   \                     ??ScreenWidth_6:
   \   000000B4   0xE3A00010         MOV      R0,#+16
   \   000000B8   0xEA000000         B        ??ScreenWidth_1
    356          	else
    357          		SCREEN_WIDTH_MAX = 0;
   \                     ??ScreenWidth_5:
   \   000000BC   0xE3A00000         MOV      R0,#+0
   \                     ??ScreenWidth_1:
   \   000000C0   0x........         LDR      R1,??DataTable4_3
   \   000000C4   0xE5810000         STR      R0,[R1, #+0]
    358          }
   \   000000C8   0xE8BD4001         POP      {R0,LR}
   \   000000CC   0xE12FFF1E         BX       LR               ;; return
    359          
    360          /***********************************************************************
    361          	차내표시기(0x1F), 정면표시기(0xF5), 측면표시기(0xF6)
    362          	열차번호표시기(0xF7), 노선표시기(0xF9)
    363          ************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    364          int IsDisplayAddressOk(UCHAR nToAddr)
    365          {
   \                     IsDisplayAddressOk:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    366          	switch(nToAddr)
   \   00000004   0xE24000F1         SUB      R0,R0,#+241
   \   00000008   0xE3500008         CMP      R0,#+8
   \   0000000C   0x8A00000C         BHI      ??IsDisplayAddressOk_1
   \   00000010   0xE7DF1000         LDRB     R1,[PC, R0]
   \   00000014   0xE08FF101         ADD      PC,PC,R1, LSL #+2
   \                     ??IsDisplayAddressOk_0:
   \   00000018   0x02 0x0A          DC8      0x2,0xA,0xA,0x29
   \              0x0A 0x29    
   \   0000001C   0x0D 0x11          DC8      0xD,0x11,0x19,0xA
   \              0x19 0x0A    
   \   00000020   0x1F 0x00          DC8      0x1F,0x0,0x0,0x0
   \              0x00 0x00    
    367          	{
    368          	case IDD:if(IS_IDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
   \                     ??IsDisplayAddressOk_2:
   \   00000024   0x........         BL       ADD_CHECK
   \   00000028   0xE200000F         AND      R0,R0,#0xF
   \   0000002C   0xE3500001         CMP      R0,#+1
   \   00000030   0xBA000003         BLT      ??IsDisplayAddressOk_1
   \   00000034   0x........         BL       ADD_CHECK
   \   00000038   0xE200000F         AND      R0,R0,#0xF
   \   0000003C   0xE3500005         CMP      R0,#+5
   \   00000040   0xBA000026         BLT      ??IsDisplayAddressOk_3
    369          	case FDD:if(IS_FDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
    370          	case SDD:if(IS_SDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
    371          	case TN:if(IS_TN_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
    372          	case LDD:if(IS_LDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
    373          	case HDD:if(IS_HDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
    374          	default:
    375          		return FALSE;
    376          	}
    377          
    378          	return FALSE;
   \                     ??IsDisplayAddressOk_1:
   \   00000044   0xE3A00000         MOV      R0,#+0
   \                     ??IsDisplayAddressOk_4:
   \   00000048   0xE8BD4002         POP      {R1,LR}
   \   0000004C   0xE12FFF1E         BX       LR               ;; return
   \                     ??IsDisplayAddressOk_5:
   \   00000050   0x........         BL       ADD_CHECK
   \   00000054   0xE200000F         AND      R0,R0,#0xF
   \   00000058   0xE350000F         CMP      R0,#+15
   \   0000005C   0xEA00000A         B        ??IsDisplayAddressOk_6
   \                     ??IsDisplayAddressOk_7:
   \   00000060   0x........         BL       ADD_CHECK
   \   00000064   0xE200000F         AND      R0,R0,#0xF
   \   00000068   0xE350000A         CMP      R0,#+10
   \   0000006C   0x0A00001B         BEQ      ??IsDisplayAddressOk_3
   \   00000070   0x........         BL       ADD_CHECK
   \   00000074   0xE200000F         AND      R0,R0,#0xF
   \   00000078   0xE350000B         CMP      R0,#+11
   \   0000007C   0xEA000002         B        ??IsDisplayAddressOk_6
   \                     ??IsDisplayAddressOk_8:
   \   00000080   0x........         BL       ADD_CHECK
   \   00000084   0xE200000F         AND      R0,R0,#0xF
   \   00000088   0xE350000D         CMP      R0,#+13
   \                     ??IsDisplayAddressOk_6:
   \   0000008C   0x1AFFFFEC         BNE      ??IsDisplayAddressOk_1
   \   00000090   0xE3A00001         MOV      R0,#+1
   \   00000094   0xEAFFFFEB         B        ??IsDisplayAddressOk_4
   \                     ??IsDisplayAddressOk_9:
   \   00000098   0x........         BL       ADD_CHECK
   \   0000009C   0xE200000F         AND      R0,R0,#0xF
   \   000000A0   0xE3500005         CMP      R0,#+5
   \   000000A4   0xBAFFFFE6         BLT      ??IsDisplayAddressOk_1
   \   000000A8   0x........         BL       ADD_CHECK
   \   000000AC   0xE200000F         AND      R0,R0,#0xF
   \   000000B0   0xE3500009         CMP      R0,#+9
   \   000000B4   0xAAFFFFE2         BGE      ??IsDisplayAddressOk_1
   \   000000B8   0xE3A00001         MOV      R0,#+1
   \   000000BC   0xEAFFFFE1         B        ??IsDisplayAddressOk_4
   \                     ??IsDisplayAddressOk_10:
   \   000000C0   0x........         BL       ADD_CHECK
   \   000000C4   0xE200000F         AND      R0,R0,#0xF
   \   000000C8   0xE3500009         CMP      R0,#+9
   \   000000CC   0x0A000003         BEQ      ??IsDisplayAddressOk_3
   \   000000D0   0x........         BL       ADD_CHECK
   \   000000D4   0xE200000F         AND      R0,R0,#0xF
   \   000000D8   0xE350000E         CMP      R0,#+14
   \   000000DC   0x1AFFFFD8         BNE      ??IsDisplayAddressOk_1
   \                     ??IsDisplayAddressOk_3:
   \   000000E0   0xE3A00001         MOV      R0,#+1
   \   000000E4   0xEAFFFFD7         B        ??IsDisplayAddressOk_4
    379          }
    380          
    381          /***********************************************************************
    382          	화면에 출력할 수 있는 표시기인지 리턴한다.
    383          ************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    384          int IsPrintOfVersion()
    385          {
   \                     IsPrintOfVersion:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    386          	if(LO_NIBBLE((UCHAR)ADD_CHECK()) < 5 || LO_NIBBLE((UCHAR)ADD_CHECK()) > 8) return TRUE; else return FALSE;
   \   00000004   0x........         BL       ADD_CHECK
   \   00000008   0xE200000F         AND      R0,R0,#0xF
   \   0000000C   0xE3500005         CMP      R0,#+5
   \   00000010   0x3A000003         BCC      ??IsPrintOfVersion_0
   \   00000014   0x........         BL       ADD_CHECK
   \   00000018   0xE200000F         AND      R0,R0,#0xF
   \   0000001C   0xE3500009         CMP      R0,#+9
   \   00000020   0x3A000001         BCC      ??IsPrintOfVersion_1
   \                     ??IsPrintOfVersion_0:
   \   00000024   0xE3A00001         MOV      R0,#+1
   \   00000028   0xEA000000         B        ??IsPrintOfVersion_2
   \                     ??IsPrintOfVersion_1:
   \   0000002C   0xE3A00000         MOV      R0,#+0
   \                     ??IsPrintOfVersion_2:
   \   00000030   0xE8BD4002         POP      {R1,LR}
   \   00000034   0xE12FFF1E         BX       LR               ;; return
    387          }
    388          
    389          /***********************************************************************
    390          	상태를 리턴한다.
    391          ************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    392          void SendStatusReq(UCHAR *pRevPtcTextBuff)
    393          {
   \                     SendStatusReq:
   \   00000000   0xE92D4000         PUSH     {LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
    394          	int i,blockSize;
    395          	int nTemp;
    396          	UCHAR nPtcBuff[20];
    397          	UINT nLen;
    398          	UINT nCrc;
    399          	UCHAR *pNorFlshAddr = (UCHAR *)(BOARD_NORFLASH_ADDR);
    400          	UCHAR *pVideoMem = (UCHAR *)DOT_VIDEO_DATA;
    401          	UCHAR sMeroTestBuf[1024];
    402          	
    403          	nLen = 10;
    404          	
    405          	nPtcBuff[0] = 0xAA;
   \   00000008   0xE3A020AA         MOV      R2,#+170
   \   0000000C   0xE5CD2000         STRB     R2,[SP, #+0]
    406          	nPtcBuff[1] = 0xBB;
   \   00000010   0xE3A020BB         MOV      R2,#+187
   \   00000014   0xE5CD2001         STRB     R2,[SP, #+1]
    407          	nPtcBuff[2] = 0xCC;
   \   00000018   0xE3A020CC         MOV      R2,#+204
   \   0000001C   0xE5CD2002         STRB     R2,[SP, #+2]
    408          	
    409          	nPtcBuff[3] = WORD_H(nLen);
   \   00000020   0xE3A02000         MOV      R2,#+0
   \   00000024   0xE5CD2003         STRB     R2,[SP, #+3]
    410          	nPtcBuff[4] = WORD_L(nLen);
   \   00000028   0xE3A0200A         MOV      R2,#+10
   \   0000002C   0xE5CD2004         STRB     R2,[SP, #+4]
    411          	
    412          	nPtcBuff[5] = ~WORD_H(nLen);
   \   00000030   0xE3A020FF         MOV      R2,#+255
   \   00000034   0xE5CD2005         STRB     R2,[SP, #+5]
    413          	nPtcBuff[6] = ~WORD_L(nLen);
   \   00000038   0xE3A020F5         MOV      R2,#+245
   \   0000003C   0xE5CD2006         STRB     R2,[SP, #+6]
    414          	
    415          	nPtcBuff[7] = pRevPtcTextBuff[1];	
   \   00000040   0xE5D02001         LDRB     R2,[R0, #+1]
   \   00000044   0xE5CD2007         STRB     R2,[SP, #+7]
    416          	nPtcBuff[8] = pRevPtcTextBuff[0];
   \   00000048   0xE5D02000         LDRB     R2,[R0, #+0]
   \   0000004C   0xE5CD2008         STRB     R2,[SP, #+8]
    417          	
    418          	nPtcBuff[9] = SCC_STATUS_RLY; // Code
   \   00000050   0xE3A02008         MOV      R2,#+8
   \   00000054   0xE5CD2009         STRB     R2,[SP, #+9]
    419          	
    420          	nPtcBuff[10] = 0x01; // Downloader Reply Code
   \   00000058   0xE3A02001         MOV      R2,#+1
   \   0000005C   0xE5CD200A         STRB     R2,[SP, #+10]
    421          	
    422          	nPtcBuff[12] = 0x00;
   \   00000060   0xE3A02000         MOV      R2,#+0
   \   00000064   0xE1CD20BC         STRH     R2,[SP, #+12]
    423          	nPtcBuff[13] = 0x00;
    424          
    425          	switch(pRevPtcTextBuff[4]&0xff)
   \   00000068   0xE5D01004         LDRB     R1,[R0, #+4]
   \   0000006C   0xE3510000         CMP      R1,#+0
   \   00000070   0x0A000023         BEQ      ??SendStatusReq_0
   \   00000074   0xE3510010         CMP      R1,#+16
   \   00000078   0x0A000002         BEQ      ??SendStatusReq_1
   \   0000007C   0xE3510020         CMP      R1,#+32
   \   00000080   0x0A00000F         BEQ      ??SendStatusReq_2
   \   00000084   0xEA00003B         B        ??SendStatusReq_3
    426          	{
    427          	default:	
    428          		return;
    429          	
    430          	// 통신 상태 OK,NG
    431          	case 0x00:
    432          		nPtcBuff[11] = 0x00;
    433          		break;
    434          				
    435          	// 메모리 Erase OK,NG
    436          	case 0x10:		
    437          		nTemp = pRevPtcTextBuff[5]*0x10000;
    438          		// 블럭이 지워졌는지 검사
    439          
    440          
    441          		for(i=0;i<0x10000;i++)
   \                     ??SendStatusReq_1:
   \   00000088   0xE3A01000         MOV      R1,#+0
   \   0000008C   0xE5D00005         LDRB     R0,[R0, #+5]
   \   00000090   0xE1A00800         LSL      R0,R0,#+16
   \   00000094   0xE2800540         ADD      R0,R0,#+268435456
    442                          {
    443          		  if(WORD_L(pNorFlshAddr[nTemp + i]) != 0xFF) break;	
   \                     ??SendStatusReq_4:
   \   00000098   0xE4D02001         LDRB     R2,[R0], #+1
   \   0000009C   0xE35200FF         CMP      R2,#+255
   \   000000A0   0x1A000002         BNE      ??SendStatusReq_5
    444                          }
   \   000000A4   0xE2811001         ADD      R1,R1,#+1
   \   000000A8   0xE3510B40         CMP      R1,#+65536
   \   000000AC   0xBAFFFFF9         BLT      ??SendStatusReq_4
    445          		
    446          		nPtcBuff[11] = (i == 0x10000 ? MEMORY_ERASE_OK : MEMORY_ERASE_NG);
   \                     ??SendStatusReq_5:
   \   000000B0   0xE3510B40         CMP      R1,#+65536
   \   000000B4   0x03A00010         MOVEQ    R0,#+16
   \   000000B8   0x13A00011         MOVNE    R0,#+17
   \   000000BC   0xE5CD000B         STRB     R0,[SP, #+11]
    447                          
    448                          
    449          		break;
   \   000000C0   0xEA000016         B        ??SendStatusReq_6
    450          
    451          	// Data Download OK,NG
    452          	case 0x20:
    453          		for(i=MAKE_WORD(pRevPtcTextBuff[6],pRevPtcTextBuff[7]);i<=MAKE_WORD(pRevPtcTextBuff[8],pRevPtcTextBuff[9]);i++)
   \                     ??SendStatusReq_2:
   \   000000C4   0xE5D01006         LDRB     R1,[R0, #+6]
   \   000000C8   0xE5D02007         LDRB     R2,[R0, #+7]
   \   000000CC   0xE1821401         ORR      R1,R2,R1, LSL #+8
   \   000000D0   0xE5D03009         LDRB     R3,[R0, #+9]
   \   000000D4   0xEA000005         B        ??SendStatusReq_7
    454          		{
    455          			// 쓰여지지 않은 메모리라면 현 루프를 중지한다.
    456          			if(WORD_L(pVideoMem[i]) == NG) break;
   \                     ??SendStatusReq_8:
   \   000000D8   0xE3E024DF         MVN      R2,#-553648128
   \   000000DC   0xE3C228FE         BIC      R2,R2,#0xFE0000
   \   000000E0   0xE7D12002         LDRB     R2,[R1, +R2]
   \   000000E4   0xE3520001         CMP      R2,#+1
   \   000000E8   0x0A000007         BEQ      ??SendStatusReq_9
    457          		}
   \   000000EC   0xE2811001         ADD      R1,R1,#+1
   \                     ??SendStatusReq_7:
   \   000000F0   0xE5D02008         LDRB     R2,[R0, #+8]
   \   000000F4   0xE1832402         ORR      R2,R3,R2, LSL #+8
   \   000000F8   0xE1520001         CMP      R2,R1
   \   000000FC   0xAAFFFFF5         BGE      ??SendStatusReq_8
    458          
    459          		if(i > MAKE_WORD(pRevPtcTextBuff[8],pRevPtcTextBuff[9]))
    460          		{
    461          			nPtcBuff[11] = 0x20; // OK
   \   00000100   0xE3A01020         MOV      R1,#+32
   \                     ??SendStatusReq_0:
   \   00000104   0xE5CD100B         STRB     R1,[SP, #+11]
    462          
    463          			nPtcBuff[12] = 0x00;
    464          			nPtcBuff[13] = 0x00;
   \   00000108   0xEA000004         B        ??SendStatusReq_6
    465          		}
    466          		else
    467          		{		
    468          			nPtcBuff[11] = 0x21; // NG
   \                     ??SendStatusReq_9:
   \   0000010C   0xE3A02021         MOV      R2,#+33
   \   00000110   0xE5CD200B         STRB     R2,[SP, #+11]
    469          
    470          			nPtcBuff[12] = WORD_H(i);
   \   00000114   0xE1A00441         ASR      R0,R1,#+8
   \   00000118   0xE5CD000C         STRB     R0,[SP, #+12]
    471          			nPtcBuff[13] = WORD_L(i);
   \   0000011C   0xE5CD100D         STRB     R1,[SP, #+13]
    472          		}
    473          		
    474          		break;
    475          	}	
    476          	
    477          	nPtcBuff[14] = 0x00; // TEXT(7)
   \                     ??SendStatusReq_6:
   \   00000120   0xE3A01000         MOV      R1,#+0
   \   00000124   0xE5CD100E         STRB     R1,[SP, #+14]
    478          	nPtcBuff[15] = VERSION; // TEXT(8) - 다운로더 번호
   \   00000128   0xE3A01010         MOV      R1,#+16
   \   0000012C   0xE5CD100F         STRB     R1,[SP, #+15]
    479          	nPtcBuff[16] = 11;//GetFirmWareVersion(); // TEXT(9) - 표시기 Firmware Version(0x10 ~ 0x90)
   \   00000130   0xE3A0100B         MOV      R1,#+11
   \   00000134   0xE5CD1010         STRB     R1,[SP, #+16]
    480          	
    481          	nPtcBuff[17] = 0x03; // ETX
   \   00000138   0xE3A01003         MOV      R1,#+3
   \   0000013C   0xE5CD1011         STRB     R1,[SP, #+17]
    482          	
    483          	
    484                  nCrc = cal_CRC16(nLen+5,(UCHAR *)&nPtcBuff[3]);
   \   00000140   0xE28D1003         ADD      R1,SP,#+3
   \   00000144   0xE3A0000F         MOV      R0,#+15
   \   00000148   0x........         BL       cal_CRC16
    485          
    486          	nPtcBuff[18] = WORD_H(nCrc); // CRC
   \   0000014C   0xE1A01420         LSR      R1,R0,#+8
   \   00000150   0xE5CD1012         STRB     R1,[SP, #+18]
    487          	nPtcBuff[19] = WORD_L(nCrc); // CRC
   \   00000154   0xE5CD0013         STRB     R0,[SP, #+19]
    488          
    489          
    490          	memcpy(SCC1_Init_AChl.pTxBuffer,nPtcBuff,20);
                 	^
Warning[Pe223]: function "memcpy" declared implicitly

  	int i,blockSize;
  	      ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",394  Warning[Pe177]: 
          variable "blockSize" was declared but never referenced

  	UCHAR sMeroTestBuf[1024];
  	      ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",401  Warning[Pe177]: 
          variable "sMeroTestBuf" was declared but never referenced
   \   00000158   0xE3A02014         MOV      R2,#+20
   \   0000015C   0xE1A0100D         MOV      R1,SP
   \   00000160   0x........         LDR      R0,??DataTable4
   \   00000164   0xE5900010         LDR      R0,[R0, #+16]
   \   00000168   0x........         BL       memcpy
    491          
    492          	SCC1_Init_AChl.TxDelTime = 10;
   \   0000016C   0x........         LDR      R0,??DataTable4
   \   00000170   0xE3A0100A         MOV      R1,#+10
   \   00000174   0xE580100C         STR      R1,[R0, #+12]
    493          
    494          }
   \                     ??SendStatusReq_3:
   \   00000178   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   0000017C   0xE8BD4000         POP      {LR}
   \   00000180   0xE12FFF1E         BX       LR               ;; return
    495          
    496          /************************************************************************
    497          	Firmware 버젼 얻기
    498          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    499          UCHAR GetFirmWareVersion()
    500          {
    501            /*
    502          	int i;
    503          	int nPos;	
    504          	DWORD nDat;
    505          	DWORD nReadBlkSize;
    506          	UCHAR *pAddr = (UCHAR *)(NORFLASH_ADDR + 0x3C0000);
    507          	UCHAR nBuff[2];
    508          
    509          	if(WORD_L(pAddr[0]) == 0xFF || WORD_L(pAddr[1]) == 0xFF || WORD_L(pAddr[2]) == 0xFF || WORD_L(pAddr[3]) == 0xFF)
    510          	 return 0xFF;
    511          	
    512          	nPos = 4;
    513          
    514          	for(;;)
    515          	{
    516          		WDI_CS;
    517          		
    518          		// Block Size
    519          		nDat = MAKE_DWORD(pAddr[nPos*4+3],pAddr[nPos*4+2],pAddr[nPos*4+1],pAddr[nPos*4+0]);
    520          		nReadBlkSize = nDat;
    521          		if(nReadBlkSize == 0x00000000)
    522          		{
    523          			nPos-=3;			
    524          			nBuff[0] = nDat = MAKE_DWORD(pAddr[nPos*4+3],pAddr[nPos*4+2],pAddr[nPos*4+1],pAddr[nPos*4+0]);
    525          			nPos++;			
    526          			nBuff[1] = nDat = MAKE_DWORD(pAddr[nPos*4+3],pAddr[nPos*4+2],pAddr[nPos*4+1],pAddr[nPos*4+0]);
    527          			
    528          			return TwoChar2HEX(WORD_L(nBuff[0]),WORD_L(nBuff[1])); // 블럭 크기가 0이면 종료한다.
    529          		}
    530          		else
    531          		if(nReadBlkSize >= 0x00040000 || nPos >= 0x00040000) // 256KB이상이면 프로그램이 잘못 다운로드 된것으로 보고 중지
    532          		{
    533          			return 0xFF;
    534          		}
    535          			
    536          		nPos++;
    537          		
    538          		// Destination Address
    539          		nPos++;
    540          
    541          		// Destination Strobe
    542          		nPos++;
    543          
    544          		// Data
    545          		nPos += nReadBlkSize;
    546          	}
    547            */
    548          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "GetFirmWareVersion"
   \                     GetFirmWareVersion:
   \   00000000   0xE12FFF1E         BX       LR               ;; return
    549          
    550          /************************************************************************
    551          	한개의 문자를 헥사 코드로 만든다.
    552          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    553          UCHAR OneChar2HEX(char Ch)
    554          {
    555          	if((UCHAR)Ch >= 'a' && (UCHAR)Ch <= 'f') return Ch - 'a' + 10;
   \                     OneChar2HEX:
   \   00000000   0xE2401061         SUB      R1,R0,#+97
   \   00000004   0xE3510006         CMP      R1,#+6
   \   00000008   0x32400057         SUBCC    R0,R0,#+87
   \   0000000C   0x3A000007         BCC      ??OneChar2HEX_0
    556          	else
    557          		if((UCHAR)Ch >= 'A' && (UCHAR)Ch <= 'F') return Ch - 'A' + 10;
   \   00000010   0xE2401041         SUB      R1,R0,#+65
   \   00000014   0xE3510006         CMP      R1,#+6
   \   00000018   0x32400037         SUBCC    R0,R0,#+55
   \   0000001C   0x3A000003         BCC      ??OneChar2HEX_0
    558          		else
    559          			if((UCHAR)Ch >= '0' && (UCHAR)Ch <= '9') return Ch - '0';
   \   00000020   0xE2401030         SUB      R1,R0,#+48
   \   00000024   0xE351000A         CMP      R1,#+10
   \   00000028   0x2A000002         BCS      ??OneChar2HEX_1
   \   0000002C   0xE2400030         SUB      R0,R0,#+48
   \                     ??OneChar2HEX_0:
   \   00000030   0xE20000FF         AND      R0,R0,#0xFF
   \   00000034   0xE12FFF1E         BX       LR
    560          			else return 0;
   \                     ??OneChar2HEX_1:
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE12FFF1E         BX       LR               ;; return
    561          }
    562          
    563          /************************************************************************
    564          	두개의 문자를 헥사 코드로 만든다.
    565          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    566          UCHAR TwoChar2HEX(char Ch1,char Ch2)
    567          {
   \                     TwoChar2HEX:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1A04001         MOV      R4,R1
    568          	return ((UCHAR)OneChar2HEX(Ch1)&0xf)<<4 | ((UCHAR)OneChar2HEX(Ch2)&0xf);
   \   00000008   0x........         BL       OneChar2HEX
   \   0000000C   0xE1A05000         MOV      R5,R0
   \   00000010   0xE1A00004         MOV      R0,R4
   \   00000014   0x........         BL       OneChar2HEX
   \   00000018   0xE200000F         AND      R0,R0,#0xF
   \   0000001C   0xE1800205         ORR      R0,R0,R5, LSL #+4
   \   00000020   0xE20000FF         AND      R0,R0,#0xFF
   \   00000024   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   00000028   0xE12FFF1E         BX       LR               ;; return
    569          }
    570          
    571          /************************************************************************
    572          	LENGTH~ETX CRC16
    573          *************************************************************************
    574          WORD CalCrc16(UCHAR *pDat,int nNo)
    575          {
    576          	WORD CRC = 0;
    577          	int i;
    578          
    579          	for(i=0; i<nNo; i++)
    580          		CRC = (CRC >> 8) ^ gCRC_Table[(CRC^pDat[i])&0x00ff];
    581          
    582          	return ((~CRC) & 0x0000ffff);
    583          }
    584          
    585          
    586          /************************************************************************
                 ^
Warning[Pe009]: nested comment is not allowed
    587          	LDM Address Setting
    588          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    589          void LdmLatchClk(int Line)
    590          {	
   \                     LdmLatchClk:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    591          	switch(Line)
   \   00000004   0xE3500000         CMP      R0,#+0
   \   00000008   0x0A000003         BEQ      ??LdmLatchClk_0
   \   0000000C   0xE3500001         CMP      R0,#+1
   \   00000010   0x0A000009         BEQ      ??LdmLatchClk_1
   \   00000014   0xE8BD4001         POP      {R0,LR}
   \   00000018   0xE12FFF1E         BX       LR
    592          	{	
    593          	case 0:
    594          		LDM_CTRL(0x0a);
                 		^
Warning[Pe223]: function "LDM_CTRL" declared implicitly
   \                     ??LdmLatchClk_0:
   \   0000001C   0xE3A0000A         MOV      R0,#+10
   \   00000020   0x........         BL       LDM_CTRL
    595          		LDM_CTRL(0x0b);
   \   00000024   0xE3A0000B         MOV      R0,#+11
   \   00000028   0x........         BL       LDM_CTRL
    596          		LDM_CTRL(0x09);
   \   0000002C   0xE3A00009         MOV      R0,#+9
   \   00000030   0x........         BL       LDM_CTRL
    597          		LDM_CTRL(0x0b);
   \   00000034   0xE3A0000B         MOV      R0,#+11
   \   00000038   0xEA000006         B        ??LdmLatchClk_2
    598          		LDM_CTRL(0x0a);
    599          		break;
    600          	case 1:
    601          		LDM_CTRL(0x0a);
   \                     ??LdmLatchClk_1:
   \   0000003C   0xE3A0000A         MOV      R0,#+10
   \   00000040   0x........         BL       LDM_CTRL
    602          		LDM_CTRL(0x0e);
   \   00000044   0xE3A0000E         MOV      R0,#+14
   \   00000048   0x........         BL       LDM_CTRL
    603          		LDM_CTRL(0x06);
   \   0000004C   0xE3A00006         MOV      R0,#+6
   \   00000050   0x........         BL       LDM_CTRL
    604          		LDM_CTRL(0x0e);
   \   00000054   0xE3A0000E         MOV      R0,#+14
   \                     ??LdmLatchClk_2:
   \   00000058   0x........         BL       LDM_CTRL
    605          		LDM_CTRL(0x0a);
   \   0000005C   0xE3A0000A         MOV      R0,#+10
   \   00000060   0xE8BD4002         POP      {R1,LR}
   \   00000064   0x........         B        LDM_CTRL         ;; tailcall
    606          		break;
    607          	}
    608          }
    609          
    610          /************************************************************************
    611          	한개의 쩜을 찍는다.
    612          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    613          void PixelPut(int x,int y,UCHAR nClr)
    614          {
   \                     PixelPut:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1A04002         MOV      R4,R2
    615          	int i;
    616          	UCHAR *pAddr = (UCHAR *)AT91C_EBI_SDRAM;	
    617          
    618          	i = x+(y*SCREEN_WIDTH_MAX);
   \   00000008   0x........         LDR      R2,??DataTable4_3
   \   0000000C   0xE5922000         LDR      R2,[R2, #+0]
   \   00000010   0xE0200192         MLA      R0,R2,R1,R0
    619          	
    620          	if(i < (SCREEN_WIDTH_MAX*16))
   \   00000014   0xE1500202         CMP      R0,R2, LSL #+4
    621          	{
    622          		pAddr[i] = nClr;
   \   00000018   0xB2800580         ADDLT    R0,R0,#+536870912
   \   0000001C   0xB5C04000         STRBLT   R4,[R0, #+0]
   \   00000020   0xBA00000E         BLT      ??PixelPut_0
    623          	}
    624          	else
    625          	{
    626          		i %= (SCREEN_WIDTH_MAX*16);
   \   00000024   0xE1A01202         LSL      R1,R2,#+4
   \   00000028   0x........         BL       __aeabi_idivmod
   \   0000002C   0xE1A00001         MOV      R0,R1
    627          		
    628          		pAddr[i] &= 0xF3;
   \   00000030   0xE2801580         ADD      R1,R0,#+536870912
   \   00000034   0xE5D11000         LDRB     R1,[R1, #+0]
   \   00000038   0xE3C1100C         BIC      R1,R1,#0xC
   \   0000003C   0xE2802580         ADD      R2,R0,#+536870912
   \   00000040   0xE5C21000         STRB     R1,[R2, #+0]
    629          		pAddr[i] |= (nClr<<2)&0x0C;
   \   00000044   0xE2801580         ADD      R1,R0,#+536870912
   \   00000048   0xE5D11000         LDRB     R1,[R1, #+0]
   \   0000004C   0xE3A0200C         MOV      R2,#+12
   \   00000050   0xE0022104         AND      R2,R2,R4, LSL #+2
   \   00000054   0xE1821001         ORR      R1,R2,R1
   \   00000058   0xE2800580         ADD      R0,R0,#+536870912
   \   0000005C   0xE5C01000         STRB     R1,[R0, #+0]
    630          	}
    631          	
    632          }
   \                     ??PixelPut_0:
   \   00000060   0xE8BD4010         POP      {R4,LR}
   \   00000064   0xE12FFF1E         BX       LR               ;; return
    633          
    634          /************************************************************************
    635          	한개의 숫자를 출력한다.
    636          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    637          void TextOut(int x,int y,UCHAR nChar,UCHAR nfClr,UCHAR nbClr)
    638          {
   \                     TextOut:
   \   00000000   0xE92D4FF8         PUSH     {R3-R11,LR}
   \   00000004   0xE1A07000         MOV      R7,R0
   \   00000008   0xE1A05003         MOV      R5,R3
   \   0000000C   0xE5DD6028         LDRB     R6,[SP, #+40]
    639          	int i,j;
    640          	UCHAR *pAddr = (UCHAR *)AT91C_EBI_SDRAM;	
                 	       ^
Warning[Pe177]: variable "pAddr" was declared but never referenced
    641          	UCHAR *pNorFlshAddr = (UCHAR *)(BOARD_NORFLASH_ADDR);
    642          	
    643          	
    644          	nChar = nChar >= 10 ? (nChar-10)+0x21 : nChar + 0x10;
   \   00000010   0xE352000A         CMP      R2,#+10
   \   00000014   0x22820017         ADDCS    R0,R2,#+23
   \   00000018   0x32820010         ADDCC    R0,R2,#+16
    645          	
    646          	for(j=0;j<16;j++)	
   \   0000001C   0xE1A00C00         LSL      R0,R0,#+24
   \   00000020   0xE1A00A20         LSR      R0,R0,#+20
   \   00000024   0xE2808540         ADD      R8,R0,#+268435456
   \   00000028   0xE1A04001         MOV      R4,R1
   \   0000002C   0xE3A09010         MOV      R9,#+16
    647          	{
    648          		for(i=0;i<8;i++)
   \                     ??TextOut_0:
   \   00000030   0xE3A0A000         MOV      R10,#+0
   \   00000034   0xE1A0B007         MOV      R11,R7
    649          		{			
    650          			PixelPut(x+i,y+j,BitTest(pNorFlshAddr[j+nChar*16],7-i) ? nfClr : nbClr);
   \                     ??TextOut_1:
   \   00000038   0xE5D80000         LDRB     R0,[R8, #+0]
   \   0000003C   0xE3A01001         MOV      R1,#+1
   \   00000040   0xE1A0200A         MOV      R2,R10
   \   00000044   0xE2622007         RSB      R2,R2,#+7
   \   00000048   0xE1100211         TST      R0,R1, LSL R2
   \   0000004C   0x11A02005         MOVNE    R2,R5
   \   00000050   0x01A02006         MOVEQ    R2,R6
   \   00000054   0xE1A01004         MOV      R1,R4
   \   00000058   0xE1A0000B         MOV      R0,R11
   \   0000005C   0x........         BL       PixelPut
    651          
    652          			//PixelPut(x+i,y+j,BitTest(gDigitName[j+LO_NIBBLE(nChar)*16],7-i) ? nfClr : nbClr);
    653          		}
   \   00000060   0xE28AA001         ADD      R10,R10,#+1
   \   00000064   0xE28BB001         ADD      R11,R11,#+1
   \   00000068   0xE35A0008         CMP      R10,#+8
   \   0000006C   0xBAFFFFF1         BLT      ??TextOut_1
    654          	}
   \   00000070   0xE2844001         ADD      R4,R4,#+1
   \   00000074   0xE2888001         ADD      R8,R8,#+1
   \   00000078   0xE2599001         SUBS     R9,R9,#+1
   \   0000007C   0x1AFFFFEB         BNE      ??TextOut_0
    655          }
   \   00000080   0xE8BD4FF1         POP      {R0,R4-R11,LR}
   \   00000084   0xE12FFF1E         BX       LR               ;; return
    656          
    657          /************************************************************************
    658          	이미지를 출력한다.
    659          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    660          void VersionImagePut()
    661          {
   \                     VersionImagePut:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    662          	UCHAR i;
    663          	UCHAR *pAddr = (UCHAR *)AT91C_EBI_SDRAM;	
    664          
    665          	memset(AT91C_EBI_SDRAM,0,(SCREEN_WIDTH_MAX * 32)); // 0으로 Clear
                 	^
Warning[Pe223]: function "memset" declared implicitly

  	UCHAR *pAddr = (UCHAR *)AT91C_EBI_SDRAM;	
  	       ^
"C:\Users\JDS_Retina\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",663  Warning[Pe177]: 
          variable "pAddr" was declared but never referenced
   \   00000004   0x........         LDR      R0,??DataTable4_3
   \   00000008   0xE5900000         LDR      R0,[R0, #+0]
   \   0000000C   0xE1A02280         LSL      R2,R0,#+5
   \   00000010   0xE3A01000         MOV      R1,#+0
   \   00000014   0xE3A00580         MOV      R0,#+536870912
   \   00000018   0x........         BL       memset
    666          
    667          	// 다운로더 버젼번호
    668          	TextOut(SCREEN_CENTER_POS + 0,0,HI_NIBBLE(VERSION),1,0);
   \   0000001C   0x........         LDR      R0,??DataTable4_3
   \   00000020   0xE5900000         LDR      R0,[R0, #+0]
   \   00000024   0xE3A01000         MOV      R1,#+0
   \   00000028   0xE58D1000         STR      R1,[SP, #+0]
   \   0000002C   0xE3A03001         MOV      R3,#+1
   \   00000030   0xE3A02001         MOV      R2,#+1
   \   00000034   0xE0800FA0         ADD      R0,R0,R0, LSR #+31
   \   00000038   0xE3E0C00F         MVN      R12,#+15
   \   0000003C   0xE08C00C0         ADD      R0,R12,R0, ASR #+1
   \   00000040   0x........         BL       TextOut
    669          	TextOut(SCREEN_CENTER_POS + 8,0,LO_NIBBLE(VERSION),1,0);
   \   00000044   0x........         LDR      R0,??DataTable4_3
   \   00000048   0xE5900000         LDR      R0,[R0, #+0]
   \   0000004C   0xE3A01000         MOV      R1,#+0
   \   00000050   0xE58D1000         STR      R1,[SP, #+0]
   \   00000054   0xE3A03001         MOV      R3,#+1
   \   00000058   0xE3A02000         MOV      R2,#+0
   \   0000005C   0xE0800FA0         ADD      R0,R0,R0, LSR #+31
   \   00000060   0xE3E0C007         MVN      R12,#+7
   \   00000064   0xE08C00C0         ADD      R0,R12,R0, ASR #+1
   \   00000068   0x........         BL       TextOut
    670          			
    671          	// 표시기 폼웨어 버젼번호
    672          	i = 11;//GetFirmWareVersion();
    673          	TextOut(SCREEN_CENTER_POS + 16,0,HI_NIBBLE(i),2,0);
   \   0000006C   0x........         LDR      R0,??DataTable4_3
   \   00000070   0xE5900000         LDR      R0,[R0, #+0]
   \   00000074   0xE3A01000         MOV      R1,#+0
   \   00000078   0xE58D1000         STR      R1,[SP, #+0]
   \   0000007C   0xE3A03002         MOV      R3,#+2
   \   00000080   0xE3A02000         MOV      R2,#+0
   \   00000084   0xE0800FA0         ADD      R0,R0,R0, LSR #+31
   \   00000088   0xE1A000C0         ASR      R0,R0,#+1
   \   0000008C   0x........         BL       TextOut
    674          	TextOut(SCREEN_CENTER_POS + 24,0,LO_NIBBLE(i),2,0);
   \   00000090   0x........         LDR      R0,??DataTable4_3
   \   00000094   0xE5900000         LDR      R0,[R0, #+0]
   \   00000098   0xE3A01000         MOV      R1,#+0
   \   0000009C   0xE58D1000         STR      R1,[SP, #+0]
   \   000000A0   0xE3A03002         MOV      R3,#+2
   \   000000A4   0xE3A0200B         MOV      R2,#+11
   \   000000A8   0xE0800FA0         ADD      R0,R0,R0, LSR #+31
   \   000000AC   0xE3A0C008         MOV      R12,#+8
   \   000000B0   0xE08C00C0         ADD      R0,R12,R0, ASR #+1
   \   000000B4   0x........         BL       TextOut
    675          }
   \   000000B8   0xE8BD4001         POP      {R0,LR}
   \   000000BC   0xE12FFF1E         BX       LR               ;; return
    676          
    677          /************************************************************************
    678          	Timer0 - Interrupt Routine [1ms]
    679          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    680          void Down_int09(void) // Timer 0
    681          {
    682          	static DWORD nBlk = 0;
                 	             ^
Warning[Pe177]: variable "nBlk" was declared but never referenced
    683          	
    684          	if(gTxEnableTimerCnt) gTxEnableTimerCnt--;
   \                     Down_int09:
   \   00000000   0x........         LDR      R0,??DataTable4_9
   \   00000004   0xE5900000         LDR      R0,[R0, #+0]
   \   00000008   0xE3500000         CMP      R0,#+0
   \   0000000C   0x0A000004         BEQ      ??Down_int09_0
   \   00000010   0x........         LDR      R0,??DataTable4_9
   \   00000014   0xE5900000         LDR      R0,[R0, #+0]
   \   00000018   0xE2400001         SUB      R0,R0,#+1
   \   0000001C   0x........         LDR      R1,??DataTable4_9
   \   00000020   0xE5810000         STR      R0,[R1, #+0]
    685               
    686          	//if(gTxDisableTimerCnt == 1) RS485_TX_DISABLE;
    687          	if(gTxDisableTimerCnt) gTxDisableTimerCnt--;
   \                     ??Down_int09_0:
   \   00000024   0x........         LDR      R0,??DataTable4_10
   \   00000028   0xE5900000         LDR      R0,[R0, #+0]
   \   0000002C   0xE3500000         CMP      R0,#+0
   \   00000030   0x0A000004         BEQ      ??Down_int09_1
   \   00000034   0x........         LDR      R0,??DataTable4_10
   \   00000038   0xE5900000         LDR      R0,[R0, #+0]
   \   0000003C   0xE2400001         SUB      R0,R0,#+1
   \   00000040   0x........         LDR      R1,??DataTable4_10
   \   00000044   0xE5810000         STR      R0,[R1, #+0]
    688                  
    689          
    690          	gFirmWareExeTime++;
   \                     ??Down_int09_1:
   \   00000048   0x........         LDR      R0,??DataTable4_11
   \   0000004C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000050   0xE2800001         ADD      R0,R0,#+1
   \   00000054   0x........         LDR      R1,??DataTable4_11
   \   00000058   0xE5810000         STR      R0,[R1, #+0]
    691          
    692          }
   \   0000005C   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4:
   \   00000000   0x........         DC32     SCC1_Init_AChl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_1:
   \   00000000   0xFFFA0040         DC32     0xfffa0040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_2:
   \   00000000   0x........         DC32     mBlockSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_3:
   \   00000000   0x........         DC32     SCREEN_WIDTH_MAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_4:
   \   00000000   0x........         DC32     gFirmWareExeFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_5:
   \   00000000   0x........         DC32     norFlash+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_6:
   \   00000000   0x........         DC32     norFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_7:
   \   00000000   0x........         DC32     mBlackChick

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_8:
   \   00000000   0x........         DC32     gVersionPrintFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_9:
   \   00000000   0x........         DC32     gTxEnableTimerCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_10:
   \   00000000   0x........         DC32     gTxDisableTimerCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable4_11:
   \   00000000   0x........         DC32     gFirmWareExeTime
    693          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  Down_int09
        0  Download_Init
      216  Download_main
             216 -> ADD_CHECK
             216 -> IsDisplayAddressOk
             216 -> IsPrintOfVersion
             216 -> NORFLASH_EraseSector
             216 -> NORFLASH_WriteData
             216 -> NorFlash_GetDeviceBlockSize
             216 -> NorFlash_GetDeviceNumOfBlocks
             216 -> NorFlash_GetDeviceSectorAddress
             216 -> PixelPut
             216 -> SendStatusReq
             216 -> TC_Stop
             216 -> VersionImagePut
             216 -> __aeabi_idiv
             216 -> memcpy
        0  GetFirmWareVersion
        8  IsDisplayAddressOk
               8 -> ADD_CHECK
        8  IsPrintOfVersion
               8 -> ADD_CHECK
        8  LdmLatchClk
               0 -> LDM_CTRL
               8 -> LDM_CTRL
        0  OneChar2HEX
        8  PixelPut
               8 -> __aeabi_idivmod
        8  ScreenWidth
               8 -> ADD_CHECK
       24  SendStatusReq
              24 -> cal_CRC16
              24 -> memcpy
       40  TextOut
              40 -> PixelPut
       16  TwoChar2HEX
              16 -> OneChar2HEX
        8  VersionImagePut
               8 -> TextOut
               8 -> memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_2
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
      12  ?Subroutine0
      96  Down_int09
       4  Download_Init
     704  Download_main
       4  GetFirmWareVersion
     232  IsDisplayAddressOk
      56  IsPrintOfVersion
     104  LdmLatchClk
      64  OneChar2HEX
     104  PixelPut
       4  SCREEN_WIDTH_MAX
     208  ScreenWidth
     388  SendStatusReq
     136  TextOut
      44  TwoChar2HEX
     192  VersionImagePut
     256  gDigitName
       4  gERASE_OkFlag
       4  gFirmWareExeFlag
       4  gFirmWareExeTime
       4  gTxDisableTimerCnt
       4  gTxEnableTimerCnt
      64  gVerName
       4  gVersionPrintFlag
     400  mBlackChick
       4  mBlockSize

 
   424 bytes in section .bss
   328 bytes in section .data
 2 396 bytes in section .text
 
 2 396 bytes of CODE memory
   752 bytes of DATA memory

Errors: none
Warnings: 19
