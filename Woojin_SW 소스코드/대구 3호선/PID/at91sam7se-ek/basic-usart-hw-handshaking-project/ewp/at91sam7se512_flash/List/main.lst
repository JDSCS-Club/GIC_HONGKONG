###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        03/Jul/2015  11:57:05
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c
#    Command line =  
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c"
#        -D at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\"
#        --remarks --diag_suppress Pe826,Pe1375 -o
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/peripherals\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/memories\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/components\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\main.lst
#    Object file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\main.o
#
###############################################################################

F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          /// \dir "Basic USART Hardware Handshaking Project"
     32          ///
     33          /// !!!Purpose
     34          ///
     35          /// This example demonstrates the hardware handshaking mode (i.e. RTS/CTS)
     36          /// provided by the USART peripherals on AT91 microcontrollers. The practical
     37          /// use of hardware handshaking is that it allows to stop transfer on the USART
     38          /// without losing any data in the process. This is very useful for applications
     39          /// that need to program slow memories for example.
     40          ///
     41          /// !!!Requirements
     42          ///
     43          /// This example can be used on any AT91 evaluation kit, except when they do
     44          /// not provide an USART serial port (i.e. on AT91SAM9261-EK, AT91SAM7L-EK and
     45          /// AT91SAM7L-STK).
     46          ///
     47          /// !!!Description
     48          ///
     49          /// The provided program uses hardware handshaking mode to regulate the data
     50          /// rate of an incoming file transfer. A terminal application, such as
     51          /// hyperterminal, is used to send a text file to the device (without any
     52          /// protocol such as X-modem). The device will enforce the configured
     53          /// bytes per second (bps) rate with its Request To Send (RTS) line.
     54          ///
     55          /// Whenever the data rate meet or exceed the configurable threshold, the device
     56          /// stops receiving data on the USART. Since no buffer is provided to the PDC,
     57          /// this will set the RTS line, telling the computer to stop sending data. Each
     58          /// second, the current data rate and total number of bytes received are
     59          /// displayed; the transfer is also restarted.
     60          ///
     61          /// Note that the device may receive slightly less bytes than the actual file
     62          /// size, depending on the nature of the file. This does NOT mean that bytes
     63          /// have been lost: this is simply an issue with how line breaks are transmitted
     64          /// by the terminal. It is therefore better to use binary files, as they most
     65          /// often do not contain line breaks. For example, send one of the object files
     66          /// generated by the compiler.
     67          ///
     68          /// !!!Usage
     69          ///
     70          /// -# Build the program and download it inside the evaluation board. Please
     71          ///    refer to the <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6224.pdf">SAM-BA User Guide</a>,
     72          ///    the <a href="http://www.atmel.com/dyn/resources/prod_documents/doc6310.pdf">GNU-Based Software Development</a>
     73          ///    application note or to the <a href="ftp://ftp.iar.se/WWWfiles/arm/Guides/EWARM_UserGuide.ENU.pdf">IAR EWARM User Guide</a>,
     74          ///    depending on your chosen solution.
     75          /// -# Connect a serial cable to the USART0 port on the evaluation kit. It will
     76          ///    most often be labeled "RS232 COM port".
     77          /// -# On the computer, open and configure a terminal application (e.g.
     78          ///    HyperTerminal on Microsoft Windows) with these settings:
     79          ///       - 115200 bauds
     80          ///       - 8 data bits
     81          ///       - No parity
     82          ///       - 1 stop bit
     83          ///       - Hardware flow control (RTS/CTS)
     84          /// -# Start the application. The following traces shall appear on the terminal:
     85          ///    \code
     86          ///    -- Basic USART Hardware Handshaking Project xxx --
     87          ///    -- AT91xxxxxx-xx
     88          ///    -- Compiled: xxx xx xxxx xx:xx:xx --
     89          ///    Bps:    0; Tot:      0
     90          ///    \endcode
     91          /// -# Send a file in text format to the device. On HyperTerminal, this is done
     92          ///    by selecting "Transfer -> Send Text File" (this does not prevent you from
     93          ///    sending binary files). The transfer will start and the device will update
     94          ///    the bps and total counts on the terminal.
     95          /// -# Whenever the transfer is complete, the total number of bytes received
     96          ///    should match the size of the sent file (unless it is a text file, see
     97          ///    explanation in description section).
     98          //------------------------------------------------------------------------------
     99          
    100          //------------------------------------------------------------------------------
    101          //         Headers
    102          //------------------------------------------------------------------------------
    103          
    104          #include <board.h>
    105          #include <pio/pio.h>
    106          #include <usart/usart.h>
    107          #include <tc/tc.h>
    108          #include <aic/aic.h>
    109          #include <pmc/pmc.h>
    110          #include <utility/trace.h>
    111          #include <pit/pit.h>
    112          #include <utility/math.h>
    113          #include <board_memories.h>
    114          #include <utility/assert.h>
    115          #include <memories/norflash/NorFlashCFI.h>
    116          #include <memories/norflash/NorFlashApi.h>
    117          #include <memories/spi-flash/at26.h>
    118          
    119          #include <spi/spi.h>
    120          
    121          
    122          #include <stdio.h>
    123          
    124          #include "UART.h"

  #endif
        ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.h",44  Remark[Pe001]: 
          last line of file ends without a newline

  #endif
        ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\UART.h",43  Remark[Pe001]: 
          last line of file ends without a newline
    125          #include "main.h"
    126          #include "NorFlash.h"

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void NorFlashAllErase()
   \                     NorFlashAllErase:
   \   00000000   0xE3A000AA         MOV      R0,#+170
   \   00000004   0xE3A01251         MOV      R1,#+268435461
   \   00000008   0xE3811E55         ORR      R1,R1,#0x550
   \   0000000C   0xE5C10000         STRB     R0,[R1, #+0]
   \   00000010   0xE3A00055         MOV      R0,#+85
   \   00000014   0xE3A012A1         MOV      R1,#+268435466
   \   00000018   0xE3811FA8         ORR      R1,R1,#0x2A0
   \   0000001C   0xE5C10000         STRB     R0,[R1, #+0]
   \   00000020   0xE3A00080         MOV      R0,#+128
   \   00000024   0xE3A01251         MOV      R1,#+268435461
   \   00000028   0xE3811E55         ORR      R1,R1,#0x550
   \   0000002C   0xE5C10000         STRB     R0,[R1, #+0]
   \   00000030   0xE3A000AA         MOV      R0,#+170
   \   00000034   0xE3A01251         MOV      R1,#+268435461
   \   00000038   0xE3811E55         ORR      R1,R1,#0x550
   \   0000003C   0xE5C10000         STRB     R0,[R1, #+0]
   \   00000040   0xE3A00055         MOV      R0,#+85
   \   00000044   0xE3A012A1         MOV      R1,#+268435466
   \   00000048   0xE3811FA8         ORR      R1,R1,#0x2A0
   \   0000004C   0xE5C10000         STRB     R0,[R1, #+0]
   \   00000050   0xE3A00010         MOV      R0,#+16
   \   00000054   0xE3A01251         MOV      R1,#+268435461
   \   00000058   0xE3811E55         ORR      R1,R1,#0x550
   \   0000005C   0xE5C10000         STRB     R0,[R1, #+0]
   \   00000060   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp int NorFlashBlockErase(DWORD)
   \                     NorFlashBlockErase:
   \   00000000   0xE1B01000         MOVS     R1,R0
   \   00000004   0xE3A000AA         MOV      R0,#+170
   \   00000008   0xE3A02251         MOV      R2,#+268435461
   \   0000000C   0xE3822E55         ORR      R2,R2,#0x550
   \   00000010   0xE5C20000         STRB     R0,[R2, #+0]
   \   00000014   0xE3A00055         MOV      R0,#+85
   \   00000018   0xE3A022A1         MOV      R2,#+268435466
   \   0000001C   0xE3822FA8         ORR      R2,R2,#0x2A0
   \   00000020   0xE5C20000         STRB     R0,[R2, #+0]
   \   00000024   0xE3A00080         MOV      R0,#+128
   \   00000028   0xE3A02251         MOV      R2,#+268435461
   \   0000002C   0xE3822E55         ORR      R2,R2,#0x550
   \   00000030   0xE5C20000         STRB     R0,[R2, #+0]
   \   00000034   0xE3A000AA         MOV      R0,#+170
   \   00000038   0xE3A02251         MOV      R2,#+268435461
   \   0000003C   0xE3822E55         ORR      R2,R2,#0x550
   \   00000040   0xE5C20000         STRB     R0,[R2, #+0]
   \   00000044   0xE3A00055         MOV      R0,#+85
   \   00000048   0xE3A022A1         MOV      R2,#+268435466
   \   0000004C   0xE3822FA8         ORR      R2,R2,#0x2A0
   \   00000050   0xE5C20000         STRB     R0,[R2, #+0]
   \   00000054   0xE3A00030         MOV      R0,#+48
   \   00000058   0xE3A02B40         MOV      R2,#+65536
   \   0000005C   0xE0130192         MULS     R3,R2,R1
   \   00000060   0xE2932540         ADDS     R2,R3,#+268435456
   \   00000064   0xE5C20000         STRB     R0,[R2, #+0]
   \   00000068   0xE3A00001         MOV      R0,#+1
   \   0000006C   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \   __interwork __softfp void NorFlashWrite(DWORD, UCHAR)
   \                     NorFlashWrite:
   \   00000000   0xE3A020AA         MOV      R2,#+170
   \   00000004   0xE3A03251         MOV      R3,#+268435461
   \   00000008   0xE3833E55         ORR      R3,R3,#0x550
   \   0000000C   0xE5C32000         STRB     R2,[R3, #+0]
   \   00000010   0xE3A02055         MOV      R2,#+85
   \   00000014   0xE3A032A1         MOV      R3,#+268435466
   \   00000018   0xE3833FA8         ORR      R3,R3,#0x2A0
   \   0000001C   0xE5C32000         STRB     R2,[R3, #+0]
   \   00000020   0xE3A020A0         MOV      R2,#+160
   \   00000024   0xE3A03251         MOV      R3,#+268435461
   \   00000028   0xE3833E55         ORR      R3,R3,#0x550
   \   0000002C   0xE5C32000         STRB     R2,[R3, #+0]
   \   00000030   0xE2902540         ADDS     R2,R0,#+268435456
   \   00000034   0xE5C21000         STRB     R1,[R2, #+0]
   \                     ??NorFlashWrite_0:
   \   00000038   0xE2902540         ADDS     R2,R0,#+268435456
   \   0000003C   0xE5D22000         LDRB     R2,[R2, #+0]
   \   00000040   0xE21220FF         ANDS     R2,R2,#0xFF      ;; Zero extend
   \   00000044   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000048   0xE1520001         CMP      R2,R1
   \   0000004C   0x1AFFFFF9         BNE      ??NorFlashWrite_0
   \   00000050   0xE12FFF1E         BX       LR               ;; return
    127          #include "Download.h"

  #endif
        ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.h",32  Remark[Pe001]: 
          last line of file ends without a newline
    128          #include "LED_Display.h"

  #endif
        ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\LED_Display.h",121  Remark[Pe001]: 
          last line of file ends without a newline
    129          
    130          #include "SPI_FUN.h"

  #endif
        ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\SPI_FUN.h",18  Remark[Pe001]: 
          last line of file ends without a newline
    131          
    132          
    133          extern SCC_INIT_SHAPE SCC1_Init_AChl; // 85C30의 송수신 버퍼 및 플래그
    134          
    135          //------------------------------------------------------------------------------
    136          //         Local variables - nandflash memory 변수 
    137          //------------------------------------------------------------------------------
    138          
    139          /// Norflash device structure.

   \                                 In section .bss, align 4
    140          struct NorFlash norFlash;
   \                     norFlash:
   \   00000000                      DS8 104
    141          
    142          //------------------------------------------------------------------------------
    143          //         Local definition
    144          //------------------------------------------------------------------------------
    145          
    146          #ifndef AT91C_ID_TC0
    147          #if defined(AT91C_ID_TC012)
    148              #define AT91C_ID_TC0 AT91C_ID_TC012
    149          #elif defined(AT91C_ID_TC)
    150              #define AT91C_ID_TC0 AT91C_ID_TC
    151          #else
    152              #error Pb define ID_TC
    153          #endif
    154          #endif
    155          
    156          /// Maximum Bytes Per Second (BPS) rate that will be forced using the CTS pin.
    157          #define MAX_BPS             550
    158          
    159          /// Size of the receive buffer used by the PDC, in bytes.
    160          #define BUFFER_SIZE         1
    161          
    162          /// PIT period value (useconds)
    163          #define PIT_PERIOD        1000
    164          /// Delay for pushbutton debouncing (ms)
    165          #define DEBOUNCE_TIME       10
    166          
    167          
    168          // Pio HexSwitch Read 
    169          #define HEX_SW_ADD1_1 {1 << 19, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
    170          #define HEX_SW_ADD1_2 {1 << 20, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
    171          #define HEX_SW_ADD1_3 {1 << 21, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
    172          #define HEX_SW_ADD1_4 {1 << 22, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
    173          
    174          #define HEX_SW_ADD2_1 {1 << 28, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
    175          #define HEX_SW_ADD2_2 {1 << 29, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
    176          #define HEX_SW_ADD2_3 {1 << 30, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
    177          #define HEX_SW_ADD2_4 {1 << 31, AT91C_BASE_PIOB, AT91C_ID_PIOB, PIO_INPUT, PIO_DEFAULT}
    178          
    179          #define ARM_RUN_LED_OUT {1 << 3, AT91C_BASE_PIOA, AT91C_ID_PIOA, PIO_OUTPUT_0,PIO_DEFAULT}
    180          
    181          
    182          #define BUFFER_ADDRESS (AT91C_EBI_SDRAM)
    183          
    184          
    185          unsigned int SPI_PDC_sandframe(char *pBUFFER, unsigned int szBUFFER, char *pNEXTBUFFER, unsigned int szNEXTBUFFER);
    186          
    187          extern  At26 at26;
    188          //------------------------------------------------------------------------------
    189          //         Local variables
    190          //------------------------------------------------------------------------------
    191          
    192          /// Pins to configure for the application.

   \                                 In section .rodata, align 4
    193          const Pin pins[] = {
   \                     pins:
   \   00000000   0x00000600         DC32 1536, 0FFFFF400H
   \              0xFFFFF400   
   \   00000008   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   0000000C   0x00000020         DC32 32, 0FFFFF400H
   \              0xFFFFF400   
   \   00000014   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   00000018   0x00000040         DC32 64, 0FFFFF400H
   \              0xFFFFF400   
   \   00000020   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   00000024   0x00000100         DC32 256, 0FFFFF400H
   \              0xFFFFF400   
   \   0000002C   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   00000030   0x00000080         DC32 128, 0FFFFF400H
   \              0xFFFFF400   
   \   00000038   0x02 0x00          DC8 2, 0, 0, 0
   \              0x00 0x00    
   \   0000003C   0x00080000         DC32 524288, 0FFFFF600H
   \              0xFFFFF600   
   \   00000044   0x03 0x02          DC8 3, 2, 0, 0
   \              0x00 0x00    
   \   00000048   0x00100000         DC32 1048576, 0FFFFF600H
   \              0xFFFFF600   
   \   00000050   0x03 0x02          DC8 3, 2, 0, 0
   \              0x00 0x00    
   \   00000054   0x00200000         DC32 2097152, 0FFFFF600H
   \              0xFFFFF600   
   \   0000005C   0x03 0x02          DC8 3, 2, 0, 0
   \              0x00 0x00    
   \   00000060   0x00400000         DC32 4194304, 0FFFFF600H
   \              0xFFFFF600   
   \   00000068   0x03 0x02          DC8 3, 2, 0, 0
   \              0x00 0x00    
   \   0000006C   0x10000000         DC32 268435456, 0FFFFF600H
   \              0xFFFFF600   
   \   00000074   0x03 0x02          DC8 3, 2, 0, 0
   \              0x00 0x00    
   \   00000078   0x20000000         DC32 536870912, 0FFFFF600H
   \              0xFFFFF600   
   \   00000080   0x03 0x02          DC8 3, 2, 0, 0
   \              0x00 0x00    
   \   00000084   0x40000000         DC32 1073741824, 0FFFFF600H
   \              0xFFFFF600   
   \   0000008C   0x03 0x02          DC8 3, 2, 0, 0
   \              0x00 0x00    
   \   00000090   0x80000000         DC32 2147483648, 0FFFFF600H
   \              0xFFFFF600   
   \   00000098   0x03 0x02          DC8 3, 2, 0, 0
   \              0x00 0x00    
   \   0000009C   0xC0000000         DC32 3221225472, 0FFFFF400H
   \              0xFFFFF400   
   \   000000A4   0x02 0x01          DC8 2, 1, 0, 0
   \              0x00 0x00    
   \   000000A8   0xFFFFFFFE         DC32 4294967294, 0FFFFF600H
   \              0xFFFFF600   
   \   000000B0   0x03 0x01          DC8 3, 1, 0, 0
   \              0x00 0x00    
   \   000000B4   0x001FFFFF         DC32 2097151, 0FFFFF800H
   \              0xFFFFF800   
   \   000000BC   0x04 0x00          DC8 4, 0, 0, 0
   \              0x00 0x00    
   \   000000C0   0x00E00000         DC32 14680064, 0FFFFF800H
   \              0xFFFFF800   
   \   000000C8   0x04 0x01          DC8 4, 1, 0, 0
   \              0x00 0x00    
   \   000000CC   0x00000008         DC32 8, 0FFFFF400H
   \              0xFFFFF400   
   \   000000D4   0x02 0x03          DC8 2, 3, 0, 0
   \              0x00 0x00    
    194              PINS_DBGU,
    195              PIN_USART0_RXD,
    196              PIN_USART0_TXD,
    197              PIN_USART0_CTS,
    198              PIN_USART0_RTS,
    199              
    200              HEX_SW_ADD1_1,
    201              HEX_SW_ADD1_2,
    202              HEX_SW_ADD1_3,
    203              HEX_SW_ADD1_4,
    204              
    205              HEX_SW_ADD2_1,
    206              HEX_SW_ADD2_2,
    207              HEX_SW_ADD2_3,
    208              HEX_SW_ADD2_4,
                     ^
Warning[Pe068]: integer conversion resulted in a change of sign
    209              PINS_NORFLASH,
    210              ARM_RUN_LED_OUT
    211          };
    212          
    213          /// Number of bytes received between two timer ticks.

   \                                 In section .bss, align 4
    214          volatile unsigned int bytesReceived = 0;
   \                     bytesReceived:
   \   00000000                      DS8 4
    215          
    216          /// Receive buffer.

   \                                 In section .bss, align 1
    217          unsigned char pBuffer[BUFFER_SIZE];
   \                     pBuffer:
   \   00000000                      DS8 1
    218          
    219          /// String buffer.

   \                                 In section .bss, align 4
    220          char pString[24];
   \                     pString:
   \   00000000                      DS8 24
    221          
    222          //타이머 1ms 

   \                                 In section .bss, align 4
    223          volatile unsigned int mTimerFlag = 0;
   \                     mTimerFlag:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    224          volatile unsigned int mTimerDebugCnt = 0;
   \                     mTimerDebugCnt:
   \   00000000                      DS8 4
    225          
    226          

   \                                 In section .bss, align 4
    227          unsigned int RxTimerCnt = 0;
   \                     RxTimerCnt:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    228          unsigned int RxTimerBuf[100];
   \                     RxTimerBuf:
   \   00000000                      DS8 400

   \                                 In section .bss, align 4
    229          unsigned int RxTimerBufCnt = 0;
   \                     RxTimerBufCnt:
   \   00000000                      DS8 4
    230          
    231          

   \                                 In section .bss, align 1
    232          UCHAR mHexSwitchAdd = 0;
   \                     mHexSwitchAdd:
   \   00000000                      DS8 1
    233          
    234          
    235          
    236          extern int mScanVidioFlag;
    237          extern int CHACK_DATA;
    238          
    239          //------------------------------------------------------------------------------
    240          //         Local functions
    241          //------------------------------------------------------------------------------
    242          
    243          //------------------------------------------------------------------------------
    244          /// Interrupt handler for USART0. Increments the number of bytes received in the
    245          /// current second and starts another transfer if the desired bps has not been
    246          /// met yet.
    247          //------------------------------------------------------------------------------
    248          

   \                                 In section .text, align 4, keep-with-next
    249          void ISR_Usart0(void)
    250          {
   \                     ISR_Usart0:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
    251              unsigned int status;
    252          
    253              // Read USART status
    254              status = AT91C_BASE_US0->US_CSR;
   \   00000004   0x........         LDR      R0,??DataTable9  ;; 0xfffc0014
   \   00000008   0xE5900000         LDR      R0,[R0, #+0]
   \   0000000C   0xE1B04000         MOVS     R4,R0
    255              
    256              //AT91C_US_TXBUFE
    257          
    258              // Receive buffer is full
    259              if ((status & AT91C_US_RXBUFF) == AT91C_US_RXBUFF) {
   \   00000010   0xE3140D40         TST      R4,#0x1000
   \   00000014   0x0A000016         BEQ      ??ISR_Usart0_0
    260          
    261                  bytesReceived += BUFFER_SIZE;
   \   00000018   0x........         LDR      R0,??DataTable9_1
   \   0000001C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000020   0xE2900001         ADDS     R0,R0,#+1
   \   00000024   0x........         LDR      R1,??DataTable9_1
   \   00000028   0xE5810000         STR      R0,[R1, #+0]
    262          
    263                  // Restart transfer if BPS is not high enough
    264                  if (bytesReceived < MAX_BPS) {
   \   0000002C   0x........         LDR      R0,??DataTable9_1
   \   00000030   0xE5900000         LDR      R0,[R0, #+0]
   \   00000034   0xE3A01026         MOV      R1,#+38
   \   00000038   0xE3811F80         ORR      R1,R1,#0x200
   \   0000003C   0xE1500001         CMP      R0,R1
   \   00000040   0x2A000008         BCS      ??ISR_Usart0_1
    265          
    266                      USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
   \   00000044   0xE3A02001         MOV      R2,#+1
   \   00000048   0x........         LDR      R1,??DataTable9_2
   \   0000004C   0xE3A004FC         MOV      R0,#-67108864
   \   00000050   0xE38007FF         ORR      R0,R0,#0x3FC0000
   \   00000054   0x........         BL       USART_ReadBuffer
    267                      
    268                      SCC_ISR(pBuffer[0]);
   \   00000058   0x........         LDR      R0,??DataTable9_2
   \   0000005C   0xE5D00000         LDRB     R0,[R0, #+0]
   \   00000060   0x........         BL       SCC_ISR
   \   00000064   0xEA000002         B        ??ISR_Usart0_0
    269                      
    270                  }
    271                  // Otherwise disable interrupt
    272                  else {
    273          
    274                      AT91C_BASE_US0->US_IDR = AT91C_US_RXBUFF;
   \                     ??ISR_Usart0_1:
   \   00000068   0xE3A00D40         MOV      R0,#+4096
   \   0000006C   0x........         LDR      R1,??DataTable9_3  ;; 0xfffc000c
   \   00000070   0xE5810000         STR      R0,[R1, #+0]
    275                  }
    276              }
    277          }
   \                     ??ISR_Usart0_0:
   \   00000074   0xE8BD4010         POP      {R4,LR}
   \   00000078   0xE12FFF1E         BX       LR               ;; return
    278          
    279          //------------------------------------------------------------------------------
    280          /// Interrupt handler for TC0. Displays the number of bytes received during the
    281          /// last second and the total number of bytes received, then restarts a read
    282          /// transfer on the USART if it was stopped.
    283          //------------------------------------------------------------------------------
    284          

   \                                 In section .bss, align 4
    285          UINT mTc1_Cnt = 0;
   \                     mTc1_Cnt:
   \   00000000                      DS8 4

   \                                 In section .text, align 4, keep-with-next
    286          void ISR_Tc0(void)
    287          {
   \                     ISR_Tc0:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
    288              unsigned int status;
    289              static unsigned int bytesTotal = 0;
    290          
    291              // Read TC0 status
    292              status = AT91C_BASE_TC0->TC_SR;
   \   00000004   0x........         LDR      R0,??DataTable9_4  ;; 0xfffa0020
   \   00000008   0xE5900000         LDR      R0,[R0, #+0]
   \   0000000C   0xE1B04000         MOVS     R4,R0
    293          
    294              // RC compare
    295              if ((status & AT91C_TC_CPCS) == AT91C_TC_CPCS) {
   \   00000010   0xE3140010         TST      R4,#0x10
   \   00000014   0x0A000015         BEQ      ??ISR_Tc0_0
    296            
    297                  // Display info
    298                  bytesTotal += bytesReceived;
   \   00000018   0x........         LDR      R0,??DataTable9_5
   \   0000001C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000020   0x........         LDR      R1,??DataTable9_1
   \   00000024   0xE5911000         LDR      R1,[R1, #+0]
   \   00000028   0xE0910000         ADDS     R0,R1,R0
   \   0000002C   0x........         LDR      R1,??DataTable9_5
   \   00000030   0xE5810000         STR      R0,[R1, #+0]
    299                  //sprintf(pString, "Bps: %4u; Tot: %6u\r", bytesReceived, bytesTotal);
    300                  //USART_WriteBuffer(AT91C_BASE_US0, pString, sizeof(pString));
    301                  bytesReceived = 0;
   \   00000034   0xE3A00000         MOV      R0,#+0
   \   00000038   0x........         LDR      R1,??DataTable9_1
   \   0000003C   0xE5810000         STR      R0,[R1, #+0]
    302          
    303                  // 통신 수신 인터럽트가 발생 하였는지 다시 한번 확인 하는 부분.
    304                  // Resume transfer if needed
    305                  if (AT91C_BASE_US0->US_RCR == 0) {
   \   00000040   0x........         LDR      R0,??DataTable9_6  ;; 0xfffc0104
   \   00000044   0xE5900000         LDR      R0,[R0, #+0]
   \   00000048   0xE3500000         CMP      R0,#+0
   \   0000004C   0x1A000007         BNE      ??ISR_Tc0_0
    306                      USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
   \   00000050   0xE3A02001         MOV      R2,#+1
   \   00000054   0x........         LDR      R1,??DataTable9_2
   \   00000058   0xE3A004FC         MOV      R0,#-67108864
   \   0000005C   0xE38007FF         ORR      R0,R0,#0x3FC0000
   \   00000060   0x........         BL       USART_ReadBuffer
    307                      AT91C_BASE_US0->US_IER = AT91C_US_RXBUFF;
   \   00000064   0xE3A00D40         MOV      R0,#+4096
   \   00000068   0x........         LDR      R1,??DataTable9_7  ;; 0xfffc0008
   \   0000006C   0xE5810000         STR      R0,[R1, #+0]
    308                  }
    309              }
    310          }
   \                     ??ISR_Tc0_0:
   \   00000070   0xE8BD4010         POP      {R4,LR}
   \   00000074   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .bss, align 4
   \                     ??bytesTotal:
   \   00000000                      DS8 4
    311          /****************************************************************************/
    312          // 1 = RED : 2 = GREEN : 3 = AMBER
    313          // 
    314          /****************************************************************************/
    315          
    316          

   \                                 In section .text, align 4, keep-with-next
    317          void ISR_Tc1(void)
    318          {
   \                     ISR_Tc1:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
    319             unsigned int status;
    320             static UINT sLineCnt = 15;
    321             static UINT sLineCnt2 = 0;
    322             UCHAR *pVd = (UCHAR *)DOT_VIDEO;
   \   00000004   0xE3A05580         MOV      R5,#+536870912
    323             static UINT sScreenSize = 224;
    324             
    325              // Read TC0 status
    326              status = AT91C_BASE_TC1->TC_SR;
   \   00000008   0x........         LDR      R0,??DataTable9_8  ;; 0xfffa0060
   \   0000000C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000010   0xE1B04000         MOVS     R4,R0
    327              
    328              
    329              //if( ADD_CHECK() == 0x0F || ADD_CHECK() == 0x1F ){ sScreenSize = 96;}
    330              //else {sScreenSize = 224;}
    331                
    332              // RC compare
    333              
    334              if (((status & AT91C_TC_CPCS) == AT91C_TC_CPCS))
   \   00000014   0xE3140010         TST      R4,#0x10
   \   00000018   0x0A00003F         BEQ      ??ISR_Tc1_0
    335              {
    336                   // Module Data Tx Enable
    337          
    338                    if(mScanVidioFlag || sLineCnt2 != 0)
   \   0000001C   0x........         LDR      R0,??DataTable9_9
   \   00000020   0xE5900000         LDR      R0,[R0, #+0]
   \   00000024   0xE3500000         CMP      R0,#+0
   \   00000028   0x1A000003         BNE      ??ISR_Tc1_1
   \   0000002C   0x........         LDR      R0,??DataTable9_10
   \   00000030   0xE5900000         LDR      R0,[R0, #+0]
   \   00000034   0xE3500000         CMP      R0,#+0
   \   00000038   0x0A000037         BEQ      ??ISR_Tc1_0
    339                    {
    340                            *(char *)0x30400000 = 0x00; // OE_Off
   \                     ??ISR_Tc1_1:
   \   0000003C   0xE3A00000         MOV      R0,#+0
   \   00000040   0xE3A015C1         MOV      R1,#+809500672
   \   00000044   0xE5C10000         STRB     R0,[R1, #+0]
    341                            *(char *)0x30400000 = 0x03; // OE_ON
   \   00000048   0xE3A00003         MOV      R0,#+3
   \   0000004C   0xE3A015C1         MOV      R1,#+809500672
   \   00000050   0xE5C10000         STRB     R0,[R1, #+0]
    342                             
    343                            *(char *)0x30600000 = 0x00; // LT_Off
   \   00000054   0xE3A00000         MOV      R0,#+0
   \   00000058   0xE3A015C0         MOV      R1,#+805306368
   \   0000005C   0xE3811860         ORR      R1,R1,#0x600000
   \   00000060   0xE5C10000         STRB     R0,[R1, #+0]
    344                            *(char *)0x30600000 = 0x03; // LT_On
   \   00000064   0xE3A00003         MOV      R0,#+3
   \   00000068   0xE3A015C0         MOV      R1,#+805306368
   \   0000006C   0xE3811860         ORR      R1,R1,#0x600000
   \   00000070   0xE5C10000         STRB     R0,[R1, #+0]
    345                            
    346                            *(char *)0x30600000 = 0x00; // LT_off 
   \   00000074   0xE3A00000         MOV      R0,#+0
   \   00000078   0xE3A015C0         MOV      R1,#+805306368
   \   0000007C   0xE3811860         ORR      R1,R1,#0x600000
   \   00000080   0xE5C10000         STRB     R0,[R1, #+0]
    347                            *(char *)0x30400000 = 0x00; // OE_off
   \   00000084   0xE3A00000         MOV      R0,#+0
   \   00000088   0xE3A015C1         MOV      R1,#+809500672
   \   0000008C   0xE5C10000         STRB     R0,[R1, #+0]
    348                            
    349                           *(char *)0x30000000 = (sLineCnt); // addres
   \   00000090   0x........         LDR      R0,??DataTable9_11
   \   00000094   0xE5900000         LDR      R0,[R0, #+0]
   \   00000098   0xE3A015C0         MOV      R1,#+805306368
   \   0000009C   0xE5C10000         STRB     R0,[R1, #+0]
    350                           
    351                            AT26_Write(&at26,&pVd[((sLineCnt2)*sScreenSize)], (sScreenSize+1), 0);
   \   000000A0   0xE3A03000         MOV      R3,#+0
   \   000000A4   0x........         LDR      R0,??DataTable9_12
   \   000000A8   0xE5900000         LDR      R0,[R0, #+0]
   \   000000AC   0xE2902001         ADDS     R2,R0,#+1
   \   000000B0   0x........         LDR      R0,??DataTable9_10
   \   000000B4   0xE5900000         LDR      R0,[R0, #+0]
   \   000000B8   0x........         LDR      R1,??DataTable9_12
   \   000000BC   0xE591C000         LDR      R12,[R1, #+0]
   \   000000C0   0xE021509C         MLA      R1,R12,R0,R5
   \   000000C4   0x........         LDR      R0,??DataTable9_13
   \   000000C8   0x........         BL       AT26_Write
    352                            
    353                            sLineCnt++;
   \   000000CC   0x........         LDR      R0,??DataTable9_11
   \   000000D0   0xE5900000         LDR      R0,[R0, #+0]
   \   000000D4   0xE2900001         ADDS     R0,R0,#+1
   \   000000D8   0x........         LDR      R1,??DataTable9_11
   \   000000DC   0xE5810000         STR      R0,[R1, #+0]
    354                            sLineCnt = sLineCnt%16;
   \   000000E0   0x........         LDR      R0,??DataTable9_11
   \   000000E4   0xE5900000         LDR      R0,[R0, #+0]
   \   000000E8   0xE210000F         ANDS     R0,R0,#0xF       ;; Zero extend
   \   000000EC   0x........         LDR      R1,??DataTable9_11
   \   000000F0   0xE5810000         STR      R0,[R1, #+0]
    355                            
    356                            sLineCnt2++;
   \   000000F4   0x........         LDR      R0,??DataTable9_10
   \   000000F8   0xE5900000         LDR      R0,[R0, #+0]
   \   000000FC   0xE2900001         ADDS     R0,R0,#+1
   \   00000100   0x........         LDR      R1,??DataTable9_10
   \   00000104   0xE5810000         STR      R0,[R1, #+0]
    357                            sLineCnt2 = sLineCnt2%16;
   \   00000108   0x........         LDR      R0,??DataTable9_10
   \   0000010C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000110   0xE210000F         ANDS     R0,R0,#0xF       ;; Zero extend
   \   00000114   0x........         LDR      R1,??DataTable9_10
   \   00000118   0xE5810000         STR      R0,[R1, #+0]
    358                    }
    359              }
    360           
    361          }
   \                     ??ISR_Tc1_0:
   \   0000011C   0xE8BD4031         POP      {R0,R4,R5,LR}
   \   00000120   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .data, align 4
   \                     ??sLineCnt:
   \   00000000   0x0000000F         DC32 15

   \                                 In section .bss, align 4
   \                     ??sLineCnt2:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
   \                     ??sScreenSize:
   \   00000000   0x000000E0         DC32 224
    362          
    363          //------------------------------------------------------------------------------
    364          /// Configures USART0 in hardware handshaking mode, asynchronous, 8 bits, 1 stop
    365          /// bit, no parity, 115200 bauds and enables its transmitter and receiver.
    366          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    367          void ConfigureUsart0(void)
    368          {
   \                     ConfigureUsart0:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
    369              unsigned int mode = //AT91C_US_USMODE_HWHSH
    370                                    AT91C_US_USMODE_RS485
    371                                  | AT91C_US_CLKS_CLOCK
    372                                  | AT91C_US_CHRL_8_BITS
    373                                  | AT91C_US_PAR_NONE
    374                                  | AT91C_US_NBSTOP_1_BIT
    375                                  | AT91C_US_CHMODE_NORMAL;
   \   00000004   0xE3A040C1         MOV      R4,#+193
   \   00000008   0xE3844E80         ORR      R4,R4,#0x800
    376          
    377              // Enable the peripheral clock in the PMC
    378              PMC_EnablePeripheral(AT91C_ID_US0);
   \   0000000C   0xE3A00006         MOV      R0,#+6
   \   00000010   0x........         BL       PMC_EnablePeripheral
    379          
    380              // Configure the USART in the desired mode @115200 bauds
    381              USART_Configure(AT91C_BASE_US0, mode, 9600, BOARD_MCK);
   \   00000014   0xE3A037B7         MOV      R3,#+47972352
   \   00000018   0xE3833C6C         ORR      R3,R3,#0x6C00
   \   0000001C   0xE3A02D96         MOV      R2,#+9600
   \   00000020   0xE1B01004         MOVS     R1,R4
   \   00000024   0xE3A004FC         MOV      R0,#-67108864
   \   00000028   0xE38007FF         ORR      R0,R0,#0x3FC0000
   \   0000002C   0x........         BL       USART_Configure
    382          
    383              // Configure the RXBUFF interrupt
    384              AIC_ConfigureIT(AT91C_ID_US0, 0, ISR_Usart0);
   \   00000030   0x........         ADR      R2,ISR_Usart0
   \   00000034   0xE3A01000         MOV      R1,#+0
   \   00000038   0xE3A00006         MOV      R0,#+6
   \   0000003C   0x........         BL       AIC_ConfigureIT
    385              AIC_EnableIT(AT91C_ID_US0);
   \   00000040   0xE3A00006         MOV      R0,#+6
   \   00000044   0x........         BL       AIC_EnableIT
    386          
    387              // Enable receiver & transmitter
    388              USART_SetTransmitterEnabled(AT91C_BASE_US0, 1);
   \   00000048   0xE3A01001         MOV      R1,#+1
   \   0000004C   0xE3A004FC         MOV      R0,#-67108864
   \   00000050   0xE38007FF         ORR      R0,R0,#0x3FC0000
   \   00000054   0x........         BL       USART_SetTransmitterEnabled
    389              USART_SetReceiverEnabled(AT91C_BASE_US0, 1);
   \   00000058   0xE3A01001         MOV      R1,#+1
   \   0000005C   0xE3A004FC         MOV      R0,#-67108864
   \   00000060   0xE38007FF         ORR      R0,R0,#0x3FC0000
   \   00000064   0x........         BL       USART_SetReceiverEnabled
    390          }
   \   00000068   0xE8BD4010         POP      {R4,LR}
   \   0000006C   0xE12FFF1E         BX       LR               ;; return
    391          
    392          //------------------------------------------------------------------------------
    393          /// Configures Timer Counter 0 (TC0) to generate an interrupt every second. This
    394          /// interrupt will be used to display the number of bytes received on the USART.
    395          //------------------------------------------------------------------------------
    396          

   \                                 In section .text, align 4, keep-with-next
    397          void ConfigureTc0(void)
    398          {
   \                     ConfigureTc0:
   \   00000000   0xE92D4000         PUSH     {LR}
   \   00000004   0xE24DD00C         SUB      SP,SP,#+12
    399          	unsigned int div, tcclks;
    400          	//------------------------------------------------------------//
    401          	// Enable TC0 peripheral clock
    402          	PMC_EnablePeripheral(AT91C_ID_TC0);
   \   00000008   0xE3A0000C         MOV      R0,#+12
   \   0000000C   0x........         BL       PMC_EnablePeripheral
    403             
    404          	/// Configure TC for a 1s (= 1Hz) tick
    405          	TC_FindMckDivisor(1, BOARD_MCK, &div, &tcclks);
   \   00000010   0xE1B0300D         MOVS     R3,SP
   \   00000014   0xE28D2004         ADD      R2,SP,#+4
   \   00000018   0xE3A017B7         MOV      R1,#+47972352
   \   0000001C   0xE3811C6C         ORR      R1,R1,#0x6C00
   \   00000020   0xE3A00001         MOV      R0,#+1
   \   00000024   0x........         BL       TC_FindMckDivisor
    406          	TC_Configure(AT91C_BASE_TC0, tcclks | AT91C_TC_CPCTRG);
   \   00000028   0xE59D0000         LDR      R0,[SP, #+0]
   \   0000002C   0xE3901C40         ORRS     R1,R0,#0x4000
   \   00000030   0xE3A004FF         MOV      R0,#-16777216
   \   00000034   0xE38008FA         ORR      R0,R0,#0xFA0000
   \   00000038   0x........         BL       TC_Configure
    407          	AT91C_BASE_TC0->TC_RC = (BOARD_MCK / (2 * div)); //500ms
   \   0000003C   0xE3A007B7         MOV      R0,#+47972352
   \   00000040   0xE3800C6C         ORR      R0,R0,#0x6C00
   \   00000044   0xE59D1004         LDR      R1,[SP, #+4]
   \   00000048   0xE1B01081         LSLS     R1,R1,#+1
   \   0000004C   0x........         BL       __aeabi_uidiv
   \   00000050   0x........         LDR      R1,??DataTable9_14  ;; 0xfffa001c
   \   00000054   0xE5810000         STR      R0,[R1, #+0]
    408          
    409          	// Configure interrupt on RC compare
    410          	AIC_ConfigureIT(AT91C_ID_TC0, 0, ISR_Tc0);
   \   00000058   0x........         ADR      R2,ISR_Tc0
   \   0000005C   0xE3A01000         MOV      R1,#+0
   \   00000060   0xE3A0000C         MOV      R0,#+12
   \   00000064   0x........         BL       AIC_ConfigureIT
    411          	AT91C_BASE_TC0->TC_IER = AT91C_TC_CPCS;
   \   00000068   0xE3A00010         MOV      R0,#+16
   \   0000006C   0x........         LDR      R1,??DataTable9_15  ;; 0xfffa0024
   \   00000070   0xE5810000         STR      R0,[R1, #+0]
    412          	AIC_EnableIT(AT91C_ID_TC0);
   \   00000074   0xE3A0000C         MOV      R0,#+12
   \   00000078   0x........         BL       AIC_EnableIT
    413          }
   \   0000007C   0xE8BD4007         POP      {R0-R2,LR}
   \   00000080   0xE12FFF1E         BX       LR               ;; return
    414          

   \                                 In section .text, align 4, keep-with-next
    415          void ConfigureTc1(void)
    416          {
   \                     ConfigureTc1:
   \   00000000   0xE92D4000         PUSH     {LR}
   \   00000004   0xE24DD00C         SUB      SP,SP,#+12
    417          	unsigned int div, tcclks;
    418             
    419          	PMC_EnablePeripheral(AT91C_ID_TC1);
   \   00000008   0xE3A0000D         MOV      R0,#+13
   \   0000000C   0x........         BL       PMC_EnablePeripheral
    420             
    421          	TC_FindMckDivisor(1, BOARD_MCK, &div, &tcclks);
   \   00000010   0xE1B0300D         MOVS     R3,SP
   \   00000014   0xE28D2004         ADD      R2,SP,#+4
   \   00000018   0xE3A017B7         MOV      R1,#+47972352
   \   0000001C   0xE3811C6C         ORR      R1,R1,#0x6C00
   \   00000020   0xE3A00001         MOV      R0,#+1
   \   00000024   0x........         BL       TC_FindMckDivisor
    422          	TC_Configure(AT91C_BASE_TC1, tcclks | AT91C_TC_CPCTRG);
   \   00000028   0xE59D0000         LDR      R0,[SP, #+0]
   \   0000002C   0xE3901C40         ORRS     R1,R0,#0x4000
   \   00000030   0x........         LDR      R0,??DataTable9_16  ;; 0xfffa0040
   \   00000034   0x........         BL       TC_Configure
    423          	AT91C_BASE_TC1->TC_RC = (BOARD_MCK / (2100 * div)); // 약 235마이크로 동작 속도
   \   00000038   0xE3A007B7         MOV      R0,#+47972352
   \   0000003C   0xE3800C6C         ORR      R0,R0,#0x6C00
   \   00000040   0xE59D1004         LDR      R1,[SP, #+4]
   \   00000044   0xE3A02034         MOV      R2,#+52
   \   00000048   0xE3822E80         ORR      R2,R2,#0x800
   \   0000004C   0xE0110192         MULS     R1,R2,R1
   \   00000050   0x........         BL       __aeabi_uidiv
   \   00000054   0x........         LDR      R1,??DataTable9_17  ;; 0xfffa005c
   \   00000058   0xE5810000         STR      R0,[R1, #+0]
    424             
    425          	AIC_ConfigureIT(AT91C_ID_TC1, 0, ISR_Tc1);
   \   0000005C   0x........         ADR      R2,ISR_Tc1
   \   00000060   0xE3A01000         MOV      R1,#+0
   \   00000064   0xE3A0000D         MOV      R0,#+13
   \   00000068   0x........         BL       AIC_ConfigureIT
    426          	AT91C_BASE_TC1->TC_IER = AT91C_TC_CPCS;
   \   0000006C   0xE3A00010         MOV      R0,#+16
   \   00000070   0x........         LDR      R1,??DataTable9_18  ;; 0xfffa0064
   \   00000074   0xE5810000         STR      R0,[R1, #+0]
    427          	AIC_EnableIT(AT91C_ID_TC1);
   \   00000078   0xE3A0000D         MOV      R0,#+13
   \   0000007C   0x........         BL       AIC_EnableIT
    428          
    429          }
   \   00000080   0xE8BD4007         POP      {R0-R2,LR}
   \   00000084   0xE12FFF1E         BX       LR               ;; return
    430          
    431          //------------------------------------------------------------------------------
    432          /// Interrupt service routine for the PIT. Debounces the wake-up pin input.
    433          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    434          static void ISR_Pit(void)
    435          {
   \                     ISR_Pit:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
    436              unsigned long pisr = 0;
   \   00000004   0xE3A04000         MOV      R4,#+0
    437          
    438              // Read the PISR
    439              pisr = PIT_GetStatus() & AT91C_PITC_PITS;
   \   00000008   0x........         BL       PIT_GetStatus
   \   0000000C   0xE2100001         ANDS     R0,R0,#0x1
   \   00000010   0xE1B04000         MOVS     R4,R0
    440          
    441              if (pisr != 0) {
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x0A000003         BEQ      ??ISR_Pit_0
    442          
    443                  // Read the PIVR. It acknowledges the IT
    444                  PIT_GetPIVR();
   \   0000001C   0x........         BL       PIT_GetPIVR
    445                  
    446                   mTimerFlag = TRUE;
   \   00000020   0xE3A00001         MOV      R0,#+1
   \   00000024   0x........         LDR      R1,??DataTable9_19
   \   00000028   0xE5810000         STR      R0,[R1, #+0]
    447              }
    448          
    449          }
   \                     ??ISR_Pit_0:
   \   0000002C   0xE8BD4010         POP      {R4,LR}
   \   00000030   0xE12FFF1E         BX       LR               ;; return
    450          
    451          //------------------------------------------------------------------------------
    452          /// Configures the PIT to generate 1ms ticks. 
    453          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    454          static void ConfigurePit(void)
    455          {
   \                     ConfigurePit:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    456              // Initialize and enable the PIT
    457              PIT_Init(PIT_PERIOD, BOARD_MCK / 1000000);
   \   00000004   0xE3A01030         MOV      R1,#+48
   \   00000008   0xE3A00FFA         MOV      R0,#+1000
   \   0000000C   0x........         BL       PIT_Init
    458          
    459              // Disable the interrupt on the interrupt controller
    460              AIC_DisableIT(AT91C_ID_SYS);
   \   00000010   0xE3A00001         MOV      R0,#+1
   \   00000014   0x........         BL       AIC_DisableIT
    461          
    462              // Configure the AIC for PIT interrupts
    463              AIC_ConfigureIT(AT91C_ID_SYS, 0, ISR_Pit);
   \   00000018   0x........         ADR      R2,ISR_Pit
   \   0000001C   0xE3A01000         MOV      R1,#+0
   \   00000020   0xE3A00001         MOV      R0,#+1
   \   00000024   0x........         BL       AIC_ConfigureIT
    464          
    465              // Enable the interrupt on the interrupt controller
    466              AIC_EnableIT(AT91C_ID_SYS);
   \   00000028   0xE3A00001         MOV      R0,#+1
   \   0000002C   0x........         BL       AIC_EnableIT
    467          
    468              // Enable the interrupt on the pit
    469              PIT_EnableIT();
   \   00000030   0x........         BL       PIT_EnableIT
    470          
    471              // Enable the pit
    472              PIT_Enable();
   \   00000034   0x........         BL       PIT_Enable
    473          }
   \   00000038   0xE8BD4001         POP      {R0,LR}
   \   0000003C   0xE12FFF1E         BX       LR               ;; return
    474          
    475          //------------------------------------------------------------------------------
    476          //         SW_TIMER (1ms)
    477          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    478          void SW_TIMER(void)
    479          {
   \                     SW_TIMER:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    480          	static int sSw_Timer_Cnt = 0; 
    481            
    482          	mTimerDebugCnt++;
   \   00000004   0x........         LDR      R0,??DataTable9_20
   \   00000008   0xE5900000         LDR      R0,[R0, #+0]
   \   0000000C   0xE2900001         ADDS     R0,R0,#+1
   \   00000010   0x........         LDR      R1,??DataTable9_20
   \   00000014   0xE5810000         STR      R0,[R1, #+0]
    483          	SCC_ISR_Timer(); // 통신 함수 타이머 
   \   00000018   0x........         BL       SCC_ISR_Timer
    484            
    485          	if(!(mTimerDebugCnt%100))
   \   0000001C   0x........         LDR      R0,??DataTable9_20
   \   00000020   0xE5900000         LDR      R0,[R0, #+0]
   \   00000024   0xE3A01064         MOV      R1,#+100
   \   00000028   0x........         BL       __aeabi_uidivmod
   \   0000002C   0xE3510000         CMP      R1,#+0
   \   00000030   0x1A00000B         BNE      ??SW_TIMER_0
    486          	{
    487          		sSw_Timer_Cnt++;
   \   00000034   0x........         LDR      R0,??DataTable9_21
   \   00000038   0xE5900000         LDR      R0,[R0, #+0]
   \   0000003C   0xE2900001         ADDS     R0,R0,#+1
   \   00000040   0x........         LDR      R1,??DataTable9_21
   \   00000044   0xE5810000         STR      R0,[R1, #+0]
    488          		AT91C_BASE_PIOA->PIO_ODSR ^= AT91C_PIO_PA3;	//해당핀을 출력 토글	
   \   00000048   0xE3E000C7         MVN      R0,#+199
   \   0000004C   0xE3C00EB0         BIC      R0,R0,#0xB00
   \   00000050   0xE5900000         LDR      R0,[R0, #+0]
   \   00000054   0xE2300008         EORS     R0,R0,#0x8
   \   00000058   0xE3E010C7         MVN      R1,#+199
   \   0000005C   0xE3C11EB0         BIC      R1,R1,#0xB00
   \   00000060   0xE5810000         STR      R0,[R1, #+0]
    489              
    490          	}
    491          }
   \                     ??SW_TIMER_0:
   \   00000064   0xE8BD4001         POP      {R0,LR}
   \   00000068   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .bss, align 4
   \                     ??sSw_Timer_Cnt:
   \   00000000                      DS8 4
    492          
    493          //**********************************************************************************
    494          //	HEXA 값을 읽어 온다..
    495          //**********************************************************************************

   \                                 In section .text, align 4, keep-with-next
    496          unsigned char ChackHexa(void)
    497          {
   \                     ChackHexa:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
    498          	unsigned char H_Add_Buff=0;
   \   00000004   0xE3A04000         MOV      R4,#+0
    499          	unsigned char L_Add_Buff=0;        
   \   00000008   0xE3A05000         MOV      R5,#+0
    500          
    501          	H_Add_Buff  = PIO_Get(&pins[5])<<3;
   \   0000000C   0x........         LDR      R0,??DataTable9_22
   \   00000010   0x........         BL       PIO_Get
   \   00000014   0xE1B00180         LSLS     R0,R0,#+3
   \   00000018   0xE1B04000         MOVS     R4,R0
    502          	H_Add_Buff |= PIO_Get(&pins[6])<<2;
   \   0000001C   0x........         LDR      R0,??DataTable9_23
   \   00000020   0x........         BL       PIO_Get
   \   00000024   0xE1940100         ORRS     R0,R4,R0, LSL #+2
   \   00000028   0xE1B04000         MOVS     R4,R0
    503          	H_Add_Buff |= PIO_Get(&pins[7])<<1;
   \   0000002C   0x........         LDR      R0,??DataTable9_24
   \   00000030   0x........         BL       PIO_Get
   \   00000034   0xE1940080         ORRS     R0,R4,R0, LSL #+1
   \   00000038   0xE1B04000         MOVS     R4,R0
    504          	H_Add_Buff |= PIO_Get(&pins[8])&0x01;      
   \   0000003C   0x........         LDR      R0,??DataTable9_25
   \   00000040   0x........         BL       PIO_Get
   \   00000044   0xE2100001         ANDS     R0,R0,#0x1
   \   00000048   0xE1900004         ORRS     R0,R0,R4
   \   0000004C   0xE1B04000         MOVS     R4,R0
    505          
    506          	L_Add_Buff  = PIO_Get(&pins[9])<<3;
   \   00000050   0x........         LDR      R0,??DataTable9_26
   \   00000054   0x........         BL       PIO_Get
   \   00000058   0xE1B00180         LSLS     R0,R0,#+3
   \   0000005C   0xE1B05000         MOVS     R5,R0
    507          	L_Add_Buff |= PIO_Get(&pins[10])<<2;
   \   00000060   0x........         LDR      R0,??DataTable9_27
   \   00000064   0x........         BL       PIO_Get
   \   00000068   0xE1950100         ORRS     R0,R5,R0, LSL #+2
   \   0000006C   0xE1B05000         MOVS     R5,R0
    508          	L_Add_Buff |= PIO_Get(&pins[11])<<1;
   \   00000070   0x........         LDR      R0,??DataTable9_28
   \   00000074   0x........         BL       PIO_Get
   \   00000078   0xE1950080         ORRS     R0,R5,R0, LSL #+1
   \   0000007C   0xE1B05000         MOVS     R5,R0
    509          	L_Add_Buff |= PIO_Get(&pins[12])&0x01;       
   \   00000080   0x........         LDR      R0,??DataTable9_29
   \   00000084   0x........         BL       PIO_Get
   \   00000088   0xE2100001         ANDS     R0,R0,#0x1
   \   0000008C   0xE1900005         ORRS     R0,R0,R5
   \   00000090   0xE1B05000         MOVS     R5,R0
    510                    
    511          	return ~((H_Add_Buff<<4)|L_Add_Buff);
   \   00000094   0xE21440FF         ANDS     R4,R4,#0xFF      ;; Zero extend
   \   00000098   0xE21550FF         ANDS     R5,R5,#0xFF      ;; Zero extend
   \   0000009C   0xE1950204         ORRS     R0,R5,R4, LSL #+4
   \   000000A0   0xE1F00000         MVNS     R0,R0
   \   000000A4   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000A8   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   000000AC   0xE12FFF1E         BX       LR               ;; return
    512          }
    513          
    514          //**********************************************************************************
    515          //	ADD_CHECK
    516          //**********************************************************************************

   \                                 In section .text, align 4, keep-with-next
    517          int ADD_CHECK(void)
    518          {
   \                     ADD_CHECK:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    519          	// 장치 어드레스 인식 부분,
    520          	if(!mHexSwitchAdd)
   \   00000004   0x........         LDR      R0,??DataTable9_30
   \   00000008   0xE5D00000         LDRB     R0,[R0, #+0]
   \   0000000C   0xE3500000         CMP      R0,#+0
   \   00000010   0x1A000002         BNE      ??ADD_CHECK_0
    521          	{
    522          		mHexSwitchAdd = ChackHexa();
   \   00000014   0x........         BL       ChackHexa
   \   00000018   0x........         LDR      R1,??DataTable9_30
   \   0000001C   0xE5C10000         STRB     R0,[R1, #+0]
    523          	}
    524          	return mHexSwitchAdd;
   \                     ??ADD_CHECK_0:
   \   00000020   0x........         LDR      R0,??DataTable9_30
   \   00000024   0xE5D00000         LDRB     R0,[R0, #+0]
   \   00000028   0xE8BD4002         POP      {R1,LR}
   \   0000002C   0xE12FFF1E         BX       LR               ;; return
    525          }
    526          //**********************************************************************************
    527          //	MODE_SET
    528          //**********************************************************************************

   \                                 In section .text, align 4, keep-with-next
    529          void MODE_SET(void)
    530          {
    531                  AT91C_BASE_PIOA->PIO_OER   = AT91C_PIO_PA3;	//출력 버퍼 ENABLE
   \                     MODE_SET:
   \   00000000   0xE3A00008         MOV      R0,#+8
   \   00000004   0xE3E010EF         MVN      R1,#+239
   \   00000008   0xE3C11EB0         BIC      R1,R1,#0xB00
   \   0000000C   0xE5810000         STR      R0,[R1, #+0]
    532          	AT91C_BASE_PIOA->PIO_PER   = AT91C_PIO_PA3;	//IO 포트로 사용
   \   00000010   0xE3A00008         MOV      R0,#+8
   \   00000014   0xE3E010FF         MVN      R1,#+255
   \   00000018   0xE3C11EB0         BIC      R1,R1,#0xB00
   \   0000001C   0xE5810000         STR      R0,[R1, #+0]
    533          	AT91C_BASE_PIOA->PIO_PPUDR = AT91C_PIO_PA3;	//각 핀을 풀업하지 않음
   \   00000020   0xE3A00008         MOV      R0,#+8
   \   00000024   0xE3E0109F         MVN      R1,#+159
   \   00000028   0xE3C11EB0         BIC      R1,R1,#0xB00
   \   0000002C   0xE5810000         STR      R0,[R1, #+0]
    534          	AT91C_BASE_PIOA->PIO_OWER  = AT91C_PIO_PA3;	//각 핀을 IO 동시 출력으로 설정함    
   \   00000030   0xE3A00008         MOV      R0,#+8
   \   00000034   0xE3E0105F         MVN      R1,#+95
   \   00000038   0xE3C11EB0         BIC      R1,R1,#0xB00
   \   0000003C   0xE5810000         STR      R0,[R1, #+0]
    535          	AT91C_BASE_PIOA->PIO_BSR= ((unsigned int) AT91C_PA20_NCS2_CFCS1);
   \   00000040   0xE3A00940         MOV      R0,#+1048576
   \   00000044   0xE3E0108B         MVN      R1,#+139
   \   00000048   0xE3C11EB0         BIC      R1,R1,#0xB00
   \   0000004C   0xE5810000         STR      R0,[R1, #+0]
    536          	AT91C_BASE_PIOA->PIO_PDR =((unsigned int) AT91C_PA20_NCS2_CFCS1); 	
   \   00000050   0xE3A00940         MOV      R0,#+1048576
   \   00000054   0xE3E010FB         MVN      R1,#+251
   \   00000058   0xE3C11EB0         BIC      R1,R1,#0xB00
   \   0000005C   0xE5810000         STR      R0,[R1, #+0]
    537          }
   \   00000060   0xE12FFF1E         BX       LR               ;; return
    538          
    539          //------------------------------------------------------------------------------
    540          /// Application entry point. Configures USART0 in hardware handshaking mode and
    541          /// Timer Counter 0 to generate an interrupt every second. Then, starts the first
    542          /// transfer on the USART and wait in an endless loop.
    543          /// \return Unused.
    544          //------------------------------------------------------------------------------

   \                                 In section .bss, align 4
    545          UCHAR TextBuf[1024];
   \                     TextBuf:
   \   00000000                      DS8 1024

   \                                 In section .bss, align 4
    546          UCHAR TextBuf_2[1024];
   \                     TextBuf_2:
   \   00000000                      DS8 1024
    547          
    548          

   \                                 In section .text, align 4, keep-with-next
    549          int main(void)
    550          {
   \                     main:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE24DD008         SUB      SP,SP,#+8
    551              
    552            
    553              //unsigned int i = 0;
    554              
    555              *AT91C_RSTC_RMR=0xA5000A01;//Reset Enable
   \   00000008   0x........         LDR      R0,??DataTable9_31  ;; 0xa5000a01
   \   0000000C   0xE3E010F7         MVN      R1,#+247
   \   00000010   0xE3C11F80         BIC      R1,R1,#0x200
   \   00000014   0xE5810000         STR      R0,[R1, #+0]
    556          
    557              unsigned char *pSRamBuffer = (unsigned char *) AT91C_EBI_SDRAM;
   \   00000018   0xE3A04580         MOV      R4,#+536870912
    558              
    559                 /* nandflash memory 변수 */ 
    560              unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
    561              unsigned char testFailed;
    562              const unsigned char busWidth[3] = {FLASH_CHIP_WIDTH_8BITS, FLASH_CHIP_WIDTH_16BITS, FLASH_CHIP_WIDTH_32BITS};
   \   0000001C   0xE1B0000D         MOVS     R0,SP
   \   00000020   0x........         LDR      R1,??DataTable9_32
   \   00000024   0xE5912000         LDR      R2,[R1, #0]
   \   00000028   0xE5802000         STR      R2,[R0, #+0]
    563              
    564             
    565              // Configure pins
    566              PIO_Configure(pins, PIO_LISTSIZE(pins));
   \   0000002C   0xE3A01012         MOV      R1,#+18
   \   00000030   0x........         LDR      R0,??DataTable9_33
   \   00000034   0x........         BL       PIO_Configure
    567              
    568                  //SDRAM 설정 
    569              BOARD_ConfigureSdram(BOARD_SDRAM_BUSWIDTH);
   \   00000038   0xE3A00010         MOV      R0,#+16
   \   0000003C   0x........         BL       BOARD_ConfigureSdram
    570              
    571               /************ TCO(통신 수신 확인) 설정 및 통신 설정.***************************/
    572              ConfigureUsart0(); // 통신 설정.
   \   00000040   0x........         BL       ConfigureUsart0
    573              ConfigureTc0();    // 타이머 설정.
   \   00000044   0x........         BL       ConfigureTc0
    574              
    575               // Start receiving data and start timer
    576              USART_ReadBuffer(AT91C_BASE_US0, pBuffer, BUFFER_SIZE);
   \   00000048   0xE3A02001         MOV      R2,#+1
   \   0000004C   0x........         LDR      R1,??DataTable9_2
   \   00000050   0xE3A004FC         MOV      R0,#-67108864
   \   00000054   0xE38007FF         ORR      R0,R0,#0x3FC0000
   \   00000058   0x........         BL       USART_ReadBuffer
    577              AT91C_BASE_US0->US_IER = AT91C_US_RXBUFF;
   \   0000005C   0xE3A00D40         MOV      R0,#+4096
   \   00000060   0x........         LDR      R1,??DataTable9_7  ;; 0xfffc0008
   \   00000064   0xE5810000         STR      R0,[R1, #+0]
    578              
    579              TC_Start(AT91C_BASE_TC0); // 타이머 시작 
   \   00000068   0xE3A004FF         MOV      R0,#-16777216
   \   0000006C   0xE38008FA         ORR      R0,R0,#0xFA0000
   \   00000070   0x........         BL       TC_Start
    580              
    581               /***********SPI 설정. ***************************/
    582              SPI_Init(); //1Byte 1마이크로 
   \   00000074   0x........         BL       SPI_Init
    583              
    584              
    585              //LED Display Timer 설정.
    586              ConfigureTc1();
   \   00000078   0x........         BL       ConfigureTc1
    587              
    588              
    589              //TC_Stop(AT91C_BASE_TC1);
    590          
    591              // 타이머 설정 1ms
    592              ConfigurePit();
   \   0000007C   0x........         BL       ConfigurePit
    593             
    594              memcpy(RxTimerBuf,0x00,sizeof(RxTimerBuf));
                     ^
Warning[Pe223]: function "memcpy" declared implicitly

      unsigned char *pSRamBuffer = (unsigned char *) AT91C_EBI_SDRAM;
                     ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",557  Warning[Pe177]: 
          variable "pSRamBuffer" was declared but never referenced

      unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
                   ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",560  Warning[Pe177]: 
          variable "blockNumber" was declared but never referenced

      unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
                                ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",560  Warning[Pe177]: 
          variable "block" was declared but never referenced

      unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
                                       ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",560  Warning[Pe177]: 
          variable "blockSize" was declared but never referenced

      unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
                                                  ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",560  Warning[Pe177]: 
          variable "blockAddress" was declared but never referenced

      unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
                                                                ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",560  Warning[Pe177]: 
          variable "pageSize" was declared but never referenced

      unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
                                                                          ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",560  Warning[Pe177]: 
          variable "packetSize" was declared but never referenced

      unsigned int blockNumber, block, blockSize, blockAddress, pageSize, packetSize, i;
                                                                                      ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",560  Warning[Pe177]: 
          variable "i" was declared but never referenced

      unsigned char testFailed;
                    ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",561  Warning[Pe177]: 
          variable "testFailed" was declared but never referenced

      const unsigned char busWidth[3] = {FLASH_CHIP_WIDTH_8BITS, FLASH_CHIP_WIDTH_16BITS, FLASH_CHIP_WIDTH_32BITS};
                          ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.c",562  Warning[Pe177]: 
          variable "busWidth" was declared but never referenced
   \   00000080   0xE3A02F64         MOV      R2,#+400
   \   00000084   0xE3A01000         MOV      R1,#+0
   \   00000088   0x........         LDR      R0,??DataTable9_34
   \   0000008C   0x........         BL       memcpy
    595              //memset(TextBuf,0x11,5000);
    596              
    597              MODE_SET();
   \   00000090   0x........         BL       MODE_SET
    598              
    599              SCC_Init(); // 통신 함수 초기화 부분.
   \   00000094   0x........         BL       SCC_Init
    600              
    601              
    602              
    603              TC_Start(AT91C_BASE_TC1);
   \   00000098   0x........         LDR      R0,??DataTable9_16  ;; 0xfffa0040
   \   0000009C   0x........         BL       TC_Start
    604              
    605              ////////////////////////////////////////////////
    606          
    607              norFlash.norFlashInfo.baseAddress = BOARD_NORFLASH_ADDR;
   \   000000A0   0xE3A00540         MOV      R0,#+268435456
   \   000000A4   0x........         LDR      R1,??DataTable9_35
   \   000000A8   0xE5810004         STR      R0,[R1, #+4]
    608          
    609              BOARD_ConfigureNorFlash48MHz(FLASH_CHIP_WIDTH_8BITS * 8);
   \   000000AC   0xE3A00008         MOV      R0,#+8
   \   000000B0   0x........         BL       BOARD_ConfigureNorFlash
    610              NorFlash_CFI_Detect(&norFlash, FLASH_CHIP_WIDTH_8BITS);
   \   000000B4   0xE3A01001         MOV      R1,#+1
   \   000000B8   0x........         LDR      R0,??DataTable9_35
   \   000000BC   0x........         BL       NorFlash_CFI_Detect
    611                  
    612                 
    613              Display_Init();
   \   000000C0   0x........         BL       Display_Init
    614             
    615              /// Infinite loop
    616              while (1)
    617              {
    618                
    619                  if(mTimerFlag) // 1ms OP 
   \                     ??main_0:
   \   000000C4   0x........         LDR      R0,??DataTable9_19
   \   000000C8   0xE5900000         LDR      R0,[R0, #+0]
   \   000000CC   0xE3500000         CMP      R0,#+0
   \   000000D0   0x0A000006         BEQ      ??main_1
    620                  {
    621                    mTimerFlag = FALSE;
   \   000000D4   0xE3A00000         MOV      R0,#+0
   \   000000D8   0x........         LDR      R1,??DataTable9_19
   \   000000DC   0xE5810000         STR      R0,[R1, #+0]
    622                    SW_TIMER();
   \   000000E0   0x........         BL       SW_TIMER
    623                    
    624                    ADD_CHECK(); // PCB ADD Check
   \   000000E4   0x........         BL       ADD_CHECK
    625          
    626                    Down_int09();
   \   000000E8   0x........         BL       Down_int09
    627          
    628                    LED_Display_c_int10();
   \   000000EC   0x........         BL       LED_Display_c_int10
    629                  }
    630                  
    631                    if(SCC1_Init_AChl.RxDownloadStart){ Download_main();}
   \                     ??main_1:
   \   000000F0   0x........         LDR      R0,??DataTable9_36
   \   000000F4   0xE5D00028         LDRB     R0,[R0, #+40]
   \   000000F8   0xE3500000         CMP      R0,#+0
   \   000000FC   0x0A000001         BEQ      ??main_2
   \   00000100   0x........         BL       Download_main
   \   00000104   0xEAFFFFEE         B        ??main_0
    632                    else 
    633                    {
    634                      Display_main();
   \                     ??main_2:
   \   00000108   0x........         BL       Display_main
   \   0000010C   0xEAFFFFEC         B        ??main_0
    635                      
    636                    }
    637                  
    638                
    639              }
    640          
    641              
    642          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0xFFFC0014         DC32     0xfffc0014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     bytesReceived

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     pBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0xFFFC000C         DC32     0xfffc000c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0xFFFA0020         DC32     0xfffa0020

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     ??bytesTotal

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0xFFFC0104         DC32     0xfffc0104

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0xFFFC0008         DC32     0xfffc0008

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0xFFFA0060         DC32     0xfffa0060

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     mScanVidioFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     ??sLineCnt2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     ??sLineCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     ??sScreenSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     at26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0xFFFA001C         DC32     0xfffa001c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0xFFFA0024         DC32     0xfffa0024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0xFFFA0040         DC32     0xfffa0040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0xFFFA005C         DC32     0xfffa005c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0xFFFA0064         DC32     0xfffa0064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x........         DC32     mTimerFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x........         DC32     mTimerDebugCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x........         DC32     ??sSw_Timer_Cnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x........         DC32     pins+0x3C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0x........         DC32     pins+0x48

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_24:
   \   00000000   0x........         DC32     pins+0x54

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_25:
   \   00000000   0x........         DC32     pins+0x60

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_26:
   \   00000000   0x........         DC32     pins+0x6C

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_27:
   \   00000000   0x........         DC32     pins+0x78

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_28:
   \   00000000   0x........         DC32     pins+0x84

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_29:
   \   00000000   0x........         DC32     pins+0x90

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_30:
   \   00000000   0x........         DC32     mHexSwitchAdd

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_31:
   \   00000000   0xA5000A01         DC32     0xa5000a01

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_32:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_33:
   \   00000000   0x........         DC32     pins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_34:
   \   00000000   0x........         DC32     RxTimerBuf

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_35:
   \   00000000   0x........         DC32     norFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_36:
   \   00000000   0x........         DC32     SCC1_Init_AChl

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x01 0x02          DC8 1, 2, 4, 0
   \              0x04 0x00    
    643          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   ADD_CHECK
         8   -> ChackHexa
      16   ChackHexa
        16   -> PIO_Get
       8   ConfigurePit
         8   -> AIC_ConfigureIT
         8   -> AIC_DisableIT
         8   -> AIC_EnableIT
         8   -> PIT_Enable
         8   -> PIT_EnableIT
         8   -> PIT_Init
      16   ConfigureTc0
        16   -> AIC_ConfigureIT
        16   -> AIC_EnableIT
        16   -> PMC_EnablePeripheral
        16   -> TC_Configure
        16   -> TC_FindMckDivisor
        16 __aeabi_uidiv
      16   ConfigureTc1
        16   -> AIC_ConfigureIT
        16   -> AIC_EnableIT
        16   -> PMC_EnablePeripheral
        16   -> TC_Configure
        16   -> TC_FindMckDivisor
        16 __aeabi_uidiv
       8   ConfigureUsart0
         8   -> AIC_ConfigureIT
         8   -> AIC_EnableIT
         8   -> PMC_EnablePeripheral
         8   -> USART_Configure
         8   -> USART_SetReceiverEnabled
         8   -> USART_SetTransmitterEnabled
       8   ISR_Pit
         8   -> PIT_GetPIVR
         8   -> PIT_GetStatus
       8   ISR_Tc0
         8   -> USART_ReadBuffer
      16   ISR_Tc1
        16   -> AT26_Write
       8   ISR_Usart0
         8   -> SCC_ISR
         8   -> USART_ReadBuffer
       0   MODE_SET
       0   NorFlashAllErase
       0   NorFlashBlockErase
       0   NorFlashWrite
       8   SW_TIMER
         8   -> SCC_ISR_Timer
         8 __aeabi_uidivmod
      16   main
        16   -> ADD_CHECK
        16   -> BOARD_ConfigureNorFlash
        16   -> BOARD_ConfigureSdram
        16   -> ConfigurePit
        16   -> ConfigureTc0
        16   -> ConfigureTc1
        16   -> ConfigureUsart0
        16   -> Display_Init
        16   -> Display_main
        16   -> Down_int09
        16   -> Download_main
        16   -> LED_Display_c_int10
        16   -> MODE_SET
        16   -> NorFlash_CFI_Detect
        16   -> PIO_Configure
        16   -> SCC_Init
        16   -> SPI_Init
        16   -> SW_TIMER
        16   -> TC_Start
        16   -> USART_ReadBuffer
        16   -> memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_26
       4  ??DataTable9_27
       4  ??DataTable9_28
       4  ??DataTable9_29
       4  ??DataTable9_3
       4  ??DataTable9_30
       4  ??DataTable9_31
       4  ??DataTable9_32
       4  ??DataTable9_33
       4  ??DataTable9_34
       4  ??DataTable9_35
       4  ??DataTable9_36
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
       4  ?_0
      48  ADD_CHECK
     176  ChackHexa
      64  ConfigurePit
     132  ConfigureTc0
     136  ConfigureTc1
     112  ConfigureUsart0
      52  ISR_Pit
     120  ISR_Tc0
     292  ISR_Tc1
     124  ISR_Usart0
     100  MODE_SET
     100  NorFlashAllErase
     112  NorFlashBlockErase
      84  NorFlashWrite
     400  RxTimerBuf
       4  RxTimerBufCnt
       4  RxTimerCnt
     108  SW_TIMER
    1024  TextBuf
    1024  TextBuf_2
       4  bytesReceived
       4  bytesTotal
       1  mHexSwitchAdd
       4  mTc1_Cnt
       4  mTimerDebugCnt
       4  mTimerFlag
     272  main
     104  norFlash
       1  pBuffer
      24  pString
     216  pins
       4  sLineCnt
       4  sLineCnt2
       4  sScreenSize
       4  sSw_Timer_Cnt

 
 2 614 bytes in section .bss
     8 bytes in section .data
   220 bytes in section .rodata
 2 180 bytes in section .text
 
 2 180 bytes of CODE  memory
   220 bytes of CONST memory
 2 622 bytes of DATA  memory

Errors: none
Warnings: 12
