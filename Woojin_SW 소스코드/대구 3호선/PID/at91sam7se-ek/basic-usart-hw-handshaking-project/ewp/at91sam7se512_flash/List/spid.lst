###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     06/Apr/2015  18:37:27 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91lib\memories\spi-flash\spid.c                     #
#    Command line =  "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91lib\memories\spi-flash\spid.c" -D at91sam7se512   #
#                    -D flash -D TRACE_LEVEL=4 -lC "C:\Users\jang             #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_ #
#                    flash\List\" --remarks --diag_suppress Pe826,Pe1375 -o   #
#                    "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\Obj\" --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/peripherals\" -I "C:\Users\jang         #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib/memories\" -I "C:\Users\jang                          #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib\" -I "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/components\" -I "C:\Users\jang          #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib/boards/at91sam7se-ek\" --interwork --cpu_mode arm     #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\List\spid.lst                        #
#    Object file  =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\Obj\spid.o                           #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91lib\memories\spi-flash\spid.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "spid.h"
     35          #include <board.h>
     36          
     37          //------------------------------------------------------------------------------
     38          //         Macros
     39          //------------------------------------------------------------------------------
     40          
     41          /// Write PMC register
     42          #define WRITE_PMC(pPmc, regName, value) pPmc->regName = (value)
     43          
     44          /// Write SPI register
     45          #define WRITE_SPI(pSpi, regName, value) pSpi->regName = (value)
     46          
     47          /// Read SPI registers
     48          #define READ_SPI(pSpi, regName) (pSpi->regName)
     49          
     50          //------------------------------------------------------------------------------
     51          //         Exported functions
     52          //------------------------------------------------------------------------------
     53          
     54          //------------------------------------------------------------------------------
     55          /// Initializes the Spid structure and the corresponding SPI hardware.
     56          /// Always returns 0.
     57          /// \param pSpid  Pointer to a Spid instance.
     58          /// \param pSpiHw  Associated SPI peripheral.
     59          /// \param spiId  SPI peripheral identifier.
     60          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     61          unsigned char SPID_Configure(Spid *pSpid, AT91S_SPI *pSpiHw, unsigned char spiId)
     62          {
   \                     SPID_Configure:
   \   00000000   0xE1B03000         MOVS     R3,R0
     63              // Initialize the SPI structure
     64              pSpid->pSpiHw = pSpiHw;
   \   00000004   0xE5831000         STR      R1,[R3, #+0]
     65              pSpid->spiId  = spiId;
   \   00000008   0xE5C32004         STRB     R2,[R3, #+4]
     66              pSpid->semaphore = 1;
   \   0000000C   0xE3A00001         MOV      R0,#+1
   \   00000010   0xE5C3000C         STRB     R0,[R3, #+12]
     67              pSpid->pCurrentCommand = 0;
   \   00000014   0xE3A00000         MOV      R0,#+0
   \   00000018   0xE5830008         STR      R0,[R3, #+8]
     68          
     69              // Enable the SPI clock
     70              WRITE_PMC(AT91C_BASE_PMC, PMC_PCER, (1 << pSpid->spiId));
   \   0000001C   0xE3A00001         MOV      R0,#+1
   \   00000020   0xE1D3C0D4         LDRSB    R12,[R3, #+4]
   \   00000024   0xE1B00C10         LSLS     R0,R0,R12
   \   00000028   0xE3E0C0EF         MVN      R12,#+239
   \   0000002C   0xE3CCCFC0         BIC      R12,R12,#0x300
   \   00000030   0xE58C0000         STR      R0,[R12, #+0]
     71              
     72              // Execute a software reset of the SPI twice
     73              WRITE_SPI(pSpiHw, SPI_CR, AT91C_SPI_SWRST);
   \   00000034   0xE3A00080         MOV      R0,#+128
   \   00000038   0xE5810000         STR      R0,[R1, #+0]
     74          
     75              // Configure SPI in Master Mode with No CS selected !!!
     76              WRITE_SPI(pSpiHw, SPI_MR, AT91C_SPI_MSTR | AT91C_SPI_MODFDIS | AT91C_SPI_PCS);
   \   0000003C   0xE3A00011         MOV      R0,#+17
   \   00000040   0xE3800AF0         ORR      R0,R0,#0xF0000
   \   00000044   0xE5810004         STR      R0,[R1, #+4]
     77               
     78              // Disable the PDC transfer    
     79              WRITE_SPI(pSpiHw, SPI_PTCR, AT91C_PDC_RXTDIS | AT91C_PDC_TXTDIS);
   \   00000048   0xE3A00002         MOV      R0,#+2
   \   0000004C   0xE3800F80         ORR      R0,R0,#0x200
   \   00000050   0xE5810120         STR      R0,[R1, #+288]
     80          
     81              // Enable the SPI
     82              WRITE_SPI(pSpiHw, SPI_CR, AT91C_SPI_SPIEN);
   \   00000054   0xE3A00001         MOV      R0,#+1
   \   00000058   0xE5810000         STR      R0,[R1, #+0]
     83          
     84              // Enable the SPI clock
     85              WRITE_PMC(AT91C_BASE_PMC, PMC_PCDR, (1 << pSpid->spiId));
   \   0000005C   0xE3A00001         MOV      R0,#+1
   \   00000060   0xE1D3C0D4         LDRSB    R12,[R3, #+4]
   \   00000064   0xE1B00C10         LSLS     R0,R0,R12
   \   00000068   0xE3E0C0EB         MVN      R12,#+235
   \   0000006C   0xE3CCCFC0         BIC      R12,R12,#0x300
   \   00000070   0xE58C0000         STR      R0,[R12, #+0]
     86              
     87              return 0;
   \   00000074   0xE3A00000         MOV      R0,#+0
   \   00000078   0xE12FFF1E         BX       LR               ;; return
     88          }
     89          
     90          //------------------------------------------------------------------------------
     91          /// Configures the parameters for the device corresponding to the cs.
     92          /// \param pSpid  Pointer to a Spid instance.
     93          /// \param cs  number corresponding to the SPI chip select.
     94          /// \param csr  SPI_CSR value to setup.
     95          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     96          void SPID_ConfigureCS(Spid *pSpid, unsigned char cs, unsigned int csr)
     97          {
     98              AT91S_SPI *pSpiHw = pSpid->pSpiHw;
   \                     SPID_ConfigureCS:
   \   00000000   0xE5903000         LDR      R3,[R0, #+0]
     99              WRITE_SPI(pSpiHw, SPI_CSR[cs], csr);
   \   00000004   0xE1B0C001         MOVS     R12,R1
   \   00000008   0xE21CC0FF         ANDS     R12,R12,#0xFF    ;; Zero extend
   \   0000000C   0xE1B0C10C         LSLS     R12,R12,#+2
   \   00000010   0xE09CC003         ADDS     R12,R12,R3
   \   00000014   0xE58C2030         STR      R2,[R12, #+48]
    100          }
   \   00000018   0xE12FFF1E         BX       LR               ;; return
    101              
    102          //------------------------------------------------------------------------------
    103          /// Starts a SPI master transfer. This is a non blocking function. It will
    104          /// return as soon as the transfer is started.
    105          /// Returns 0 if the transfer has been started successfully; otherwise returns
    106          /// SPID_ERROR_LOCK is the driver is in use, or SPID_ERROR if the command is not
    107          /// valid.
    108          /// \param pSpid  Pointer to a Spid instance.
    109          /// \param pCommand Pointer to the SPI command to execute.
    110          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    111          unsigned char SPID_SendCommand(Spid *pSpid, SpidCmd *pCommand)
    112          {
   \                     SPID_SendCommand:
   \   00000000   0xE92D4000         PUSH     {LR}
   \   00000004   0xE1B02000         MOVS     R2,R0
    113              AT91S_SPI *pSpiHw = pSpid->pSpiHw;
   \   00000008   0xE5923000         LDR      R3,[R2, #+0]
    114               unsigned int spiMr;
    115                   
    116               // Try to get the dataflash semaphore
    117               
    118               /*
    119               if (pSpid->semaphore == 0) {
    120              
    121                   return SPID_ERROR_LOCK;
    122              }
    123               pSpid->semaphore--;
    124              */
    125               
    126              // Enable the SPI clock
    127              WRITE_PMC(AT91C_BASE_PMC, PMC_PCER, (1 << pSpid->spiId));
   \   0000000C   0xE3A00001         MOV      R0,#+1
   \   00000010   0xE1D2E0D4         LDRSB    LR,[R2, #+4]
   \   00000014   0xE1B00E10         LSLS     R0,R0,LR
   \   00000018   0xE3E0E0EF         MVN      LR,#+239
   \   0000001C   0xE3CEEFC0         BIC      LR,LR,#0x300
   \   00000020   0xE58E0000         STR      R0,[LR, #+0]
    128              
    129              // Disable transmitter and receiver
    130              WRITE_SPI(pSpiHw, SPI_PTCR, AT91C_PDC_RXTDIS | AT91C_PDC_TXTDIS);
   \   00000024   0xE3A00002         MOV      R0,#+2
   \   00000028   0xE3800F80         ORR      R0,R0,#0x200
   \   0000002C   0xE5830120         STR      R0,[R3, #+288]
    131          
    132               // Write to the MR register
    133               spiMr = READ_SPI(pSpiHw, SPI_MR);
   \   00000030   0xE5930004         LDR      R0,[R3, #+4]
   \   00000034   0xE1B0C000         MOVS     R12,R0
    134               spiMr |= AT91C_SPI_PCS;
   \   00000038   0xE39CCAF0         ORRS     R12,R12,#0xF0000
    135               spiMr &= ~((1 << pCommand->spiCs) << 16);
   \   0000003C   0xE3A00001         MOV      R0,#+1
   \   00000040   0xE1D1E0DE         LDRSB    LR,[R1, #+14]
   \   00000044   0xE1B00E10         LSLS     R0,R0,LR
   \   00000048   0xE1F00800         MVNS     R0,R0, LSL #+16
   \   0000004C   0xE010C00C         ANDS     R12,R0,R12
    136              //WRITE_SPI(pSpiHw, SPI_MR, spiMr);
    137               WRITE_SPI(pSpiHw, SPI_MR, (AT91C_SPI_MSTR|AT91C_SPI_MODFDIS));
   \   00000050   0xE3A00011         MOV      R0,#+17
   \   00000054   0xE5830004         STR      R0,[R3, #+4]
    138               
    139              /*
    140              // Initialize the two SPI PDC buffer
    141              WRITE_SPI(pSpiHw, SPI_RPR, (int) pCommand->pCmd);
    142              WRITE_SPI(pSpiHw, SPI_RCR, pCommand->cmdSize);
    143              
    144              WRITE_SPI(pSpiHw, SPI_TPR, (int) pCommand->pCmd);
    145              WRITE_SPI(pSpiHw, SPI_TCR, pCommand->cmdSize);
    146             
    147              
    148              
    149              WRITE_SPI(pSpiHw, SPI_RNPR, (int) pCommand->pData);
    150              WRITE_SPI(pSpiHw, SPI_RNCR, pCommand->dataSize);
    151           
    152              WRITE_SPI(pSpiHw, SPI_TNPR, (int) pCommand->pData);
    153              WRITE_SPI(pSpiHw, SPI_TNCR, pCommand->dataSize);
    154          */
    155          
    156              
    157              //WRITE_SPI(pSpiHw, SPI_RPR, (int) pCommand->pCmd);
    158              //WRITE_SPI(pSpiHw, SPI_RCR, pCommand->cmdSize);
    159              
    160              WRITE_SPI(pSpiHw, SPI_TPR, (int) pCommand->pCmd);
   \   00000058   0xE5910000         LDR      R0,[R1, #+0]
   \   0000005C   0xE5830108         STR      R0,[R3, #+264]
    161              WRITE_SPI(pSpiHw, SPI_TCR, pCommand->cmdSize);
   \   00000060   0xE5D10004         LDRB     R0,[R1, #+4]
   \   00000064   0xE583010C         STR      R0,[R3, #+268]
    162             
    163              
    164              
    165              //WRITE_SPI(pSpiHw, SPI_RNPR, (int) pCommand->pData);
    166              //WRITE_SPI(pSpiHw, SPI_RNCR, pCommand->dataSize);
    167           
    168              WRITE_SPI(pSpiHw, SPI_TNPR, (int) pCommand->pData);
   \   00000068   0xE5910008         LDR      R0,[R1, #+8]
   \   0000006C   0xE5830118         STR      R0,[R3, #+280]
    169              WRITE_SPI(pSpiHw, SPI_TNCR, pCommand->dataSize);
   \   00000070   0xE1D100BC         LDRH     R0,[R1, #+12]
   \   00000074   0xE583011C         STR      R0,[R3, #+284]
    170              
    171              
    172              // Initialize the callback
    173              //pSpid->pCurrentCommand = pCommand;
    174              
    175              // Enable transmitter and receiver
    176              WRITE_SPI(pSpiHw, SPI_PTCR, AT91C_PDC_RXTEN | AT91C_PDC_TXTEN);
   \   00000078   0xE3A00001         MOV      R0,#+1
   \   0000007C   0xE3800F40         ORR      R0,R0,#0x100
   \   00000080   0xE5830120         STR      R0,[R3, #+288]
    177          
    178              // Enable buffer complete interrupt
    179             // WRITE_SPI(pSpiHw, SPI_IER, AT91C_SPI_RXBUFF);
    180              
    181              
    182              return 0;    
   \   00000084   0xE3A00000         MOV      R0,#+0
   \   00000088   0xE8BD4000         POP      {LR}
   \   0000008C   0xE12FFF1E         BX       LR               ;; return
    183          }
    184          
    185          //------------------------------------------------------------------------------
    186          /// The SPI_Handler must be called by the SPI Interrupt Service Routine with the
    187          /// corresponding Spi instance.
    188          /// The SPI_Handler will unlock the Spi semaphore and invoke the upper application 
    189          /// callback.
    190          /// \param pSpid  Pointer to a Spid instance.
    191          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    192          void SPID_Handler(Spid *pSpid)
    193          {
   \                     SPID_Handler:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE24DD008         SUB      SP,SP,#+8
   \   00000008   0xE1B04000         MOVS     R4,R0
    194              SpidCmd *pSpidCmd = pSpid->pCurrentCommand;
   \   0000000C   0xE5945008         LDR      R5,[R4, #+8]
    195              AT91S_SPI *pSpiHw = pSpid->pSpiHw;
   \   00000010   0xE5946000         LDR      R6,[R4, #+0]
    196              volatile unsigned int spiSr;
    197              
    198              // Read the status register
    199              spiSr = READ_SPI(pSpiHw, SPI_SR);    
   \   00000014   0xE5960010         LDR      R0,[R6, #+16]
   \   00000018   0xE58D0000         STR      R0,[SP, #+0]
    200              if (spiSr & AT91C_SPI_RXBUFF) {
   \   0000001C   0xE59D0000         LDR      R0,[SP, #+0]
   \   00000020   0xE3100040         TST      R0,#0x40
   \   00000024   0x0A000017         BEQ      ??SPID_Handler_0
    201          
    202                  // Disable transmitter and receiver
    203                  WRITE_SPI(pSpiHw, SPI_PTCR, AT91C_PDC_RXTDIS | AT91C_PDC_TXTDIS);
   \   00000028   0xE3A00002         MOV      R0,#+2
   \   0000002C   0xE3800F80         ORR      R0,R0,#0x200
   \   00000030   0xE5860120         STR      R0,[R6, #+288]
    204          
    205                  // Disable the SPI clock
    206                  WRITE_PMC(AT91C_BASE_PMC, PMC_PCDR, (1 << pSpid->spiId));
   \   00000034   0xE3A00001         MOV      R0,#+1
   \   00000038   0xE1D410D4         LDRSB    R1,[R4, #+4]
   \   0000003C   0xE1B00110         LSLS     R0,R0,R1
   \   00000040   0xE3E010EB         MVN      R1,#+235
   \   00000044   0xE3C11FC0         BIC      R1,R1,#0x300
   \   00000048   0xE5810000         STR      R0,[R1, #+0]
    207          
    208                  // Disable buffer complete interrupt
    209                  WRITE_SPI(pSpiHw, SPI_IDR, AT91C_SPI_RXBUFF);
   \   0000004C   0xE3A00040         MOV      R0,#+64
   \   00000050   0xE5860018         STR      R0,[R6, #+24]
    210          
    211                  // Release the dataflash semaphore
    212                  pSpid->semaphore++;
   \   00000054   0xE5D4000C         LDRB     R0,[R4, #+12]
   \   00000058   0xE2900001         ADDS     R0,R0,#+1
   \   0000005C   0xE5C4000C         STRB     R0,[R4, #+12]
    213                      
    214                  // Invoke the callback associated with the current command
    215                  if (pSpidCmd && pSpidCmd->callback) {
   \   00000060   0xE3550000         CMP      R5,#+0
   \   00000064   0x0A000007         BEQ      ??SPID_Handler_0
   \   00000068   0xE5950010         LDR      R0,[R5, #+16]
   \   0000006C   0xE3500000         CMP      R0,#+0
   \   00000070   0x0A000004         BEQ      ??SPID_Handler_0
    216                  
    217                      pSpidCmd->callback(0, pSpidCmd->pArgument);
   \   00000074   0xE5951014         LDR      R1,[R5, #+20]
   \   00000078   0xE3A00000         MOV      R0,#+0
   \   0000007C   0xE5952010         LDR      R2,[R5, #+16]
   \   00000080   0xE1A0E00F         MOV      LR,PC
   \   00000084   0xE12FFF12         BX       R2
    218                  }
    219                      
    220                  // Nothing must be done after. A new DF operation may have been started
    221                  // in the callback function.
    222              }
    223          }
   \                     ??SPID_Handler_0:
   \   00000088   0xE8BD4073         POP      {R0,R1,R4-R6,LR}
   \   0000008C   0xE12FFF1E         BX       LR               ;; return
    224          
    225          //------------------------------------------------------------------------------
    226          /// Returns 1 if the SPI driver is currently busy executing a command; otherwise
    227          /// returns 0.
    228          /// \param pSpid  Pointer to a SPI driver instance.
    229          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    230          unsigned char SPID_IsBusy(const Spid *pSpid)
    231          {
   \                     SPID_IsBusy:
   \   00000000   0xE1B01000         MOVS     R1,R0
    232              if (pSpid->semaphore == 0) {
   \   00000004   0xE5D1000C         LDRB     R0,[R1, #+12]
   \   00000008   0xE3500000         CMP      R0,#+0
   \   0000000C   0x1A000001         BNE      ??SPID_IsBusy_0
    233          
    234                  return 1;
   \   00000010   0xE3A00001         MOV      R0,#+1
   \   00000014   0xEA000000         B        ??SPID_IsBusy_1
    235              }
    236              else {
    237          
    238                  return 0;
   \                     ??SPID_IsBusy_0:
   \   00000018   0xE3A00000         MOV      R0,#+0
   \                     ??SPID_IsBusy_1:
   \   0000001C   0xE12FFF1E         BX       LR               ;; return
    239              }
    240          }
    241          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  SPID_Configure
        0  SPID_ConfigureCS
       24  SPID_Handler
             24 -- Indirect call
        0  SPID_IsBusy
        4  SPID_SendCommand


   Section sizes:

   Bytes  Function/Label
   -----  --------------
     124  SPID_Configure
      28  SPID_ConfigureCS
     144  SPID_Handler
      32  SPID_IsBusy
     144  SPID_SendCommand

 
 472 bytes in section .text
 
 472 bytes of CODE memory

Errors: none
Warnings: none
