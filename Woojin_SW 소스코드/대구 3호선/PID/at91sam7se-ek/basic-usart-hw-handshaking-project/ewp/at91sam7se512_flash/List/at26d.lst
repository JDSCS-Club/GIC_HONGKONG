###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     06/Apr/2015  18:37:31 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91lib\memories\spi-flash\at26d.c                    #
#    Command line =  "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91lib\memories\spi-flash\at26d.c" -D at91sam7se512  #
#                    -D flash -D TRACE_LEVEL=4 -lC "C:\Users\jang             #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_ #
#                    flash\List\" --remarks --diag_suppress Pe826,Pe1375 -o   #
#                    "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\Obj\" --no_cse --no_unroll           #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/peripherals\" -I "C:\Users\jang         #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib/memories\" -I "C:\Users\jang                          #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib\" -I "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/components\" -I "C:\Users\jang          #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib/boards/at91sam7se-ek\" --interwork --cpu_mode arm     #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\List\at26d.lst                       #
#    Object file  =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\Obj\at26d.o                          #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91lib\memories\spi-flash\at26d.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "at26.h"
     35          #include "at26d.h"
     36          #include "board.h"
     37          #include <utility/math.h>
     38          #include <utility/assert.h>
     39          
     40          /*****/
     41          #include <utility/trace.h>
     42          /*****/
     43          
     44          //------------------------------------------------------------------------------
     45          //         Local functions
     46          //------------------------------------------------------------------------------
     47          
     48          //------------------------------------------------------------------------------
     49          /// Wait for transfer to finish calling the SPI driver ISR. (interrupts are disabled)
     50          /// \param pAt26  Pointer to an AT26 driver instance.
     51          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     52          static void AT26D_Wait(At26 *pAt26)
     53          {
   \                     AT26D_Wait:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     54              // Wait for transfer to finish
     55              while (AT26_IsBusy(pAt26))
   \                     ??AT26D_Wait_0:
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0x........         BL       AT26_IsBusy
   \   00000010   0xE3500000         CMP      R0,#+0
   \   00000014   0x0A000002         BEQ      ??AT26D_Wait_1
     56                  SPID_Handler(pAt26->pSpid);
   \   00000018   0xE5940000         LDR      R0,[R4, #+0]
   \   0000001C   0x........         BL       SPID_Handler
   \   00000020   0xEAFFFFF8         B        ??AT26D_Wait_0
     57          }
   \                     ??AT26D_Wait_1:
   \   00000024   0xE8BD4010         POP      {R4,LR}
   \   00000028   0xE12FFF1E         BX       LR               ;; return
     58          
     59          //------------------------------------------------------------------------------
     60          /// Reads and returns the status register of the serial flash.
     61          /// \param pAt26  Pointer to an AT26 driver instance.
     62          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     63          static unsigned char AT26D_ReadStatus(At26 *pAt26)
     64          {
   \                     AT26D_ReadStatus:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
     65              unsigned char error, status;
     66          
     67              SANITY_CHECK(pAt26);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT26D_ReadStatus_0
   \   00000014   0x........         LDR      R0,??DataTable9
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A02043         MOV      R2,#+67
   \   00000020   0x........         LDR      R1,??DataTable9_1
   \   00000024   0x........         LDR      R0,??DataTable9_2
   \   00000028   0x........         BL       printf
   \                     ??AT26D_ReadStatus_1:
   \   0000002C   0xEAFFFFFE         B        ??AT26D_ReadStatus_1
     68          
     69              // Issue a status read command
     70              error = AT26_SendCommand(pAt26, AT26_READ_STATUS, 1, &status, 1, 0, 0, 0);
   \                     ??AT26D_ReadStatus_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xE58D000C         STR      R0,[SP, #+12]
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0004         STR      R0,[SP, #+4]
   \   00000048   0xE3A00001         MOV      R0,#+1
   \   0000004C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000050   0xE28D3010         ADD      R3,SP,#+16
   \   00000054   0xE3A02001         MOV      R2,#+1
   \   00000058   0xE3A01005         MOV      R1,#+5
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       AT26_SendCommand
   \   00000064   0xE1B05000         MOVS     R5,R0
     71              ASSERT(!error, "-F- AT26_GetStatus: Failed to issue command.\n\r");
   \   00000068   0xE21550FF         ANDS     R5,R5,#0xFF      ;; Zero extend
   \   0000006C   0xE3550000         CMP      R5,#+0
   \   00000070   0x0A000004         BEQ      ??AT26D_ReadStatus_2
   \   00000074   0x........         LDR      R0,??DataTable9
   \   00000078   0x........         BL       printf
   \   0000007C   0x........         LDR      R0,??DataTable9_3
   \   00000080   0x........         BL       printf
   \                     ??AT26D_ReadStatus_3:
   \   00000084   0xEAFFFFFE         B        ??AT26D_ReadStatus_3
     72          
     73              // Wait for transfer to finish
     74              AT26D_Wait(pAt26);
   \                     ??AT26D_ReadStatus_2:
   \   00000088   0xE1B00004         MOVS     R0,R4
   \   0000008C   0x........         BL       AT26D_Wait
     75          
     76              return status;
   \   00000090   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000094   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   00000098   0xE8BD4030         POP      {R4,R5,LR}
   \   0000009C   0xE12FFF1E         BX       LR               ;; return
     77          }
     78          
     79          //------------------------------------------------------------------------------
     80          /// Writes the given value in the status register of the serial flash device.
     81          /// \param pAt26  Pointer to an AT26 driver instance.
     82          /// \param status  Status to write.
     83          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     84          static void AT26D_WriteStatus(At26 *pAt26, unsigned char status)
     85          {
   \                     AT26D_WriteStatus:
   \   00000000   0xE92D4032         PUSH     {R1,R4,R5,LR}
   \   00000004   0xE24DD010         SUB      SP,SP,#+16
   \   00000008   0xE1B04000         MOVS     R4,R0
     86              unsigned char error;
     87          
     88              SANITY_CHECK(pAt26);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT26D_WriteStatus_0
   \   00000014   0x........         LDR      R0,??DataTable9
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A02058         MOV      R2,#+88
   \   00000020   0x........         LDR      R1,??DataTable9_1
   \   00000024   0x........         LDR      R0,??DataTable9_2
   \   00000028   0x........         BL       printf
   \                     ??AT26D_WriteStatus_1:
   \   0000002C   0xEAFFFFFE         B        ??AT26D_WriteStatus_1
     89          
     90              // Issue a write status command
     91              error = AT26_SendCommand(pAt26, AT26_WRITE_STATUS, 1, &status, 1, 0, 0, 0);
   \                     ??AT26D_WriteStatus_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xE58D000C         STR      R0,[SP, #+12]
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0004         STR      R0,[SP, #+4]
   \   00000048   0xE3A00001         MOV      R0,#+1
   \   0000004C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000050   0xE28D3010         ADD      R3,SP,#+16
   \   00000054   0xE3A02001         MOV      R2,#+1
   \   00000058   0xE3A01001         MOV      R1,#+1
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       AT26_SendCommand
   \   00000064   0xE1B05000         MOVS     R5,R0
     92              ASSERT(!error, "-F- AT26_WriteStatus: Failed to issue command.\n\r");
   \   00000068   0xE21550FF         ANDS     R5,R5,#0xFF      ;; Zero extend
   \   0000006C   0xE3550000         CMP      R5,#+0
   \   00000070   0x0A000004         BEQ      ??AT26D_WriteStatus_2
   \   00000074   0x........         LDR      R0,??DataTable9
   \   00000078   0x........         BL       printf
   \   0000007C   0x........         LDR      R0,??DataTable9_4
   \   00000080   0x........         BL       printf
   \                     ??AT26D_WriteStatus_3:
   \   00000084   0xEAFFFFFE         B        ??AT26D_WriteStatus_3
     93              // Wait for transfer to finish
     94              AT26D_Wait(pAt26);
   \                     ??AT26D_WriteStatus_2:
   \   00000088   0xE1B00004         MOVS     R0,R4
   \   0000008C   0x........         BL       AT26D_Wait
     95          }
   \   00000090   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   00000094   0xE8BD4030         POP      {R4,R5,LR}
   \   00000098   0xE12FFF1E         BX       LR               ;; return
     96          
     97          
     98          //------------------------------------------------------------------------------
     99          //         Global functions
    100          //------------------------------------------------------------------------------
    101          
    102          //------------------------------------------------------------------------------
    103          /// Waits for the serial flash device to become ready to accept new commands.
    104          /// \param pAt26  Pointer to an AT26 driver instance.
    105          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    106          void AT26D_WaitReady(At26 *pAt26)
    107          {
   \                     AT26D_WaitReady:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    108              unsigned char ready = 0;
   \   00000008   0xE3A05000         MOV      R5,#+0
    109          
    110              SANITY_CHECK(pAt26);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT26D_WaitReady_0
   \   00000014   0x........         LDR      R0,??DataTable9
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A0206E         MOV      R2,#+110
   \   00000020   0x........         LDR      R1,??DataTable9_1
   \   00000024   0x........         LDR      R0,??DataTable9_2
   \   00000028   0x........         BL       printf
   \                     ??AT26D_WaitReady_1:
   \   0000002C   0xEAFFFFFE         B        ??AT26D_WaitReady_1
    111          
    112              // Read status register and check busy bit
    113              while (!ready) {
   \                     ??AT26D_WaitReady_0:
   \   00000030   0xE21550FF         ANDS     R5,R5,#0xFF      ;; Zero extend
   \   00000034   0xE3550000         CMP      R5,#+0
   \   00000038   0x1A000005         BNE      ??AT26D_WaitReady_2
    114          
    115                  ready = ((AT26D_ReadStatus(pAt26) & AT26_STATUS_RDYBSY) == AT26_STATUS_RDYBSY_READY);
   \   0000003C   0xE1B00004         MOVS     R0,R4
   \   00000040   0x........         BL       AT26D_ReadStatus
   \   00000044   0xE2100001         ANDS     R0,R0,#0x1
   \   00000048   0xE2300001         EORS     R0,R0,#0x1
   \   0000004C   0xE1B05000         MOVS     R5,R0
   \   00000050   0xEAFFFFF6         B        ??AT26D_WaitReady_0
    116              }
    117          }
   \                     ??AT26D_WaitReady_2:
   \   00000054   0xE8BD4031         POP      {R0,R4,R5,LR}
   \   00000058   0xE12FFF1E         BX       LR               ;; return
    118          
    119          //------------------------------------------------------------------------------
    120          /// Reads and returns the serial flash device ID.
    121          /// \param pAt26  Pointer to an AT26 driver instance.
    122          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    123          unsigned int AT26D_ReadJedecId(At26 *pAt26)
    124          {
   \                     AT26D_ReadJedecId:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
    125              unsigned char error;
    126              unsigned int id = 0;
   \   0000000C   0xE3A01000         MOV      R1,#+0
   \   00000010   0xE58D1010         STR      R1,[SP, #+16]
    127          
    128              SANITY_CHECK(pAt26);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000006         BNE      ??AT26D_ReadJedecId_0
   \   0000001C   0x........         LDR      R0,??DataTable9
   \   00000020   0x........         BL       printf
   \   00000024   0xE3A02080         MOV      R2,#+128
   \   00000028   0x........         LDR      R1,??DataTable9_1
   \   0000002C   0x........         LDR      R0,??DataTable9_2
   \   00000030   0x........         BL       printf
   \                     ??AT26D_ReadJedecId_1:
   \   00000034   0xEAFFFFFE         B        ??AT26D_ReadJedecId_1
    129           
    130              // Issue a read ID command
    131              error = AT26_SendCommand(pAt26, AT26_READ_JEDEC_ID, 1,
    132                                       (unsigned char *) &id, 3, 0, 0, 0);
   \                     ??AT26D_ReadJedecId_0:
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D000C         STR      R0,[SP, #+12]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0008         STR      R0,[SP, #+8]
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xE58D0004         STR      R0,[SP, #+4]
   \   00000050   0xE3A00003         MOV      R0,#+3
   \   00000054   0xE58D0000         STR      R0,[SP, #+0]
   \   00000058   0xE28D3010         ADD      R3,SP,#+16
   \   0000005C   0xE3A02001         MOV      R2,#+1
   \   00000060   0xE3A0109F         MOV      R1,#+159
   \   00000064   0xE1B00004         MOVS     R0,R4
   \   00000068   0x........         BL       AT26_SendCommand
   \   0000006C   0xE1B05000         MOVS     R5,R0
    133              ASSERT(!error, "-F- AT26_GetJedecId: Could not issue command.\n\r");
   \   00000070   0xE21550FF         ANDS     R5,R5,#0xFF      ;; Zero extend
   \   00000074   0xE3550000         CMP      R5,#+0
   \   00000078   0x0A000004         BEQ      ??AT26D_ReadJedecId_2
   \   0000007C   0x........         LDR      R0,??DataTable9
   \   00000080   0x........         BL       printf
   \   00000084   0x........         LDR      R0,??DataTable9_5
   \   00000088   0x........         BL       printf
   \                     ??AT26D_ReadJedecId_3:
   \   0000008C   0xEAFFFFFE         B        ??AT26D_ReadJedecId_3
    134          
    135              // Wait for transfer to finish
    136              AT26D_Wait(pAt26);
   \                     ??AT26D_ReadJedecId_2:
   \   00000090   0xE1B00004         MOVS     R0,R4
   \   00000094   0x........         BL       AT26D_Wait
    137          
    138              return id;
   \   00000098   0xE59D0010         LDR      R0,[SP, #+16]
   \   0000009C   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000A0   0xE8BD4030         POP      {R4,R5,LR}
   \   000000A4   0xE12FFF1E         BX       LR               ;; return
    139          }
    140          
    141          //------------------------------------------------------------------------------
    142          /// Enables critical writes operation on a serial flash device, such as sector
    143          /// protection, status register, etc.
    144          /// \para pAt26  Pointer to an AT26 driver instance.
    145          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    146          void AT26D_EnableWrite(At26 *pAt26)
    147          {
   \                     AT26D_EnableWrite:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
    148              unsigned char error;
    149          
    150              SANITY_CHECK(pAt26);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT26D_EnableWrite_0
   \   00000014   0x........         LDR      R0,??DataTable9
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A02096         MOV      R2,#+150
   \   00000020   0x........         LDR      R1,??DataTable9_1
   \   00000024   0x........         LDR      R0,??DataTable9_2
   \   00000028   0x........         BL       printf
   \                     ??AT26D_EnableWrite_1:
   \   0000002C   0xEAFFFFFE         B        ??AT26D_EnableWrite_1
    151          
    152              // Issue a write enable command
    153              error = AT26_SendCommand(pAt26, AT26_WRITE_ENABLE, 1, 0, 0, 0, 0, 0);
   \                     ??AT26D_EnableWrite_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xE58D000C         STR      R0,[SP, #+12]
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0004         STR      R0,[SP, #+4]
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000050   0xE3A03000         MOV      R3,#+0
   \   00000054   0xE3A02001         MOV      R2,#+1
   \   00000058   0xE3A01006         MOV      R1,#+6
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       AT26_SendCommand
   \   00000064   0xE1B05000         MOVS     R5,R0
    154              ASSERT(!error, "-F- AT26_EnableWrite: Could not issue command.\n\r");
   \   00000068   0xE21550FF         ANDS     R5,R5,#0xFF      ;; Zero extend
   \   0000006C   0xE3550000         CMP      R5,#+0
   \   00000070   0x0A000004         BEQ      ??AT26D_EnableWrite_2
   \   00000074   0x........         LDR      R0,??DataTable9
   \   00000078   0x........         BL       printf
   \   0000007C   0x........         LDR      R0,??DataTable9_6
   \   00000080   0x........         BL       printf
   \                     ??AT26D_EnableWrite_3:
   \   00000084   0xEAFFFFFE         B        ??AT26D_EnableWrite_3
    155          
    156              // Wait for transfer to finish
    157              AT26D_Wait(pAt26);
   \                     ??AT26D_EnableWrite_2:
   \   00000088   0xE1B00004         MOVS     R0,R4
   \   0000008C   0x........         BL       AT26D_Wait
    158          }
   \   00000090   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   00000094   0xE8BD4030         POP      {R4,R5,LR}
   \   00000098   0xE12FFF1E         BX       LR               ;; return
    159          
    160          //------------------------------------------------------------------------------
    161          /// Unprotects the contents of the serial flash device.
    162          /// Returns 0 if the device has been unprotected; otherwise returns
    163          /// SF_PROTECTED.
    164          /// \param pAt26  Pointer to an AT26 driver instance.
    165          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    166          unsigned char AT26D_Unprotect(At26 *pAt26)
    167          {
   \                     AT26D_Unprotect:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    168              unsigned char status;
    169          
    170              SANITY_CHECK(pAt26);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000006         BNE      ??AT26D_Unprotect_0
   \   00000010   0x........         LDR      R0,??DataTable9
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A020AA         MOV      R2,#+170
   \   0000001C   0x........         LDR      R1,??DataTable9_1
   \   00000020   0x........         LDR      R0,??DataTable9_2
   \   00000024   0x........         BL       printf
   \                     ??AT26D_Unprotect_1:
   \   00000028   0xEAFFFFFE         B        ??AT26D_Unprotect_1
    171          
    172              // Get the status register value to check the current protection
    173              status = AT26D_ReadStatus(pAt26);
   \                     ??AT26D_Unprotect_0:
   \   0000002C   0xE1B00004         MOVS     R0,R4
   \   00000030   0x........         BL       AT26D_ReadStatus
   \   00000034   0xE1B05000         MOVS     R5,R0
    174              if ((status & AT26_STATUS_SWP) == AT26_STATUS_SWP_PROTNONE) {
   \   00000038   0xE315000C         TST      R5,#0xC
   \   0000003C   0x1A000001         BNE      ??AT26D_Unprotect_2
    175          
    176                  // Protection already disabled
    177                  return 0;
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xEA000015         B        ??AT26D_Unprotect_3
    178              }
    179              
    180              // Check if sector protection registers are locked
    181              if ((status & AT26_STATUS_SPRL) == AT26_STATUS_SPRL_LOCKED) {
   \                     ??AT26D_Unprotect_2:
   \   00000048   0xE1B00005         MOVS     R0,R5
   \   0000004C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000050   0xE3100080         TST      R0,#0x80
   \   00000054   0x0A000004         BEQ      ??AT26D_Unprotect_4
    182          
    183                  // Unprotect sector protection registers by writing the status reg.
    184                  AT26D_EnableWrite(pAt26);
   \   00000058   0xE1B00004         MOVS     R0,R4
   \   0000005C   0x........         BL       AT26D_EnableWrite
    185                  AT26D_WriteStatus(pAt26, 0);
   \   00000060   0xE3A01000         MOV      R1,#+0
   \   00000064   0xE1B00004         MOVS     R0,R4
   \   00000068   0x........         BL       AT26D_WriteStatus
    186              }
    187              
    188              // Perform a global unprotect command
    189                AT26D_EnableWrite(pAt26);
   \                     ??AT26D_Unprotect_4:
   \   0000006C   0xE1B00004         MOVS     R0,R4
   \   00000070   0x........         BL       AT26D_EnableWrite
    190              AT26D_WriteStatus(pAt26, 0);
   \   00000074   0xE3A01000         MOV      R1,#+0
   \   00000078   0xE1B00004         MOVS     R0,R4
   \   0000007C   0x........         BL       AT26D_WriteStatus
    191              
    192              // Check the new status
    193              status = AT26D_ReadStatus(pAt26);
   \   00000080   0xE1B00004         MOVS     R0,R4
   \   00000084   0x........         BL       AT26D_ReadStatus
   \   00000088   0xE1B05000         MOVS     R5,R0
    194              if ((status & (AT26_STATUS_SPRL | AT26_STATUS_SWP)) != 0) {
   \   0000008C   0xE315008C         TST      R5,#0x8C
   \   00000090   0x0A000001         BEQ      ??AT26D_Unprotect_5
    195          
    196                  return AT26_ERROR_PROTECTED;
   \   00000094   0xE3A00001         MOV      R0,#+1
   \   00000098   0xEA000000         B        ??AT26D_Unprotect_3
    197              }
    198              else {
    199          
    200                  return 0;
   \                     ??AT26D_Unprotect_5:
   \   0000009C   0xE3A00000         MOV      R0,#+0
   \                     ??AT26D_Unprotect_3:
   \   000000A0   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   000000A4   0xE12FFF1E         BX       LR               ;; return
    201              }
    202          }
    203          
    204          //------------------------------------------------------------------------------
    205          /// Erases all the content of the memory chip.
    206          /// \param pAt26  Pointer to an AT26 driver instance.
    207          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    208          unsigned char AT26D_EraseChip(At26 *pAt26)
    209          {
   \                     AT26D_EraseChip:
   \   00000000   0xE92D407F         PUSH     {R0-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    210              unsigned char status;
    211              unsigned char error;
    212          
    213              SANITY_CHECK(pAt26);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000006         BNE      ??AT26D_EraseChip_0
   \   00000010   0x........         LDR      R0,??DataTable9
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A020D5         MOV      R2,#+213
   \   0000001C   0x........         LDR      R1,??DataTable9_1
   \   00000020   0x........         LDR      R0,??DataTable9_2
   \   00000024   0x........         BL       printf
   \                     ??AT26D_EraseChip_1:
   \   00000028   0xEAFFFFFE         B        ??AT26D_EraseChip_1
    214          
    215              // Check that the flash is unprotected
    216              status = AT26D_ReadStatus(pAt26);
   \                     ??AT26D_EraseChip_0:
   \   0000002C   0xE1B00004         MOVS     R0,R4
   \   00000030   0x........         BL       AT26D_ReadStatus
   \   00000034   0xE1B05000         MOVS     R5,R0
    217              if ((status & AT26_STATUS_SWP) != AT26_STATUS_SWP_PROTNONE) {
   \   00000038   0xE315000C         TST      R5,#0xC
   \   0000003C   0x0A000001         BEQ      ??AT26D_EraseChip_2
    218                  return AT26_ERROR_PROTECTED;
   \   00000040   0xE3A00001         MOV      R0,#+1
   \   00000044   0xEA00001C         B        ??AT26D_EraseChip_3
    219              }
    220              
    221              // Enable critical write operation
    222                AT26D_EnableWrite(pAt26);
   \                     ??AT26D_EraseChip_2:
   \   00000048   0xE1B00004         MOVS     R0,R4
   \   0000004C   0x........         BL       AT26D_EnableWrite
    223              
    224              // Erase the chip
    225              error = AT26_SendCommand(pAt26, AT26_CHIP_ERASE_2, 1, 0, 0, 0, 0, 0);
   \   00000050   0xE3A00000         MOV      R0,#+0
   \   00000054   0xE58D000C         STR      R0,[SP, #+12]
   \   00000058   0xE3A00000         MOV      R0,#+0
   \   0000005C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000060   0xE3A00000         MOV      R0,#+0
   \   00000064   0xE58D0004         STR      R0,[SP, #+4]
   \   00000068   0xE3A00000         MOV      R0,#+0
   \   0000006C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000070   0xE3A03000         MOV      R3,#+0
   \   00000074   0xE3A02001         MOV      R2,#+1
   \   00000078   0xE3A010C7         MOV      R1,#+199
   \   0000007C   0xE1B00004         MOVS     R0,R4
   \   00000080   0x........         BL       AT26_SendCommand
   \   00000084   0xE1B06000         MOVS     R6,R0
    226              ASSERT(!error, "-F- AT26_ChipErase: Could not issue command.\n\r");
   \   00000088   0xE21660FF         ANDS     R6,R6,#0xFF      ;; Zero extend
   \   0000008C   0xE3560000         CMP      R6,#+0
   \   00000090   0x0A000004         BEQ      ??AT26D_EraseChip_4
   \   00000094   0x........         LDR      R0,??DataTable9
   \   00000098   0x........         BL       printf
   \   0000009C   0x........         LDR      R0,??DataTable9_7
   \   000000A0   0x........         BL       printf
   \                     ??AT26D_EraseChip_5:
   \   000000A4   0xEAFFFFFE         B        ??AT26D_EraseChip_5
    227              // Wait for transfer to finish
    228              AT26D_Wait(pAt26);
   \                     ??AT26D_EraseChip_4:
   \   000000A8   0xE1B00004         MOVS     R0,R4
   \   000000AC   0x........         BL       AT26D_Wait
    229              // Poll the Serial flash status register until the operation is achieved
    230              AT26D_WaitReady(pAt26);
   \   000000B0   0xE1B00004         MOVS     R0,R4
   \   000000B4   0x........         BL       AT26D_WaitReady
    231          
    232              return 0;
   \   000000B8   0xE3A00000         MOV      R0,#+0
   \                     ??AT26D_EraseChip_3:
   \   000000BC   0xE28DD010         ADD      SP,SP,#+16       ;; stack cleaning
   \   000000C0   0xE8BD4070         POP      {R4-R6,LR}
   \   000000C4   0xE12FFF1E         BX       LR               ;; return
    233          }
    234          
    235          //------------------------------------------------------------------------------
    236          /// Erases the specified 64KB block of the serial firmware dataflash.
    237          /// Returns 0 if successful; otherwise returns AT26_ERROR_PROTECTED if the
    238          /// device is protected or AT26_ERROR_BUSY if it is busy executing a command.
    239          /// \param pAt26  Pointer to an AT26 driver instance.
    240          /// \param address  Address of the block to erase.
    241          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    242          unsigned char AT26D_EraseBlock(At26 *pAt26, unsigned int address)
    243          {
   \                     AT26D_EraseBlock:
   \   00000000   0xE92D40F0         PUSH     {R4-R7,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05001         MOVS     R5,R1
    244              unsigned char status;
    245              unsigned char error;
    246          
    247              SANITY_CHECK(pAt26);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000006         BNE      ??AT26D_EraseBlock_0
   \   00000018   0x........         LDR      R0,??DataTable9
   \   0000001C   0x........         BL       printf
   \   00000020   0xE3A020F7         MOV      R2,#+247
   \   00000024   0x........         LDR      R1,??DataTable9_1
   \   00000028   0x........         LDR      R0,??DataTable9_2
   \   0000002C   0x........         BL       printf
   \                     ??AT26D_EraseBlock_1:
   \   00000030   0xEAFFFFFE         B        ??AT26D_EraseBlock_1
    248           
    249              // Check that the flash is ready and unprotected
    250              status = AT26D_ReadStatus(pAt26);
   \                     ??AT26D_EraseBlock_0:
   \   00000034   0xE1B00004         MOVS     R0,R4
   \   00000038   0x........         BL       AT26D_ReadStatus
   \   0000003C   0xE1B06000         MOVS     R6,R0
    251              if ((status & AT26_STATUS_RDYBSY) != AT26_STATUS_RDYBSY_READY) {
   \   00000040   0xE3160001         TST      R6,#0x1
   \   00000044   0x0A000003         BEQ      ??AT26D_EraseBlock_2
    252                  TRACE_ERROR("AT26D_EraseBlock : Flash busy\n\r");
   \   00000048   0x........         LDR      R0,??DataTable9_8
   \   0000004C   0x........         BL       printf
    253                  return AT26_ERROR_BUSY;
   \   00000050   0xE3A00002         MOV      R0,#+2
   \   00000054   0xEA000023         B        ??AT26D_EraseBlock_3
    254              }
    255              else if ((status & AT26_STATUS_SWP) != AT26_STATUS_SWP_PROTNONE) {
   \                     ??AT26D_EraseBlock_2:
   \   00000058   0xE316000C         TST      R6,#0xC
   \   0000005C   0x0A000003         BEQ      ??AT26D_EraseBlock_4
    256                  TRACE_ERROR("AT26D_EraseBlock : Flash protected\n\r");
   \   00000060   0x........         LDR      R0,??DataTable9_9
   \   00000064   0x........         BL       printf
    257                  return AT26_ERROR_PROTECTED;
   \   00000068   0xE3A00001         MOV      R0,#+1
   \   0000006C   0xEA00001D         B        ??AT26D_EraseBlock_3
    258              }
    259          
    260              // Enable critical write operation
    261                AT26D_EnableWrite(pAt26);
   \                     ??AT26D_EraseBlock_4:
   \   00000070   0xE1B00004         MOVS     R0,R4
   \   00000074   0x........         BL       AT26D_EnableWrite
    262          
    263              // Start the block erase command
    264              error = AT26_SendCommand(pAt26, AT26_BlockEraseCmd(pAt26), 4, 0, 0, address, 0, 0);
   \   00000078   0xE3A00000         MOV      R0,#+0
   \   0000007C   0xE58D000C         STR      R0,[SP, #+12]
   \   00000080   0xE3A00000         MOV      R0,#+0
   \   00000084   0xE58D0008         STR      R0,[SP, #+8]
   \   00000088   0xE58D5004         STR      R5,[SP, #+4]
   \   0000008C   0xE3A00000         MOV      R0,#+0
   \   00000090   0xE58D0000         STR      R0,[SP, #+0]
   \   00000094   0xE3A03000         MOV      R3,#+0
   \   00000098   0xE3A02004         MOV      R2,#+4
   \   0000009C   0xE594001C         LDR      R0,[R4, #+28]
   \   000000A0   0xE5901014         LDR      R1,[R0, #+20]
   \   000000A4   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   000000A8   0xE1B00004         MOVS     R0,R4
   \   000000AC   0x........         BL       AT26_SendCommand
   \   000000B0   0xE1B07000         MOVS     R7,R0
    265              ASSERT(!error, "-F- AT26_EraseBlock: Could not issue command.\n\r");
   \   000000B4   0xE21770FF         ANDS     R7,R7,#0xFF      ;; Zero extend
   \   000000B8   0xE3570000         CMP      R7,#+0
   \   000000BC   0x0A000004         BEQ      ??AT26D_EraseBlock_5
   \   000000C0   0x........         LDR      R0,??DataTable9
   \   000000C4   0x........         BL       printf
   \   000000C8   0x........         LDR      R0,??DataTable9_10
   \   000000CC   0x........         BL       printf
   \                     ??AT26D_EraseBlock_6:
   \   000000D0   0xEAFFFFFE         B        ??AT26D_EraseBlock_6
    266              // Wait for transfer to finish
    267              AT26D_Wait(pAt26);
   \                     ??AT26D_EraseBlock_5:
   \   000000D4   0xE1B00004         MOVS     R0,R4
   \   000000D8   0x........         BL       AT26D_Wait
    268              // Poll the Serial flash status register until the operation is achieved
    269              AT26D_WaitReady(pAt26);
   \   000000DC   0xE1B00004         MOVS     R0,R4
   \   000000E0   0x........         BL       AT26D_WaitReady
    270          
    271              return 0;
   \   000000E4   0xE3A00000         MOV      R0,#+0
   \                     ??AT26D_EraseBlock_3:
   \   000000E8   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000EC   0xE8BD40F0         POP      {R4-R7,LR}
   \   000000F0   0xE12FFF1E         BX       LR               ;; return
    272          }
    273          
    274          //------------------------------------------------------------------------------
    275          /// Writes data at the specified address on the serial firmware dataflash. The
    276          /// page(s) to program must have been erased prior to writing. This function
    277          /// handles page boundary crossing automatically.
    278          /// Returns 0 if successful; otherwise, returns AT26_ERROR_PROGRAM is there has
    279          /// been an error during the data programming.
    280          /// \param pAt26  Pointer to an AT26 driver instance.
    281          /// \param pData  Data buffer.
    282          /// \param size  Number of bytes in buffer.
    283          /// \param address  Write address.
    284          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    285          unsigned char AT26D_Write(
    286              At26 *pAt26,
    287              unsigned char *pData,
    288              unsigned int size,
    289              unsigned int address)
    290          {
   \                     AT26D_Write:
   \   00000000   0xE92D4FF0         PUSH     {R4-R11,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05001         MOVS     R5,R1
   \   00000010   0xE1B06002         MOVS     R6,R2
   \   00000014   0xE1B07003         MOVS     R7,R3
    291              unsigned int pageSize;
    292              unsigned int writeSize;
    293              unsigned char error;
    294              unsigned char status;
    295          
    296              SANITY_CHECK(pAt26);
   \   00000018   0xE3540000         CMP      R4,#+0
   \   0000001C   0x1A000006         BNE      ??AT26D_Write_0
   \   00000020   0x........         LDR      R0,??DataTable9
   \   00000024   0x........         BL       printf
   \   00000028   0xE3A02F4A         MOV      R2,#+296
   \   0000002C   0x........         LDR      R1,??DataTable9_1
   \   00000030   0x........         LDR      R0,??DataTable9_2
   \   00000034   0x........         BL       printf
   \                     ??AT26D_Write_1:
   \   00000038   0xEAFFFFFE         B        ??AT26D_Write_1
    297              SANITY_CHECK(pData);
   \                     ??AT26D_Write_0:
   \   0000003C   0xE3550000         CMP      R5,#+0
   \   00000040   0x1A000007         BNE      ??AT26D_Write_2
   \   00000044   0x........         LDR      R0,??DataTable9
   \   00000048   0x........         BL       printf
   \   0000004C   0xE3A02029         MOV      R2,#+41
   \   00000050   0xE3822F40         ORR      R2,R2,#0x100
   \   00000054   0x........         LDR      R1,??DataTable9_1
   \   00000058   0x........         LDR      R0,??DataTable9_2
   \   0000005C   0x........         BL       printf
   \                     ??AT26D_Write_3:
   \   00000060   0xEAFFFFFE         B        ??AT26D_Write_3
    298          
    299              // Retrieve device page size
    300              pageSize = AT26_PageSize(pAt26);
   \                     ??AT26D_Write_2:
   \   00000064   0xE594001C         LDR      R0,[R4, #+28]
   \   00000068   0xE590000C         LDR      R0,[R0, #+12]
   \   0000006C   0xE1B08000         MOVS     R8,R0
    301          
    302              // Program one page after the other
    303              while (size > 0) {
   \                     ??AT26D_Write_4:
   \   00000070   0xE3560000         CMP      R6,#+0
   \   00000074   0x0A00002D         BEQ      ??AT26D_Write_5
    304                  // Compute number of bytes to program in page
    305                  writeSize = min(size, pageSize - (address % pageSize));
   \   00000078   0xE1B00007         MOVS     R0,R7
   \   0000007C   0xE1B01008         MOVS     R1,R8
   \   00000080   0x........         BL       __aeabi_uidivmod
   \   00000084   0xE0581001         SUBS     R1,R8,R1
   \   00000088   0xE1B00006         MOVS     R0,R6
   \   0000008C   0x........         BL       min
   \   00000090   0xE1B09000         MOVS     R9,R0
    306          
    307                  // Enable critical write operation
    308                  AT26D_EnableWrite(pAt26);
   \   00000094   0xE1B00004         MOVS     R0,R4
   \   00000098   0x........         BL       AT26D_EnableWrite
    309               
    310                   // Program page
    311                    error = AT26_SendCommand(pAt26, AT26_BYTE_PAGE_PROGRAM, 4,
    312                                     pData, writeSize, address, 0, 0);
   \   0000009C   0xE3A00000         MOV      R0,#+0
   \   000000A0   0xE58D000C         STR      R0,[SP, #+12]
   \   000000A4   0xE3A00000         MOV      R0,#+0
   \   000000A8   0xE58D0008         STR      R0,[SP, #+8]
   \   000000AC   0xE58D7004         STR      R7,[SP, #+4]
   \   000000B0   0xE58D9000         STR      R9,[SP, #+0]
   \   000000B4   0xE1B03005         MOVS     R3,R5
   \   000000B8   0xE3A02004         MOV      R2,#+4
   \   000000BC   0xE3A01002         MOV      R1,#+2
   \   000000C0   0xE1B00004         MOVS     R0,R4
   \   000000C4   0x........         BL       AT26_SendCommand
   \   000000C8   0xE1B0A000         MOVS     R10,R0
    313                  ASSERT(!error, "-F- AT26_WritePage: Failed to issue command.\n\r");
   \   000000CC   0xE21AA0FF         ANDS     R10,R10,#0xFF    ;; Zero extend
   \   000000D0   0xE35A0000         CMP      R10,#+0
   \   000000D4   0x0A000004         BEQ      ??AT26D_Write_6
   \   000000D8   0x........         LDR      R0,??DataTable9
   \   000000DC   0x........         BL       printf
   \   000000E0   0x........         LDR      R0,??DataTable9_11
   \   000000E4   0x........         BL       printf
   \                     ??AT26D_Write_7:
   \   000000E8   0xEAFFFFFE         B        ??AT26D_Write_7
    314                  // Wait for transfer to finish
    315                  AT26D_Wait(pAt26);
   \                     ??AT26D_Write_6:
   \   000000EC   0xE1B00004         MOVS     R0,R4
   \   000000F0   0x........         BL       AT26D_Wait
    316                  // Poll the Serial flash status register until the operation is achieved
    317                  AT26D_WaitReady(pAt26);
   \   000000F4   0xE1B00004         MOVS     R0,R4
   \   000000F8   0x........         BL       AT26D_WaitReady
    318          
    319                  // Make sure that write was without error
    320                  status = AT26D_ReadStatus(pAt26);
   \   000000FC   0xE1B00004         MOVS     R0,R4
   \   00000100   0x........         BL       AT26D_ReadStatus
   \   00000104   0xE1B0B000         MOVS     R11,R0
    321                  if ((status & AT26_STATUS_EPE) == AT26_STATUS_EPE_ERROR) {
   \   00000108   0xE1B0000B         MOVS     R0,R11
   \   0000010C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000110   0xE3100020         TST      R0,#0x20
   \   00000114   0x0A000001         BEQ      ??AT26D_Write_8
    322          
    323                      return AT26_ERROR_PROGRAM;
   \   00000118   0xE3A00003         MOV      R0,#+3
   \   0000011C   0xEA000004         B        ??AT26D_Write_9
    324                  }
    325                  pData += writeSize;
   \                     ??AT26D_Write_8:
   \   00000120   0xE0995005         ADDS     R5,R9,R5
    326                  size -= writeSize;
   \   00000124   0xE0566009         SUBS     R6,R6,R9
    327                  address += writeSize;
   \   00000128   0xE0997007         ADDS     R7,R9,R7
   \   0000012C   0xEAFFFFCF         B        ??AT26D_Write_4
    328              }
    329          
    330              return 0;
   \                     ??AT26D_Write_5:
   \   00000130   0xE3A00000         MOV      R0,#+0
   \                     ??AT26D_Write_9:
   \   00000134   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   00000138   0xE8BD4FF0         POP      {R4-R11,LR}
   \   0000013C   0xE12FFF1E         BX       LR               ;; return
    331          }
    332          
    333          //------------------------------------------------------------------------------
    334          /// Reads data from the specified address on the serial flash.
    335          /// \param pAt26  Pointer to an AT26 driver instance.
    336          /// \param pData  Data buffer.
    337          /// \param size  Number of bytes to read.
    338          /// \param address  Read address.
    339          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    340          unsigned char AT26D_Read(
    341              At26 *pAt26,
    342              unsigned char *pData,
    343              unsigned int size,
    344              unsigned int address)
    345          {
   \                     AT26D_Read:
   \   00000000   0xE92D41FF         PUSH     {R0-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    346              unsigned char error;
    347              
    348               // Start a read operation
    349                error = AT26_SendCommand(pAt26, AT26_READ_ARRAY_LF, 4, pData, size, address, 0, 0);
   \   00000014   0xE3A00000         MOV      R0,#+0
   \   00000018   0xE58D000C         STR      R0,[SP, #+12]
   \   0000001C   0xE3A00000         MOV      R0,#+0
   \   00000020   0xE58D0008         STR      R0,[SP, #+8]
   \   00000024   0xE58D7004         STR      R7,[SP, #+4]
   \   00000028   0xE58D6000         STR      R6,[SP, #+0]
   \   0000002C   0xE1B03005         MOVS     R3,R5
   \   00000030   0xE3A02004         MOV      R2,#+4
   \   00000034   0xE3A01003         MOV      R1,#+3
   \   00000038   0xE1B00004         MOVS     R0,R4
   \   0000003C   0x........         BL       AT26_SendCommand
   \   00000040   0xE1B08000         MOVS     R8,R0
    350              ASSERT(!error, "-F- AT26_Read: Could not issue command.\n\r");
   \   00000044   0xE21880FF         ANDS     R8,R8,#0xFF      ;; Zero extend
   \   00000048   0xE3580000         CMP      R8,#+0
   \   0000004C   0x0A000004         BEQ      ??AT26D_Read_0
   \   00000050   0x........         LDR      R0,??DataTable9
   \   00000054   0x........         BL       printf
   \   00000058   0x........         LDR      R0,??DataTable9_12
   \   0000005C   0x........         BL       printf
   \                     ??AT26D_Read_1:
   \   00000060   0xEAFFFFFE         B        ??AT26D_Read_1
    351              // Wait for transfer to finish
    352              AT26D_Wait(pAt26);
   \                     ??AT26D_Read_0:
   \   00000064   0xE1B00004         MOVS     R0,R4
   \   00000068   0x........         BL       AT26D_Wait
    353              
    354              return error;
   \   0000006C   0xE1B00008         MOVS     R0,R8
   \   00000070   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000074   0xE28DD010         ADD      SP,SP,#+16       ;; stack cleaning
   \   00000078   0xE8BD41F0         POP      {R4-R8,LR}
   \   0000007C   0xE12FFF1E         BX       LR               ;; return
    355          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     `?<Constant "-F- ASSERT: ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     `?<Constant "C:\\\\Users\\\\jang duksu\\\\D...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     `?<Constant "Sanity check failed a...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_GetStatus: F...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_WriteStatus:...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_GetJedecId: ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_EnableWrite:...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_ChipErase: C...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     `?<Constant "-E- AT26D_EraseBlock ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     `?<Constant "-E- AT26D_EraseBlock ...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_EraseBlock: ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_WritePage: F...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_Read: Could ...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- ASSERT: ">`:
   \   00000000   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sanity check failed a...">`:
   \   00000000   0x53 0x61          DC8 "Sanity check failed at %s:%d\012\015"
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x20 0x63    
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x73 0x3A    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "C:\\\\Users\\\\jang duksu\\\\D...">`:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x6A          DC8 5CH, 6AH, 61H, 6EH, 67H, 20H, 64H, 75H
   \              0x61 0x6E    
   \              0x67 0x20    
   \              0x64 0x75    
   \   00000010   0x6B 0x73          DC8 6BH, 73H, 75H, 5CH, 44H, 72H, 6FH, 70H
   \              0x75 0x5C    
   \              0x44 0x72    
   \              0x6F 0x70    
   \   00000018   0x62 0x6F          DC8 62H, 6FH, 78H, 5CH, 0C8H, 0B8H, 0BBH, 0E7H
   \              0x78 0x5C    
   \              0xC8 0xB8    
   \              0xBB 0xE7    
   \   00000020   0x5C 0x4A          DC8 5CH, 4AH, 44H, 53H, 5FH, 50H, 52H, 4FH
   \              0x44 0x53    
   \              0x5F 0x50    
   \              0x52 0x4F    
   \   00000028   0x5C 0xB1          DC8 5CH, 0B1H, 0B9H, 0B3H, 0BBH, 20H, 0C7H, 0C1H
   \              0xB9 0xB3    
   \              0xBB 0x20    
   \              0xC7 0xC1    
   \   00000030   0xB7 0xCE          DC8 0B7H, 0CEH, 0C1H, 0A7H, 0C6H, 0AEH, 5CH, 0B4H
   \              0xC1 0xA7    
   \              0xC6 0xAE    
   \              0x5C 0xB4    
   \   00000038   0xEB 0xB1          DC8 0EBH, 0B1H, 0B8H, 20H, 0B8H, 0F0H, 0B3H, 0EBH
   \              0xB8 0x20    
   \              0xB8 0xF0    
   \              0xB3 0xEB    
   \   00000040   0xB7 0xB9          DC8 0B7H, 0B9H, 0C0H, 0CFH, 5CH, 0C7H, 0C1H, 0B7H
   \              0xC0 0xCF    
   \              0x5C 0xC7    
   \              0xC1 0xB7    
   \   00000048   0xCE 0xB1          DC8 0CEH, 0B1H, 0D7H, 0B7H, 0A5H, 5CH, 41H, 52H
   \              0xD7 0xB7    
   \              0xA5 0x5C    
   \              0x41 0x52    
   \   00000050   0x4D 0x5F          DC8 4DH, 5FH, 41H, 54H, 39H, 31H, 73H, 61H
   \              0x41 0x54    
   \              0x39 0x31    
   \              0x73 0x61    
   \   00000058   0x6D 0x37          DC8 6DH, 37H, 73H, 65H, 35H, 31H, 32H, 5FH
   \              0x73 0x65    
   \              0x35 0x31    
   \              0x32 0x5F    
   \   00000060   0x44 0x61          DC8 44H, 61H, 67H, 75H, 5FH, 4CH, 45H, 44H
   \              0x67 0x75    
   \              0x5F 0x4C    
   \              0x45 0x44    
   \   00000068   0x5C 0x61          DC8 5CH, 61H, 74H, 39H, 31H, 6CH, 69H, 62H
   \              0x74 0x39    
   \              0x31 0x6C    
   \              0x69 0x62    
   \   00000070   0x5C 0x6D          DC8 5CH, 6DH, 65H, 6DH, 6FH, 72H, 69H, 65H
   \              0x65 0x6D    
   \              0x6F 0x72    
   \              0x69 0x65    
   \   00000078   0x73 0x5C          DC8 73H, 5CH, 73H, 70H, 69H, 2DH, 66H, 6CH
   \              0x73 0x70    
   \              0x69 0x2D    
   \              0x66 0x6C    
   \   00000080   0x61 0x73          DC8 61H, 73H, 68H, 5CH, 61H, 74H, 32H, 36H
   \              0x68 0x5C    
   \              0x61 0x74    
   \              0x32 0x36    
   \   00000088   0x64 0x2E          DC8 64H, 2EH, 63H, 0
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_GetStatus: F...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_GetStatus: Failed to issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x47    
   \              0x65 0x74    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_WriteStatus:...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_WriteStatus: Failed to issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_GetJedecId: ...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_GetJedecId: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x47    
   \              0x65 0x74    
   \              0x4A 0x65    
   \              0x64 0x65    
   \              0x63 0x49    
   \              0x64 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_EnableWrite:...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_EnableWrite: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x45    
   \              0x6E 0x61    
   \              0x62 0x6C    
   \              0x65 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x3A 0x20    
   \              0x43 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_ChipErase: C...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_ChipErase: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x43    
   \              0x68 0x69    
   \              0x70 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x3A 0x20    
   \              0x43 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- AT26D_EraseBlock ...">`:
   \   00000000   0x2D 0x45          DC8 "-E- AT26D_EraseBlock : Flash busy\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x44 0x5F    
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x42    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x3A    
   \              0x20 0x46    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x62    
   \              0x75 0x73    
   \              0x79 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- AT26D_EraseBlock ...">_1`:
   \   00000000   0x2D 0x45          DC8 "-E- AT26D_EraseBlock : Flash protected\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x44 0x5F    
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x42    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x3A    
   \              0x20 0x46    
   \              0x6C 0x61    
   \              0x73 0x68    
   \              0x20 0x70    
   \              0x72 0x6F    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_EraseBlock: ...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_EraseBlock: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_WritePage: F...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_WritePage: Failed to issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x50 0x61    
   \              0x67 0x65    
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_Read: Could ...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_Read: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x52    
   \              0x65 0x61    
   \              0x64 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       32  AT26D_EnableWrite
             32 -> AT26D_Wait
             32 -> AT26_SendCommand
             32 -> printf
       40  AT26D_EraseBlock
             40 -> AT26D_EnableWrite
             40 -> AT26D_ReadStatus
             40 -> AT26D_Wait
             40 -> AT26D_WaitReady
             40 -> AT26_SendCommand
             40 -> printf
       32  AT26D_EraseChip
             32 -> AT26D_EnableWrite
             32 -> AT26D_ReadStatus
             32 -> AT26D_Wait
             32 -> AT26D_WaitReady
             32 -> AT26_SendCommand
             32 -> printf
       40  AT26D_Read
             40 -> AT26D_Wait
             40 -> AT26_SendCommand
             40 -> printf
       32  AT26D_ReadJedecId
             32 -> AT26D_Wait
             32 -> AT26_SendCommand
             32 -> printf
       32  AT26D_ReadStatus
             32 -> AT26D_Wait
             32 -> AT26_SendCommand
             32 -> printf
       16  AT26D_Unprotect
             16 -> AT26D_EnableWrite
             16 -> AT26D_ReadStatus
             16 -> AT26D_WriteStatus
             16 -> printf
        8  AT26D_Wait
              8 -> AT26_IsBusy
              8 -> SPID_Handler
       16  AT26D_WaitReady
             16 -> AT26D_ReadStatus
             16 -> printf
       56  AT26D_Write
             56 -> AT26D_EnableWrite
             56 -> AT26D_ReadStatus
             56 -> AT26D_Wait
             56 -> AT26D_WaitReady
             56 -> AT26_SendCommand
             56 -> __aeabi_uidivmod
             56 -> min
             56 -> printf
       32  AT26D_WriteStatus
             32 -> AT26D_Wait
             32 -> AT26_SendCommand
             32 -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      36  ?<Constant "-E- AT26D_EraseBlock ...">
      44  ?<Constant "-E- AT26D_EraseBlock ...">_1
      16  ?<Constant "-F- ASSERT: ">
      48  ?<Constant "-F- AT26_ChipErase: C...">
      52  ?<Constant "-F- AT26_EnableWrite:...">
      48  ?<Constant "-F- AT26_EraseBlock: ...">
      48  ?<Constant "-F- AT26_GetJedecId: ...">
      48  ?<Constant "-F- AT26_GetStatus: F...">
      44  ?<Constant "-F- AT26_Read: Could ...">
      48  ?<Constant "-F- AT26_WritePage: F...">
      52  ?<Constant "-F- AT26_WriteStatus:...">
     140  ?<Constant "C:\\Users\\jang duksu\\D...">
      32  ?<Constant "Sanity check failed a...">
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     156  AT26D_EnableWrite
     244  AT26D_EraseBlock
     200  AT26D_EraseChip
     128  AT26D_Read
     168  AT26D_ReadJedecId
     160  AT26D_ReadStatus
     168  AT26D_Unprotect
      44  AT26D_Wait
      92  AT26D_WaitReady
     320  AT26D_Write
     156  AT26D_WriteStatus

 
   656 bytes in section .rodata
 1 888 bytes in section .text
 
 1 888 bytes of CODE  memory
   656 bytes of CONST memory

Errors: none
Warnings: none
