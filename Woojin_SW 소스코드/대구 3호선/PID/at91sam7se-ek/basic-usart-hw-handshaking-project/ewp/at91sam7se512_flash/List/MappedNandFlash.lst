###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     06/Apr/2015  18:37:30 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91lib\memories\nandflash\MappedNandFlash.c          #
#    Command line =  "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91lib\memories\nandflash\MappedNandFlash.c" -D      #
#                    at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC              #
#                    "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\List\" --remarks --diag_suppress     #
#                    Pe826,Pe1375 -o "C:\Users\jang                           #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_ #
#                    flash\Obj\" --no_cse --no_unroll --no_inline             #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/peripherals\" -I "C:\Users\jang         #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib/memories\" -I "C:\Users\jang                          #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib\" -I "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/components\" -I "C:\Users\jang          #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib/boards/at91sam7se-ek\" --interwork --cpu_mode arm     #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\List\MappedNandFlash.lst             #
#    Object file  =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\Obj\MappedNandFlash.o                #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91lib\memories\nandflash\MappedNandFlash.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "MappedNandFlash.h"
     35          #include <utility/trace.h>
     36          #include <utility/assert.h>
     37          #include <utility/math.h>
     38          
     39          #include <string.h>

   \                                 In section .text, align 4
   \   __intrinsic __nounwind __interwork __softfp void *memcpy(void *, void const *, size_t)
   \                     memcpy:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B02006         MOVS     R2,R6
   \   00000014   0xE1B01005         MOVS     R1,R5
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       __aeabi_memcpy
   \   00000020   0xE1B00004         MOVS     R0,R4
   \   00000024   0xE8BD4070         POP      {R4-R6,LR}
   \   00000028   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .text, align 4
   \   __intrinsic __nounwind __interwork __softfp void *memset(void *, int, size_t)
   \                     memset:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B02005         MOVS     R2,R5
   \   00000014   0xE1B01006         MOVS     R1,R6
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       __aeabi_memset
   \   00000020   0xE1B00004         MOVS     R0,R4
   \   00000024   0xE8BD4070         POP      {R4-R6,LR}
   \   00000028   0xE12FFF1E         BX       LR               ;; return
     40          
     41          //------------------------------------------------------------------------------
     42          //         Internal definitions
     43          //------------------------------------------------------------------------------
     44          
     45          /// Casts
     46          #define MANAGED(mapped) ((struct ManagedNandFlash *) mapped)
     47          #define ECC(mapped)     ((struct EccNandFlash *) mapped)
     48          #define RAW(mapped)     ((struct RawNandFlash *) mapped)
     49          #define MODEL(mapped)   ((struct NandFlashModel *) mapped)
     50          
     51          /// Logical block mapping pattern
     52          #define PATTERN(i)      ((i << 1) & 0x73)
     53          
     54          //------------------------------------------------------------------------------
     55          //         Internal functions
     56          //------------------------------------------------------------------------------
     57          
     58          //------------------------------------------------------------------------------
     59          /// Scans a mapped nandflash to find an existing logical block mapping. If a
     60          /// block contains the mapping, its index is stored in the provided variable (if
     61          /// pointer is not 0).
     62          /// Returns 0 if mapping has been found; otherwise returns
     63          /// NandCommon_ERROR_NOMAPPING if no mapping exists, or another
     64          /// NandCommon_ERROR_xxx code.
     65          /// \param mapped  Pointer to a MappedNandFlash instance.
     66          /// \param logicalMappingBlock  Pointer to a variable for storing the block
     67          ///                             number.
     68          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     69          static unsigned char FindLogicalMappingBlock(
     70              const struct MappedNandFlash *mapped,
     71              signed short *logicalMappingBlock)
     72          {
   \                     FindLogicalMappingBlock:
   \   00000000   0xE92D4FF0         PUSH     {R4-R11,LR}
   \   00000004   0xE24DD004         SUB      SP,SP,#+4
   \   00000008   0xE24DDE80         SUB      SP,SP,#+2048
   \   0000000C   0xE1B04000         MOVS     R4,R0
   \   00000010   0xE1B05001         MOVS     R5,R1
     73              unsigned short block;
     74              unsigned char found;
     75              unsigned short numBlocks = ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped));
   \   00000014   0xE1B00004         MOVS     R0,R4
   \   00000018   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   0000001C   0xE1B08000         MOVS     R8,R0
     76              unsigned short pageDataSize = NandFlashModel_GetPageDataSize(MODEL(mapped));
   \   00000020   0xE1B00004         MOVS     R0,R4
   \   00000024   0x........         BL       NandFlashModel_GetPageDataSize
   \   00000028   0xE1B09000         MOVS     R9,R0
     77              unsigned char error;
     78              unsigned char data[NandCommon_MAXPAGEDATASIZE];
     79              unsigned int i;
     80              
     81              TRACE_INFO("FindLogicalMappingBlock()~%d\n\r", numBlocks);
   \   0000002C   0xE1B01008         MOVS     R1,R8
   \   00000030   0xE1A01801         LSL      R1,R1,#+16
   \   00000034   0xE1B01821         LSRS     R1,R1,#+16
   \   00000038   0x........         LDR      R0,??DataTable9
   \   0000003C   0x........         BL       printf
     82          
     83              // Search each LIVE block
     84              found = 0;
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE1B07000         MOVS     R7,R0
     85              block = 0;
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xE1B06000         MOVS     R6,R0
     86              while (!found && (block < numBlocks)) {
   \                     ??FindLogicalMappingBlock_0:
   \   00000050   0xE21770FF         ANDS     R7,R7,#0xFF      ;; Zero extend
   \   00000054   0xE3570000         CMP      R7,#+0
   \   00000058   0x1A000051         BNE      ??FindLogicalMappingBlock_1
   \   0000005C   0xE1A06806         LSL      R6,R6,#+16
   \   00000060   0xE1B06826         LSRS     R6,R6,#+16
   \   00000064   0xE1A08808         LSL      R8,R8,#+16
   \   00000068   0xE1B08828         LSRS     R8,R8,#+16
   \   0000006C   0xE1560008         CMP      R6,R8
   \   00000070   0x2A00004B         BCS      ??FindLogicalMappingBlock_1
     87          
     88                  // Check that block is LIVE
     89                  if (MANAGED(mapped)->blockStatuses[block].status == NandBlockStatus_LIVE) {
   \   00000074   0xE1B00006         MOVS     R0,R6
   \   00000078   0xE1A00800         LSL      R0,R0,#+16
   \   0000007C   0xE1B00820         LSRS     R0,R0,#+16
   \   00000080   0xE1B00100         LSLS     R0,R0,#+2
   \   00000084   0xE0900004         ADDS     R0,R0,R4
   \   00000088   0xE5D00030         LDRB     R0,[R0, #+48]
   \   0000008C   0xE210000F         ANDS     R0,R0,#0xF
   \   00000090   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000094   0xE350000C         CMP      R0,#+12
   \   00000098   0x1A00003F         BNE      ??FindLogicalMappingBlock_2
     90          
     91                      // Read block
     92                      TRACE_INFO("Checking LIVE block #%d\n\r", block);
   \   0000009C   0xE1B01006         MOVS     R1,R6
   \   000000A0   0xE1A01801         LSL      R1,R1,#+16
   \   000000A4   0xE1B01821         LSRS     R1,R1,#+16
   \   000000A8   0x........         LDR      R0,??DataTable9_1
   \   000000AC   0x........         BL       printf
     93                      error = ManagedNandFlash_ReadPage(MANAGED(mapped), block, 0, data, 0);
   \   000000B0   0xE3A00000         MOV      R0,#+0
   \   000000B4   0xE58D0000         STR      R0,[SP, #+0]
   \   000000B8   0xE28D3004         ADD      R3,SP,#+4
   \   000000BC   0xE3A02000         MOV      R2,#+0
   \   000000C0   0xE1B01006         MOVS     R1,R6
   \   000000C4   0xE1A01801         LSL      R1,R1,#+16
   \   000000C8   0xE1B01821         LSRS     R1,R1,#+16
   \   000000CC   0xE1B00004         MOVS     R0,R4
   \   000000D0   0x........         BL       ManagedNandFlash_ReadPage
   \   000000D4   0xE1B0A000         MOVS     R10,R0
     94                      if (!error) {
   \   000000D8   0xE21AA0FF         ANDS     R10,R10,#0xFF    ;; Zero extend
   \   000000DC   0xE35A0000         CMP      R10,#+0
   \   000000E0   0x1A000022         BNE      ??FindLogicalMappingBlock_3
     95          
     96                          // Compare data with logical mapping pattern
     97                          i = 0;
   \   000000E4   0xE3A00000         MOV      R0,#+0
   \   000000E8   0xE1B0B000         MOVS     R11,R0
     98                          found = 1;
   \   000000EC   0xE3A00001         MOV      R0,#+1
   \   000000F0   0xE1B07000         MOVS     R7,R0
     99                          while ((i < pageDataSize) && found) {
   \                     ??FindLogicalMappingBlock_4:
   \   000000F4   0xE1B00009         MOVS     R0,R9
   \   000000F8   0xE1A00800         LSL      R0,R0,#+16
   \   000000FC   0xE1B00820         LSRS     R0,R0,#+16
   \   00000100   0xE15B0000         CMP      R11,R0
   \   00000104   0x2A00000C         BCS      ??FindLogicalMappingBlock_5
   \   00000108   0xE21770FF         ANDS     R7,R7,#0xFF      ;; Zero extend
   \   0000010C   0xE3570000         CMP      R7,#+0
   \   00000110   0x0A000009         BEQ      ??FindLogicalMappingBlock_5
    100          
    101                              if (data[i] != PATTERN(i)) {
   \   00000114   0xE28D0004         ADD      R0,SP,#+4
   \   00000118   0xE7DB0000         LDRB     R0,[R11, +R0]
   \   0000011C   0xE3A01073         MOV      R1,#+115
   \   00000120   0xE011108B         ANDS     R1,R1,R11, LSL #+1
   \   00000124   0xE1500001         CMP      R0,R1
   \   00000128   0x0A000001         BEQ      ??FindLogicalMappingBlock_6
    102              
    103                                  found = 0;
   \   0000012C   0xE3A00000         MOV      R0,#+0
   \   00000130   0xE1B07000         MOVS     R7,R0
    104                              }
    105                              i++;
   \                     ??FindLogicalMappingBlock_6:
   \   00000134   0xE29BB001         ADDS     R11,R11,#+1
   \   00000138   0xEAFFFFED         B        ??FindLogicalMappingBlock_4
    106                          }
    107              
    108                          // If this is the mapping, stop looking
    109                          if (found) {
   \                     ??FindLogicalMappingBlock_5:
   \   0000013C   0xE21770FF         ANDS     R7,R7,#0xFF      ;; Zero extend
   \   00000140   0xE3570000         CMP      R7,#+0
   \   00000144   0x0A000014         BEQ      ??FindLogicalMappingBlock_2
    110              
    111                              TRACE_WARNING_WP("-I- Logical mapping in block #%d\n\r",
    112                                               block);
   \   00000148   0xE1B01006         MOVS     R1,R6
   \   0000014C   0xE1A01801         LSL      R1,R1,#+16
   \   00000150   0xE1B01821         LSRS     R1,R1,#+16
   \   00000154   0x........         LDR      R0,??DataTable9_2
   \   00000158   0x........         BL       printf
    113                              if (logicalMappingBlock) {
   \   0000015C   0xE3550000         CMP      R5,#+0
   \   00000160   0x0A000000         BEQ      ??FindLogicalMappingBlock_7
    114              
    115                                  *logicalMappingBlock = block;
   \   00000164   0xE1C560B0         STRH     R6,[R5, #+0]
    116                              }
    117                              return 0;
   \                     ??FindLogicalMappingBlock_7:
   \   00000168   0xE3A00000         MOV      R0,#+0
   \   0000016C   0xEA00000F         B        ??FindLogicalMappingBlock_8
    118                          }
    119                      }
    120                      else if (error != NandCommon_ERROR_WRONGSTATUS) {
   \                     ??FindLogicalMappingBlock_3:
   \   00000170   0xE21AA0FF         ANDS     R10,R10,#0xFF    ;; Zero extend
   \   00000174   0xE35A000A         CMP      R10,#+10
   \   00000178   0x0A000007         BEQ      ??FindLogicalMappingBlock_2
    121              
    122                          TRACE_ERROR(
    123                                    "FindLogicalMappingBlock: Failed to scan block #%d\n\r",
    124                                    block);
   \   0000017C   0xE1B01006         MOVS     R1,R6
   \   00000180   0xE1A01801         LSL      R1,R1,#+16
   \   00000184   0xE1B01821         LSRS     R1,R1,#+16
   \   00000188   0x........         LDR      R0,??DataTable9_3
   \   0000018C   0x........         BL       printf
    125                          return error;
   \   00000190   0xE1B0000A         MOVS     R0,R10
   \   00000194   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000198   0xEA000004         B        ??FindLogicalMappingBlock_8
    126                      }
    127                  }
    128          
    129                  block++;
   \                     ??FindLogicalMappingBlock_2:
   \   0000019C   0xE2966001         ADDS     R6,R6,#+1
   \   000001A0   0xEAFFFFAA         B        ??FindLogicalMappingBlock_0
    130              }
    131          
    132              TRACE_WARNING("No logical mapping found in device\n\r");
   \                     ??FindLogicalMappingBlock_1:
   \   000001A4   0x........         LDR      R0,??DataTable9_4
   \   000001A8   0x........         BL       printf
    133              return NandCommon_ERROR_NOMAPPING;
   \   000001AC   0xE3A0000B         MOV      R0,#+11
   \                     ??FindLogicalMappingBlock_8:
   \   000001B0   0xE28DD004         ADD      SP,SP,#+4        ;; stack cleaning
   \   000001B4   0xE28DDE80         ADD      SP,SP,#+2048
   \   000001B8   0xE8BD4FF0         POP      {R4-R11,LR}
   \   000001BC   0xE12FFF1E         BX       LR               ;; return
    134          }
    135          
    136          //------------------------------------------------------------------------------
    137          /// Loads the logical mapping contained in the given physical block.
    138          /// Returns 0 if successful; otherwise, returns a NandCommon_ERROR code.
    139          /// \param mapped  Pointer to a MappedNandFlash instance.
    140          /// \param physicalBlock  Physical block number.
    141          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    142          static unsigned char LoadLogicalMapping(
    143              struct MappedNandFlash *mapped,
    144              unsigned short physicalBlock)
    145          {
   \                     LoadLogicalMapping:
   \   00000000   0xE92D4FF0         PUSH     {R4-R11,LR}
   \   00000004   0xE24DD00C         SUB      SP,SP,#+12
   \   00000008   0xE24DDE80         SUB      SP,SP,#+2048
   \   0000000C   0xE1B04000         MOVS     R4,R0
   \   00000010   0xE1B05001         MOVS     R5,R1
    146              unsigned char error;
    147              unsigned char data[NandCommon_MAXPAGEDATASIZE];
    148              unsigned short pageDataSize =
    149                              NandFlashModel_GetPageDataSize(MODEL(mapped));
   \   00000014   0xE1B00004         MOVS     R0,R4
   \   00000018   0x........         BL       NandFlashModel_GetPageDataSize
   \   0000001C   0xE1CD00B8         STRH     R0,[SP, #+8]
    150              unsigned short numBlocks =
    151                              ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped));
   \   00000020   0xE1B00004         MOVS     R0,R4
   \   00000024   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000028   0xE1CD00B6         STRH     R0,[SP, #+6]
    152              unsigned int remainingSize;
    153              unsigned char *currentBuffer;
    154              unsigned short currentPage;
    155              unsigned int readSize;
    156              unsigned int i;
    157              unsigned char status;
    158              signed short logicalBlock;
    159              //signed short firstBlock, lastBlock;
    160          
    161              TRACE_INFO("LoadLogicalMapping(B#%d)\n\r", physicalBlock);
   \   0000002C   0xE1B01005         MOVS     R1,R5
   \   00000030   0xE1A01801         LSL      R1,R1,#+16
   \   00000034   0xE1B01821         LSRS     R1,R1,#+16
   \   00000038   0x........         LDR      R0,??DataTable9_5
   \   0000003C   0x........         BL       printf
    162          
    163              // Load mapping from pages #1 - #XXX of block
    164              currentBuffer = (unsigned char *) mapped->logicalMapping;
   \   00000040   0xE3A00034         MOV      R0,#+52
   \   00000044   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000048   0xE0900004         ADDS     R0,R0,R4
   \   0000004C   0xE1B07000         MOVS     R7,R0
    165              remainingSize = sizeof(mapped->logicalMapping);
   \   00000050   0xE3A00E80         MOV      R0,#+2048
   \   00000054   0xE1B06000         MOVS     R6,R0
    166              currentPage = 1;
   \   00000058   0xE3A00001         MOV      R0,#+1
   \   0000005C   0xE1B08000         MOVS     R8,R0
    167              while (remainingSize > 0) {
   \                     ??LoadLogicalMapping_0:
   \   00000060   0xE3560000         CMP      R6,#+0
   \   00000064   0x0A00001E         BEQ      ??LoadLogicalMapping_1
    168          
    169                  // Read page
    170                  readSize = min(remainingSize, pageDataSize);
   \   00000068   0xE1DD10B8         LDRH     R1,[SP, #+8]
   \   0000006C   0xE1B00006         MOVS     R0,R6
   \   00000070   0x........         BL       min
   \   00000074   0xE1B09000         MOVS     R9,R0
    171                  error = ManagedNandFlash_ReadPage(MANAGED(mapped),
    172                                                    physicalBlock,
    173                                                    currentPage,
    174                                                    data,
    175                                                    0);
   \   00000078   0xE3A00000         MOV      R0,#+0
   \   0000007C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000080   0xE28D300C         ADD      R3,SP,#+12
   \   00000084   0xE1B02008         MOVS     R2,R8
   \   00000088   0xE1A02802         LSL      R2,R2,#+16
   \   0000008C   0xE1B02822         LSRS     R2,R2,#+16
   \   00000090   0xE1B01005         MOVS     R1,R5
   \   00000094   0xE1A01801         LSL      R1,R1,#+16
   \   00000098   0xE1B01821         LSRS     R1,R1,#+16
   \   0000009C   0xE1B00004         MOVS     R0,R4
   \   000000A0   0x........         BL       ManagedNandFlash_ReadPage
   \   000000A4   0xE5CD0005         STRB     R0,[SP, #+5]
    176                  if (error) {
   \   000000A8   0xE5DD0005         LDRB     R0,[SP, #+5]
   \   000000AC   0xE3500000         CMP      R0,#+0
   \   000000B0   0x0A000003         BEQ      ??LoadLogicalMapping_2
    177          
    178                      TRACE_ERROR(
    179                                "LoadLogicalMapping: Failed to load mapping\n\r");
   \   000000B4   0x........         LDR      R0,??DataTable9_6
   \   000000B8   0x........         BL       printf
    180                      return error;
   \   000000BC   0xE5DD0005         LDRB     R0,[SP, #+5]
   \   000000C0   0xEA00005D         B        ??LoadLogicalMapping_3
    181                  }
    182          
    183                  // Copy page info
    184                  memcpy(currentBuffer, data, readSize);
   \                     ??LoadLogicalMapping_2:
   \   000000C4   0xE1B02009         MOVS     R2,R9
   \   000000C8   0xE28D100C         ADD      R1,SP,#+12
   \   000000CC   0xE1B00007         MOVS     R0,R7
   \   000000D0   0x........         BL       memcpy
    185          
    186                  currentBuffer += readSize;
   \   000000D4   0xE0997007         ADDS     R7,R9,R7
    187                  remainingSize -= readSize;
   \   000000D8   0xE0566009         SUBS     R6,R6,R9
    188                  currentPage++;
   \   000000DC   0xE2988001         ADDS     R8,R8,#+1
   \   000000E0   0xEAFFFFDE         B        ??LoadLogicalMapping_0
    189              }
    190          
    191              // Store mapping block index
    192              mapped->logicalMappingBlock = physicalBlock;
   \                     ??LoadLogicalMapping_1:
   \   000000E4   0xE3A00034         MOV      R0,#+52
   \   000000E8   0xE3800D60         ORR      R0,R0,#0x1800
   \   000000EC   0xE18050B4         STRH     R5,[R0, +R4]
    193          
    194              // Power-loss recovery
    195              for (i=0; i < numBlocks; i++) {
   \   000000F0   0xE3A00000         MOV      R0,#+0
   \   000000F4   0xE1B0A000         MOVS     R10,R0
   \                     ??LoadLogicalMapping_4:
   \   000000F8   0xE1DD00B6         LDRH     R0,[SP, #+6]
   \   000000FC   0xE15A0000         CMP      R10,R0
   \   00000100   0x2A000047         BCS      ??LoadLogicalMapping_5
    196          
    197                  // Check that this is not the logical mapping block
    198                  if (i != physicalBlock) {
   \   00000104   0xE1B00005         MOVS     R0,R5
   \   00000108   0xE1A00800         LSL      R0,R0,#+16
   \   0000010C   0xE1B00820         LSRS     R0,R0,#+16
   \   00000110   0xE15A0000         CMP      R10,R0
   \   00000114   0x0A000040         BEQ      ??LoadLogicalMapping_6
    199          
    200                      status = mapped->managed.blockStatuses[i].status;
   \   00000118   0xE1B0010A         LSLS     R0,R10,#+2
   \   0000011C   0xE0900004         ADDS     R0,R0,R4
   \   00000120   0xE5D00030         LDRB     R0,[R0, #+48]
   \   00000124   0xE210000F         ANDS     R0,R0,#0xF
   \   00000128   0xE5CD0004         STRB     R0,[SP, #+4]
    201                      logicalBlock = MappedNandFlash_PhysicalToLogical(mapped, i);
   \   0000012C   0xE1B0100A         MOVS     R1,R10
   \   00000130   0xE1A01801         LSL      R1,R1,#+16
   \   00000134   0xE1B01821         LSRS     R1,R1,#+16
   \   00000138   0xE1B00004         MOVS     R0,R4
   \   0000013C   0x........         BL       MappedNandFlash_PhysicalToLogical
   \   00000140   0xE1B0B000         MOVS     R11,R0
    202          
    203                      // Block is LIVE
    204                      if (status == NandBlockStatus_LIVE) {
   \   00000144   0xE5DD0004         LDRB     R0,[SP, #+4]
   \   00000148   0xE350000C         CMP      R0,#+12
   \   0000014C   0x1A00000D         BNE      ??LoadLogicalMapping_7
    205          
    206                          // Block is not mapped -> release it
    207                          if (logicalBlock == -1) {
   \   00000150   0xE3E00000         MVN      R0,#+0
   \   00000154   0xE1A0B80B         LSL      R11,R11,#+16
   \   00000158   0xE1B0B84B         ASRS     R11,R11,#+16
   \   0000015C   0xE15B0000         CMP      R11,R0
   \   00000160   0x1A00002D         BNE      ??LoadLogicalMapping_6
    208          
    209                              TRACE_WARNING_WP("-I- Release unmapped LIVE #%d\n\r",
    210                                               i);
                                                      ^
Remark[Pe181]: argument is incompatible with corresponding format string
          conversion
   \   00000164   0xE1B0100A         MOVS     R1,R10
   \   00000168   0x........         LDR      R0,??DataTable9_7
   \   0000016C   0x........         BL       printf
    211                              ManagedNandFlash_ReleaseBlock(MANAGED(mapped), i);
   \   00000170   0xE1B0100A         MOVS     R1,R10
   \   00000174   0xE1A01801         LSL      R1,R1,#+16
   \   00000178   0xE1B01821         LSRS     R1,R1,#+16
   \   0000017C   0xE1B00004         MOVS     R0,R4
   \   00000180   0x........         BL       ManagedNandFlash_ReleaseBlock
   \   00000184   0xEA000024         B        ??LoadLogicalMapping_6
    212                          }
    213                      }
    214                      // Block is DIRTY
    215                      else if (status == NandBlockStatus_DIRTY) {
   \                     ??LoadLogicalMapping_7:
   \   00000188   0xE5DD0004         LDRB     R0,[SP, #+4]
   \   0000018C   0xE3500008         CMP      R0,#+8
   \   00000190   0x1A000010         BNE      ??LoadLogicalMapping_8
    216          
    217                          // Block is mapped -> fake it as live
    218                          if (logicalBlock != -1) {
   \   00000194   0xE3E00000         MVN      R0,#+0
   \   00000198   0xE1A0B80B         LSL      R11,R11,#+16
   \   0000019C   0xE1B0B84B         ASRS     R11,R11,#+16
   \   000001A0   0xE15B0000         CMP      R11,R0
   \   000001A4   0x0A00001C         BEQ      ??LoadLogicalMapping_6
    219          
    220                              TRACE_WARNING_WP("-I- Mark mapped DIRTY #%d -> LIVE\n\r",
    221                                               i);
                                                      ^
Remark[Pe181]: argument is incompatible with corresponding format string
          conversion
   \   000001A8   0xE1B0100A         MOVS     R1,R10
   \   000001AC   0x........         LDR      R0,??DataTable9_8
   \   000001B0   0x........         BL       printf
    222                              mapped->managed.blockStatuses[i].status =
    223                                                              NandBlockStatus_LIVE;
   \   000001B4   0xE1B0010A         LSLS     R0,R10,#+2
   \   000001B8   0xE0900004         ADDS     R0,R0,R4
   \   000001BC   0xE5900030         LDR      R0,[R0, #+48]
   \   000001C0   0xE3D0000F         BICS     R0,R0,#0xF
   \   000001C4   0xE390000C         ORRS     R0,R0,#0xC
   \   000001C8   0xE1B0110A         LSLS     R1,R10,#+2
   \   000001CC   0xE0911004         ADDS     R1,R1,R4
   \   000001D0   0xE5810030         STR      R0,[R1, #+48]
   \   000001D4   0xEA000010         B        ??LoadLogicalMapping_6
    224                          }
    225                      }
    226                      // Block is FREE or BAD
    227                      else {
    228          
    229                          // Block is mapped -> remove it from mapping
    230                          if (logicalBlock != -1) {
   \                     ??LoadLogicalMapping_8:
   \   000001D8   0xE3E00000         MVN      R0,#+0
   \   000001DC   0xE1A0B80B         LSL      R11,R11,#+16
   \   000001E0   0xE1B0B84B         ASRS     R11,R11,#+16
   \   000001E4   0xE15B0000         CMP      R11,R0
   \   000001E8   0x0A00000B         BEQ      ??LoadLogicalMapping_6
    231          
    232                              TRACE_WARNING_WP("-I- Unmap FREE or BAD #%d\n\r", i);
                                                                                       ^
Remark[Pe181]: argument is incompatible with corresponding format string
          conversion
   \   000001EC   0xE1B0100A         MOVS     R1,R10
   \   000001F0   0x........         LDR      R0,??DataTable9_9
   \   000001F4   0x........         BL       printf
    233                              mapped->logicalMapping[logicalBlock] = -1;
   \   000001F8   0xE3A00034         MOV      R0,#+52
   \   000001FC   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000200   0xE1B0100B         MOVS     R1,R11
   \   00000204   0xE1A01801         LSL      R1,R1,#+16
   \   00000208   0xE1B01841         ASRS     R1,R1,#+16
   \   0000020C   0xE1B01081         LSLS     R1,R1,#+1
   \   00000210   0xE0911004         ADDS     R1,R1,R4
   \   00000214   0xE3E02000         MVN      R2,#+0
   \   00000218   0xE18020B1         STRH     R2,[R0, +R1]
    234                          }
    235                      }
    236                  }
    237              }
   \                     ??LoadLogicalMapping_6:
   \   0000021C   0xE29AA001         ADDS     R10,R10,#+1
   \   00000220   0xEAFFFFB4         B        ??LoadLogicalMapping_4
    238          
    239              TRACE_WARNING_WP("-I- Mapping loaded from block #%d\n\r", physicalBlock);
   \                     ??LoadLogicalMapping_5:
   \   00000224   0xE1B01005         MOVS     R1,R5
   \   00000228   0xE1A01801         LSL      R1,R1,#+16
   \   0000022C   0xE1B01821         LSRS     R1,R1,#+16
   \   00000230   0x........         LDR      R0,??DataTable9_10
   \   00000234   0x........         BL       printf
    240          
    241              return 0;
   \   00000238   0xE3A00000         MOV      R0,#+0
   \                     ??LoadLogicalMapping_3:
   \   0000023C   0xE28DD00C         ADD      SP,SP,#+12       ;; stack cleaning
   \   00000240   0xE28DDE80         ADD      SP,SP,#+2048
   \   00000244   0xE8BD4FF0         POP      {R4-R11,LR}
   \   00000248   0xE12FFF1E         BX       LR               ;; return
    242          }
    243          
    244          //------------------------------------------------------------------------------
    245          //         Exported functions
    246          //------------------------------------------------------------------------------
    247          
    248          //------------------------------------------------------------------------------
    249          /// Initializes a MappedNandFlash instance. Scans the device to look for and
    250          /// existing logical block mapping; otherwise starts from scratch (no block
    251          /// mapped).
    252          /// Returns 0 if successful; otherwise returns a NandCommon_ERROR_xxx code.
    253          /// \param mapped  Pointer to a MappedNandFlash instance.
    254          /// \param model  Pointer to the underlying nand chip model. Can be 0.
    255          /// \param commandAddress  Address at which commands are sent.
    256          /// \param addressAddress  Address at which addresses are sent.
    257          /// \param dataAddress  Address at which data is sent.
    258          /// \param pinChipEnable  Pin controlling the CE signal of the NandFlash.
    259          /// \param pinReadyBusy  Pin used to monitor the ready/busy signal of the Nand.
    260          /// \param baseBlock Basic physical block address of mapped area.
    261          /// \param sizeInBlocks Number of blocks that is mapped.
    262          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    263          unsigned char MappedNandFlash_Initialize(
    264              struct MappedNandFlash *mapped,
    265              const struct NandFlashModel *model,
    266              unsigned int commandAddress,
    267              unsigned int addressAddress,
    268              unsigned int dataAddress,
    269              const Pin pinChipEnable,
    270              const Pin pinReadyBusy,
    271              unsigned short baseBlock,
    272              unsigned short sizeInBlocks)
    273          {
   \                     MappedNandFlash_Initialize:
   \   00000000   0xE92D4FF6         PUSH     {R1,R2,R4-R11,LR}
   \   00000004   0xE24DD02C         SUB      SP,SP,#+44
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05003         MOVS     R5,R3
   \   00000010   0xE59D6058         LDR      R6,[SP, #+88]
   \   00000014   0xE1DD77B4         LDRH     R7,[SP, #+116]
   \   00000018   0xE1DD87B8         LDRH     R8,[SP, #+120]
    274              unsigned char error;
    275              unsigned short numBlocks;
    276              unsigned short block;
    277              signed short logicalMappingBlock = 0;
   \   0000001C   0xE3A01000         MOV      R1,#+0
   \   00000020   0xE1CD12B4         STRH     R1,[SP, #+36]
    278          
    279              TRACE_INFO("MappedNandFlash_Initialize()\n\r");
   \   00000024   0x........         LDR      R0,??DataTable9_11
   \   00000028   0x........         BL       printf
    280          
    281              // Initialize ManagedNandFlash
    282              error = ManagedNandFlash_Initialize(MANAGED(mapped),
    283                                                  model,
    284                                                  commandAddress,
    285                                                  addressAddress,
    286                                                  dataAddress,
    287                                                  pinChipEnable,
    288                                                  pinReadyBusy,
    289                                                  baseBlock,
    290                                                  sizeInBlocks);
   \   0000002C   0xE1A08808         LSL      R8,R8,#+16
   \   00000030   0xE1B08828         LSRS     R8,R8,#+16
   \   00000034   0xE58D8020         STR      R8,[SP, #+32]
   \   00000038   0xE1A07807         LSL      R7,R7,#+16
   \   0000003C   0xE1B07827         LSRS     R7,R7,#+16
   \   00000040   0xE58D701C         STR      R7,[SP, #+28]
   \   00000044   0xE28D0068         ADD      R0,SP,#+104
   \   00000048   0xE28D2010         ADD      R2,SP,#+16
   \   0000004C   0xE8B0000A         LDM      R0!,{R1,R3}
   \   00000050   0xE8A2000A         STM      R2!,{R1,R3}
   \   00000054   0xE5903000         LDR      R3,[R0, #0]
   \   00000058   0xE5823000         STR      R3,[R2, #+0]
   \   0000005C   0xE2500008         SUBS     R0,R0,#+8
   \   00000060   0xE2522008         SUBS     R2,R2,#+8
   \   00000064   0xE28D005C         ADD      R0,SP,#+92
   \   00000068   0xE28D2004         ADD      R2,SP,#+4
   \   0000006C   0xE8B0000A         LDM      R0!,{R1,R3}
   \   00000070   0xE8A2000A         STM      R2!,{R1,R3}
   \   00000074   0xE5903000         LDR      R3,[R0, #0]
   \   00000078   0xE5823000         STR      R3,[R2, #+0]
   \   0000007C   0xE2500008         SUBS     R0,R0,#+8
   \   00000080   0xE2522008         SUBS     R2,R2,#+8
   \   00000084   0xE58D6000         STR      R6,[SP, #+0]
   \   00000088   0xE1B03005         MOVS     R3,R5
   \   0000008C   0xE59D2030         LDR      R2,[SP, #+48]
   \   00000090   0xE59D102C         LDR      R1,[SP, #+44]
   \   00000094   0xE1B00004         MOVS     R0,R4
   \   00000098   0x........         BL       ManagedNandFlash_Initialize
   \   0000009C   0xE1B09000         MOVS     R9,R0
    291              if (error) {
   \   000000A0   0xE21990FF         ANDS     R9,R9,#0xFF      ;; Zero extend
   \   000000A4   0xE3590000         CMP      R9,#+0
   \   000000A8   0x0A000002         BEQ      ??MappedNandFlash_Initialize_0
    292          
    293                  return error;
   \   000000AC   0xE1B00009         MOVS     R0,R9
   \   000000B0   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000B4   0xEA000037         B        ??MappedNandFlash_Initialize_1
    294              }
    295          
    296              // Scan to find logical mapping
    297              mapped->mappingModified = 0;
   \                     ??MappedNandFlash_Initialize_0:
   \   000000B8   0xE3A00036         MOV      R0,#+54
   \   000000BC   0xE3800D60         ORR      R0,R0,#0x1800
   \   000000C0   0xE3A01000         MOV      R1,#+0
   \   000000C4   0xE7C01004         STRB     R1,[R0, +R4]
    298              error = FindLogicalMappingBlock(mapped, &logicalMappingBlock);
   \   000000C8   0xE28D1024         ADD      R1,SP,#+36
   \   000000CC   0xE1B00004         MOVS     R0,R4
   \   000000D0   0x........         BL       FindLogicalMappingBlock
   \   000000D4   0xE1B09000         MOVS     R9,R0
    299              if (!error) {
   \   000000D8   0xE21990FF         ANDS     R9,R9,#0xFF      ;; Zero extend
   \   000000DC   0xE3590000         CMP      R9,#+0
   \   000000E0   0x1A000009         BNE      ??MappedNandFlash_Initialize_2
    300          
    301                  // Extract mapping from block
    302                  mapped->logicalMappingBlock = logicalMappingBlock;
   \   000000E4   0xE3A00034         MOV      R0,#+52
   \   000000E8   0xE3800D60         ORR      R0,R0,#0x1800
   \   000000EC   0xE1DD12F4         LDRSH    R1,[SP, #+36]
   \   000000F0   0xE18010B4         STRH     R1,[R0, +R4]
    303                  return LoadLogicalMapping(mapped, logicalMappingBlock);
   \   000000F4   0xE1DD12B4         LDRH     R1,[SP, #+36]
   \   000000F8   0xE1A01801         LSL      R1,R1,#+16
   \   000000FC   0xE1B01821         LSRS     R1,R1,#+16
   \   00000100   0xE1B00004         MOVS     R0,R4
   \   00000104   0x........         BL       LoadLogicalMapping
   \   00000108   0xEA000022         B        ??MappedNandFlash_Initialize_1
    304              }
    305              else if (error == NandCommon_ERROR_NOMAPPING) {
   \                     ??MappedNandFlash_Initialize_2:
   \   0000010C   0xE21990FF         ANDS     R9,R9,#0xFF      ;; Zero extend
   \   00000110   0xE359000B         CMP      R9,#+11
   \   00000114   0x1A00001B         BNE      ??MappedNandFlash_Initialize_3
    306          
    307                  // Start with no block mapped
    308                  mapped->logicalMappingBlock = -1;
   \   00000118   0xE3A00034         MOV      R0,#+52
   \   0000011C   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000120   0xE3E01000         MVN      R1,#+0
   \   00000124   0xE18010B4         STRH     R1,[R0, +R4]
    309                  numBlocks = ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped));
   \   00000128   0xE1B00004         MOVS     R0,R4
   \   0000012C   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000130   0xE1B0A000         MOVS     R10,R0
    310                  for (block=0; block < numBlocks; block++) {
   \   00000134   0xE3A00000         MOV      R0,#+0
   \   00000138   0xE1B0B000         MOVS     R11,R0
   \                     ??MappedNandFlash_Initialize_4:
   \   0000013C   0xE1A0B80B         LSL      R11,R11,#+16
   \   00000140   0xE1B0B82B         LSRS     R11,R11,#+16
   \   00000144   0xE1A0A80A         LSL      R10,R10,#+16
   \   00000148   0xE1B0A82A         LSRS     R10,R10,#+16
   \   0000014C   0xE15B000A         CMP      R11,R10
   \   00000150   0x2A00000A         BCS      ??MappedNandFlash_Initialize_5
    311          
    312                      mapped->logicalMapping[block] = -1;
   \   00000154   0xE3A00034         MOV      R0,#+52
   \   00000158   0xE3800D40         ORR      R0,R0,#0x1000
   \   0000015C   0xE1B0100B         MOVS     R1,R11
   \   00000160   0xE1A01801         LSL      R1,R1,#+16
   \   00000164   0xE1B01821         LSRS     R1,R1,#+16
   \   00000168   0xE1B01081         LSLS     R1,R1,#+1
   \   0000016C   0xE0911004         ADDS     R1,R1,R4
   \   00000170   0xE3E02000         MVN      R2,#+0
   \   00000174   0xE18020B1         STRH     R2,[R0, +R1]
    313                  }
   \   00000178   0xE29BB001         ADDS     R11,R11,#+1
   \   0000017C   0xEAFFFFEE         B        ??MappedNandFlash_Initialize_4
    314              }
    315              else {
    316                  
    317                  TRACE_ERROR("MappedNandFlash_Initialize: Initialize device\n\r");
    318                  return error;
    319              }
    320          
    321              return 0;
   \                     ??MappedNandFlash_Initialize_5:
   \   00000180   0xE3A00000         MOV      R0,#+0
   \   00000184   0xEA000003         B        ??MappedNandFlash_Initialize_1
   \                     ??MappedNandFlash_Initialize_3:
   \   00000188   0x........         LDR      R0,??DataTable9_12
   \   0000018C   0x........         BL       printf
   \   00000190   0xE1B00009         MOVS     R0,R9
   \   00000194   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \                     ??MappedNandFlash_Initialize_1:
   \   00000198   0xE28DD034         ADD      SP,SP,#+52       ;; stack cleaning
   \   0000019C   0xE8BD4FF0         POP      {R4-R11,LR}
   \   000001A0   0xE12FFF1E         BX       LR               ;; return
    322          }
    323          
    324          //------------------------------------------------------------------------------
    325          /// Reads the data and/or spare area of a page in a mapped logical block.
    326          /// Returns 0 if successful; otherwise, returns NandCommon_ERROR_BLOCKNOTMAPPED
    327          /// if the block is not mapped, or a NandCommon_ERROR_xxx code.
    328          /// \param mapped  Pointer to a MappedNandFlash instance.
    329          /// \param block  Number of logical block to read page from.
    330          /// \param page  Number of page to read inside given block.
    331          /// \param data  Data area buffer, can be 0.
    332          /// \param spare  Spare area buffer, can be 0.
    333          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    334          unsigned char MappedNandFlash_ReadPage(
    335              const struct MappedNandFlash *mapped,
    336              unsigned short block,
    337              unsigned short page,
    338              void *data,
    339              void *spare)
    340          {
   \                     MappedNandFlash_ReadPage:
   \   00000000   0xE92D43F8         PUSH     {R3-R9,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B07001         MOVS     R7,R1
   \   0000000C   0xE1B05002         MOVS     R5,R2
   \   00000010   0xE1B06003         MOVS     R6,R3
   \   00000014   0xE59D8020         LDR      R8,[SP, #+32]
    341              signed short physicalBlock;
    342          
    343              TRACE_INFO("MappedNandFlash_ReadPage(LB#%d:P#%d)\n\r", block, page);
   \   00000018   0xE1B02005         MOVS     R2,R5
   \   0000001C   0xE1A02802         LSL      R2,R2,#+16
   \   00000020   0xE1B02822         LSRS     R2,R2,#+16
   \   00000024   0xE1B01007         MOVS     R1,R7
   \   00000028   0xE1A01801         LSL      R1,R1,#+16
   \   0000002C   0xE1B01821         LSRS     R1,R1,#+16
   \   00000030   0x........         LDR      R0,??DataTable9_13
   \   00000034   0x........         BL       printf
    344          
    345              // Check if block is mapped
    346              physicalBlock = mapped->logicalMapping[block];
   \   00000038   0xE3A00034         MOV      R0,#+52
   \   0000003C   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000040   0xE1B01007         MOVS     R1,R7
   \   00000044   0xE1A01801         LSL      R1,R1,#+16
   \   00000048   0xE1B01821         LSRS     R1,R1,#+16
   \   0000004C   0xE1B01081         LSLS     R1,R1,#+1
   \   00000050   0xE0911004         ADDS     R1,R1,R4
   \   00000054   0xE19000F1         LDRSH    R0,[R0, +R1]
   \   00000058   0xE1B09000         MOVS     R9,R0
    347              if (physicalBlock == -1) {
   \   0000005C   0xE3E00000         MVN      R0,#+0
   \   00000060   0xE1A09809         LSL      R9,R9,#+16
   \   00000064   0xE1B09849         ASRS     R9,R9,#+16
   \   00000068   0xE1590000         CMP      R9,R0
   \   0000006C   0x1A000006         BNE      ??MappedNandFlash_ReadPage_0
    348          
    349                  TRACE_INFO( "MappedNandFlash_ReadPage: Block %d not mapped\n\r", block);
   \   00000070   0xE1B01007         MOVS     R1,R7
   \   00000074   0xE1A01801         LSL      R1,R1,#+16
   \   00000078   0xE1B01821         LSRS     R1,R1,#+16
   \   0000007C   0x........         LDR      R0,??DataTable9_14
   \   00000080   0x........         BL       printf
    350                  return NandCommon_ERROR_BLOCKNOTMAPPED;
   \   00000084   0xE3A00002         MOV      R0,#+2
   \   00000088   0xEA000009         B        ??MappedNandFlash_ReadPage_1
    351              }
    352          
    353              // Read page from corresponding physical block
    354              return ManagedNandFlash_ReadPage(MANAGED(mapped),
    355                                               physicalBlock,
    356                                               page,
    357                                               data,
    358                                               spare);
   \                     ??MappedNandFlash_ReadPage_0:
   \   0000008C   0xE58D8000         STR      R8,[SP, #+0]
   \   00000090   0xE1B03006         MOVS     R3,R6
   \   00000094   0xE1B02005         MOVS     R2,R5
   \   00000098   0xE1A02802         LSL      R2,R2,#+16
   \   0000009C   0xE1B02822         LSRS     R2,R2,#+16
   \   000000A0   0xE1B01009         MOVS     R1,R9
   \   000000A4   0xE1A01801         LSL      R1,R1,#+16
   \   000000A8   0xE1B01821         LSRS     R1,R1,#+16
   \   000000AC   0xE1B00004         MOVS     R0,R4
   \   000000B0   0x........         BL       ManagedNandFlash_ReadPage
   \                     ??MappedNandFlash_ReadPage_1:
   \   000000B4   0xE8BD43F2         POP      {R1,R4-R9,LR}
   \   000000B8   0xE12FFF1E         BX       LR               ;; return
    359          }
    360          
    361          //------------------------------------------------------------------------------
    362          /// Writes the data and/or spare area of a page in the given mapped logical
    363          /// block.
    364          /// Returns 0 if successful; otherwise, returns NandCommon_ERROR_BLOCKNOTMAPPED
    365          /// (indicating the block is not logically mapped) or another NandCommon_ERROR
    366          /// code.
    367          /// \param mapped  Pointer to a MappedNandFlash instance.
    368          /// \param block  Number of logical block to write on.
    369          /// \param page  Number of page to write inside given block.
    370          /// \param data  Data area buffer, can be 0.
    371          /// \param spare  Spare area buffer, can be 0.
    372          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    373          unsigned char MappedNandFlash_WritePage(
    374              const struct MappedNandFlash *mapped,
    375              unsigned short block,
    376              unsigned short page,
    377              void *data,
    378              void *spare)
    379          {
   \                     MappedNandFlash_WritePage:
   \   00000000   0xE92D43F8         PUSH     {R3-R9,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B07001         MOVS     R7,R1
   \   0000000C   0xE1B05002         MOVS     R5,R2
   \   00000010   0xE1B06003         MOVS     R6,R3
   \   00000014   0xE59D8020         LDR      R8,[SP, #+32]
    380              signed short physicalBlock;
    381          
    382              TRACE_INFO("MappedNandFlash_WritePage(LB#%d:P#%d)\n\r", block, page);
   \   00000018   0xE1B02005         MOVS     R2,R5
   \   0000001C   0xE1A02802         LSL      R2,R2,#+16
   \   00000020   0xE1B02822         LSRS     R2,R2,#+16
   \   00000024   0xE1B01007         MOVS     R1,R7
   \   00000028   0xE1A01801         LSL      R1,R1,#+16
   \   0000002C   0xE1B01821         LSRS     R1,R1,#+16
   \   00000030   0x........         LDR      R0,??DataTable9_15
   \   00000034   0x........         BL       printf
    383          
    384              // Check if block is mapped
    385              physicalBlock = mapped->logicalMapping[block];
   \   00000038   0xE3A00034         MOV      R0,#+52
   \   0000003C   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000040   0xE1B01007         MOVS     R1,R7
   \   00000044   0xE1A01801         LSL      R1,R1,#+16
   \   00000048   0xE1B01821         LSRS     R1,R1,#+16
   \   0000004C   0xE1B01081         LSLS     R1,R1,#+1
   \   00000050   0xE0911004         ADDS     R1,R1,R4
   \   00000054   0xE19000F1         LDRSH    R0,[R0, +R1]
   \   00000058   0xE1B09000         MOVS     R9,R0
    386              if (physicalBlock == -1) {
   \   0000005C   0xE3E00000         MVN      R0,#+0
   \   00000060   0xE1A09809         LSL      R9,R9,#+16
   \   00000064   0xE1B09849         ASRS     R9,R9,#+16
   \   00000068   0xE1590000         CMP      R9,R0
   \   0000006C   0x1A000003         BNE      ??MappedNandFlash_WritePage_0
    387          
    388                  TRACE_ERROR("MappedNandFlash_WritePage: Block must be mapped\n\r");
   \   00000070   0x........         LDR      R0,??DataTable9_16
   \   00000074   0x........         BL       printf
    389                  return NandCommon_ERROR_BLOCKNOTMAPPED;
   \   00000078   0xE3A00002         MOV      R0,#+2
   \   0000007C   0xEA000009         B        ??MappedNandFlash_WritePage_1
    390              }
    391          
    392              // Write page on physical block
    393              return ManagedNandFlash_WritePage(MANAGED(mapped),
    394                                                physicalBlock,
    395                                                page,
    396                                                data,
    397                                                spare);
   \                     ??MappedNandFlash_WritePage_0:
   \   00000080   0xE58D8000         STR      R8,[SP, #+0]
   \   00000084   0xE1B03006         MOVS     R3,R6
   \   00000088   0xE1B02005         MOVS     R2,R5
   \   0000008C   0xE1A02802         LSL      R2,R2,#+16
   \   00000090   0xE1B02822         LSRS     R2,R2,#+16
   \   00000094   0xE1B01009         MOVS     R1,R9
   \   00000098   0xE1A01801         LSL      R1,R1,#+16
   \   0000009C   0xE1B01821         LSRS     R1,R1,#+16
   \   000000A0   0xE1B00004         MOVS     R0,R4
   \   000000A4   0x........         BL       ManagedNandFlash_WritePage
   \                     ??MappedNandFlash_WritePage_1:
   \   000000A8   0xE8BD43F2         POP      {R1,R4-R9,LR}
   \   000000AC   0xE12FFF1E         BX       LR               ;; return
    398          }
    399          
    400          //------------------------------------------------------------------------------
    401          /// Maps a logical block number to an actual physical block. This allocates
    402          /// the physical block (meaning it must be FREE), and releases the previous
    403          /// block being replaced (if any).
    404          /// Returns 0 if successful; otherwise returns a NandCommon_ERROR_xxx code.
    405          /// \param mapped  Pointer to a MappedNandFlash instance.
    406          /// \param logicalBlock  Logical block number to map.
    407          /// \param physicalBlock  Physical block to map to the logical one.
    408          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    409          unsigned char MappedNandFlash_Map(
    410              struct MappedNandFlash *mapped,
    411              unsigned short logicalBlock,
    412              unsigned short physicalBlock)
    413          {
   \                     MappedNandFlash_Map:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    414              unsigned char error;
    415              signed short oldPhysicalBlock;
    416          
    417              TRACE_INFO("MappedNandFlash_Map(LB#%d -> PB#%d)\n\r",
    418                         logicalBlock, physicalBlock);
   \   00000010   0xE1B02006         MOVS     R2,R6
   \   00000014   0xE1A02802         LSL      R2,R2,#+16
   \   00000018   0xE1B02822         LSRS     R2,R2,#+16
   \   0000001C   0xE1B01005         MOVS     R1,R5
   \   00000020   0xE1A01801         LSL      R1,R1,#+16
   \   00000024   0xE1B01821         LSRS     R1,R1,#+16
   \   00000028   0x........         LDR      R0,??DataTable9_17
   \   0000002C   0x........         BL       printf
    419              ASSERT(
    420                 logicalBlock < ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped)),
    421                 "MappedNandFlash_Map: logicalBlock out-of-range\n\r");
   \   00000030   0xE1B00004         MOVS     R0,R4
   \   00000034   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000038   0xE1A05805         LSL      R5,R5,#+16
   \   0000003C   0xE1B05825         LSRS     R5,R5,#+16
   \   00000040   0xE1550000         CMP      R5,R0
   \   00000044   0x3A000004         BCC      ??MappedNandFlash_Map_0
   \   00000048   0x........         LDR      R0,??DataTable9_18
   \   0000004C   0x........         BL       printf
   \   00000050   0x........         LDR      R0,??DataTable9_19
   \   00000054   0x........         BL       printf
   \                     ??MappedNandFlash_Map_1:
   \   00000058   0xEAFFFFFE         B        ??MappedNandFlash_Map_1
    422              ASSERT(
    423                 physicalBlock < ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped)),
    424                 "MappedNandFlash_Map: physicalBlock out-of-range\n\r");
   \                     ??MappedNandFlash_Map_0:
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000064   0xE1A06806         LSL      R6,R6,#+16
   \   00000068   0xE1B06826         LSRS     R6,R6,#+16
   \   0000006C   0xE1560000         CMP      R6,R0
   \   00000070   0x3A000004         BCC      ??MappedNandFlash_Map_2
   \   00000074   0x........         LDR      R0,??DataTable9_18
   \   00000078   0x........         BL       printf
   \   0000007C   0x........         LDR      R0,??DataTable9_20
   \   00000080   0x........         BL       printf
   \                     ??MappedNandFlash_Map_3:
   \   00000084   0xEAFFFFFE         B        ??MappedNandFlash_Map_3
    425          
    426              // Allocate physical block
    427              error = ManagedNandFlash_AllocateBlock(MANAGED(mapped), physicalBlock);
   \                     ??MappedNandFlash_Map_2:
   \   00000088   0xE1B01006         MOVS     R1,R6
   \   0000008C   0xE1A01801         LSL      R1,R1,#+16
   \   00000090   0xE1B01821         LSRS     R1,R1,#+16
   \   00000094   0xE1B00004         MOVS     R0,R4
   \   00000098   0x........         BL       ManagedNandFlash_AllocateBlock
   \   0000009C   0xE1B08000         MOVS     R8,R0
    428              if (error) {
   \   000000A0   0xE21880FF         ANDS     R8,R8,#0xFF      ;; Zero extend
   \   000000A4   0xE3580000         CMP      R8,#+0
   \   000000A8   0x0A000002         BEQ      ??MappedNandFlash_Map_4
    429          
    430                  return error;
   \   000000AC   0xE1B00008         MOVS     R0,R8
   \   000000B0   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000B4   0xEA000026         B        ??MappedNandFlash_Map_5
    431              }
    432          
    433              // Release currently mapped block (if any)
    434              oldPhysicalBlock = mapped->logicalMapping[logicalBlock];
   \                     ??MappedNandFlash_Map_4:
   \   000000B8   0xE3A00034         MOV      R0,#+52
   \   000000BC   0xE3800D40         ORR      R0,R0,#0x1000
   \   000000C0   0xE1B01005         MOVS     R1,R5
   \   000000C4   0xE1A01801         LSL      R1,R1,#+16
   \   000000C8   0xE1B01821         LSRS     R1,R1,#+16
   \   000000CC   0xE1B01081         LSLS     R1,R1,#+1
   \   000000D0   0xE0911004         ADDS     R1,R1,R4
   \   000000D4   0xE19000F1         LDRSH    R0,[R0, +R1]
   \   000000D8   0xE1B07000         MOVS     R7,R0
    435              if (oldPhysicalBlock != -1) {
   \   000000DC   0xE3E00000         MVN      R0,#+0
   \   000000E0   0xE1A07807         LSL      R7,R7,#+16
   \   000000E4   0xE1B07847         ASRS     R7,R7,#+16
   \   000000E8   0xE1570000         CMP      R7,R0
   \   000000EC   0x0A00000B         BEQ      ??MappedNandFlash_Map_6
    436          
    437                  error =
    438                      ManagedNandFlash_ReleaseBlock(MANAGED(mapped), oldPhysicalBlock);
   \   000000F0   0xE1B01007         MOVS     R1,R7
   \   000000F4   0xE1A01801         LSL      R1,R1,#+16
   \   000000F8   0xE1B01821         LSRS     R1,R1,#+16
   \   000000FC   0xE1B00004         MOVS     R0,R4
   \   00000100   0x........         BL       ManagedNandFlash_ReleaseBlock
   \   00000104   0xE1B08000         MOVS     R8,R0
    439                  if (error) {
   \   00000108   0xE21880FF         ANDS     R8,R8,#0xFF      ;; Zero extend
   \   0000010C   0xE3580000         CMP      R8,#+0
   \   00000110   0x0A000002         BEQ      ??MappedNandFlash_Map_6
    440          
    441                      return error;
   \   00000114   0xE1B00008         MOVS     R0,R8
   \   00000118   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000011C   0xEA00000C         B        ??MappedNandFlash_Map_5
    442                  }                                      
    443              }
    444          
    445              // Set mapping
    446              mapped->logicalMapping[logicalBlock] = physicalBlock;
   \                     ??MappedNandFlash_Map_6:
   \   00000120   0xE3A00034         MOV      R0,#+52
   \   00000124   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000128   0xE1B01005         MOVS     R1,R5
   \   0000012C   0xE1A01801         LSL      R1,R1,#+16
   \   00000130   0xE1B01821         LSRS     R1,R1,#+16
   \   00000134   0xE1B01081         LSLS     R1,R1,#+1
   \   00000138   0xE0911004         ADDS     R1,R1,R4
   \   0000013C   0xE18060B1         STRH     R6,[R0, +R1]
    447              mapped->mappingModified = 1;
   \   00000140   0xE3A00036         MOV      R0,#+54
   \   00000144   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000148   0xE3A01001         MOV      R1,#+1
   \   0000014C   0xE7C01004         STRB     R1,[R0, +R4]
    448          
    449              return 0;
   \   00000150   0xE3A00000         MOV      R0,#+0
   \                     ??MappedNandFlash_Map_5:
   \   00000154   0xE8BD41F0         POP      {R4-R8,LR}
   \   00000158   0xE12FFF1E         BX       LR               ;; return
    450          }
    451          
    452          //------------------------------------------------------------------------------
    453          /// Unmaps a logical block by releasing the corresponding physical block (if 
    454          /// any).
    455          /// Returns 0 if successful; otherwise returns a NandCommon_ERROR code.
    456          /// \param mapped  Pointer to a MappedNandFlash instance.
    457          /// \param logicalBlock  Number of logical block to unmap.
    458          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    459          unsigned char MappedNandFlash_Unmap(
    460              struct MappedNandFlash *mapped,
    461              unsigned short logicalBlock)
    462          {
   \                     MappedNandFlash_Unmap:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    463              signed short physicalBlock = mapped->logicalMapping[logicalBlock];
   \   0000000C   0xE3A00034         MOV      R0,#+52
   \   00000010   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000014   0xE1B01005         MOVS     R1,R5
   \   00000018   0xE1A01801         LSL      R1,R1,#+16
   \   0000001C   0xE1B01821         LSRS     R1,R1,#+16
   \   00000020   0xE1B01081         LSLS     R1,R1,#+1
   \   00000024   0xE0911004         ADDS     R1,R1,R4
   \   00000028   0xE19060F1         LDRSH    R6,[R0, +R1]
    464              unsigned char error;
    465          
    466              TRACE_INFO("MappedNandFlash_Unmap(LB#%d)\n\r", logicalBlock);
   \   0000002C   0xE1B01005         MOVS     R1,R5
   \   00000030   0xE1A01801         LSL      R1,R1,#+16
   \   00000034   0xE1B01821         LSRS     R1,R1,#+16
   \   00000038   0x........         LDR      R0,??DataTable9_21
   \   0000003C   0x........         BL       printf
    467              ASSERT(
    468                  logicalBlock < ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped)),
    469                  "MappedNandFlash_Unmap: logicalBlock out-of-range\n\r");
   \   00000040   0xE1B00004         MOVS     R0,R4
   \   00000044   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000048   0xE1A05805         LSL      R5,R5,#+16
   \   0000004C   0xE1B05825         LSRS     R5,R5,#+16
   \   00000050   0xE1550000         CMP      R5,R0
   \   00000054   0x3A000004         BCC      ??MappedNandFlash_Unmap_0
   \   00000058   0x........         LDR      R0,??DataTable9_18
   \   0000005C   0x........         BL       printf
   \   00000060   0x........         LDR      R0,??DataTable9_22
   \   00000064   0x........         BL       printf
   \                     ??MappedNandFlash_Unmap_1:
   \   00000068   0xEAFFFFFE         B        ??MappedNandFlash_Unmap_1
    470          
    471              if (physicalBlock != -1) {
   \                     ??MappedNandFlash_Unmap_0:
   \   0000006C   0xE3E00000         MVN      R0,#+0
   \   00000070   0xE1A06806         LSL      R6,R6,#+16
   \   00000074   0xE1B06846         ASRS     R6,R6,#+16
   \   00000078   0xE1560000         CMP      R6,R0
   \   0000007C   0x0A00000B         BEQ      ??MappedNandFlash_Unmap_2
    472          
    473                  error = ManagedNandFlash_ReleaseBlock(MANAGED(mapped), physicalBlock);
   \   00000080   0xE1B01006         MOVS     R1,R6
   \   00000084   0xE1A01801         LSL      R1,R1,#+16
   \   00000088   0xE1B01821         LSRS     R1,R1,#+16
   \   0000008C   0xE1B00004         MOVS     R0,R4
   \   00000090   0x........         BL       ManagedNandFlash_ReleaseBlock
   \   00000094   0xE1B07000         MOVS     R7,R0
    474                  if (error) {
   \   00000098   0xE21770FF         ANDS     R7,R7,#0xFF      ;; Zero extend
   \   0000009C   0xE3570000         CMP      R7,#+0
   \   000000A0   0x0A000002         BEQ      ??MappedNandFlash_Unmap_2
    475          
    476                      return error;
   \   000000A4   0xE1B00007         MOVS     R0,R7
   \   000000A8   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000AC   0xEA00000D         B        ??MappedNandFlash_Unmap_3
    477                  }
    478              }
    479              mapped->logicalMapping[logicalBlock] = -1;
   \                     ??MappedNandFlash_Unmap_2:
   \   000000B0   0xE3A00034         MOV      R0,#+52
   \   000000B4   0xE3800D40         ORR      R0,R0,#0x1000
   \   000000B8   0xE1B01005         MOVS     R1,R5
   \   000000BC   0xE1A01801         LSL      R1,R1,#+16
   \   000000C0   0xE1B01821         LSRS     R1,R1,#+16
   \   000000C4   0xE1B01081         LSLS     R1,R1,#+1
   \   000000C8   0xE0911004         ADDS     R1,R1,R4
   \   000000CC   0xE3E02000         MVN      R2,#+0
   \   000000D0   0xE18020B1         STRH     R2,[R0, +R1]
    480              mapped->mappingModified = 1;
   \   000000D4   0xE3A00036         MOV      R0,#+54
   \   000000D8   0xE3800D60         ORR      R0,R0,#0x1800
   \   000000DC   0xE3A01001         MOV      R1,#+1
   \   000000E0   0xE7C01004         STRB     R1,[R0, +R4]
    481          
    482              return 0;
   \   000000E4   0xE3A00000         MOV      R0,#+0
   \                     ??MappedNandFlash_Unmap_3:
   \   000000E8   0xE8BD40F2         POP      {R1,R4-R7,LR}
   \   000000EC   0xE12FFF1E         BX       LR               ;; return
    483          }
    484          
    485          //------------------------------------------------------------------------------
    486          /// Returns the physical block mapped with the given logical block, or -1 if it
    487          /// is not mapped.
    488          /// \param mapped  Pointer to a MappedNandFlash instance.
    489          /// \param logicalBlock  Logical block number.
    490          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    491          signed short MappedNandFlash_LogicalToPhysical(
    492              const struct MappedNandFlash *mapped,
    493              unsigned short logicalBlock)
    494          {
   \                     MappedNandFlash_LogicalToPhysical:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    495              ASSERT(
    496                  logicalBlock < ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped)),
    497                  "MappedNandFlash_LogicalToPhysical: logicalBlock out-of-range\n\r");
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000014   0xE1A05805         LSL      R5,R5,#+16
   \   00000018   0xE1B05825         LSRS     R5,R5,#+16
   \   0000001C   0xE1550000         CMP      R5,R0
   \   00000020   0x3A000004         BCC      ??MappedNandFlash_LogicalToPhysical_0
   \   00000024   0x........         LDR      R0,??DataTable9_18
   \   00000028   0x........         BL       printf
   \   0000002C   0x........         LDR      R0,??DataTable9_23
   \   00000030   0x........         BL       printf
   \                     ??MappedNandFlash_LogicalToPhysical_1:
   \   00000034   0xEAFFFFFE         B        ??MappedNandFlash_LogicalToPhysical_1
    498          
    499              return mapped->logicalMapping[logicalBlock];
   \                     ??MappedNandFlash_LogicalToPhysical_0:
   \   00000038   0xE3A00034         MOV      R0,#+52
   \   0000003C   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000040   0xE1A05805         LSL      R5,R5,#+16
   \   00000044   0xE1B05825         LSRS     R5,R5,#+16
   \   00000048   0xE1B01085         LSLS     R1,R5,#+1
   \   0000004C   0xE0911004         ADDS     R1,R1,R4
   \   00000050   0xE19000F1         LDRSH    R0,[R0, +R1]
   \   00000054   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   00000058   0xE12FFF1E         BX       LR               ;; return
    500          }
    501          
    502          //------------------------------------------------------------------------------
    503          /// Returns the logical block which is mapped to given physical block, or -1 if
    504          /// the latter is not mapped.
    505          /// \param mapped  Pointer to a MappedNandFlash instance.
    506          /// \param physicalBlock  Physical block number.
    507          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    508          signed short MappedNandFlash_PhysicalToLogical(
    509              const struct MappedNandFlash *mapped,
    510              unsigned short physicalBlock)
    511          {
   \                     MappedNandFlash_PhysicalToLogical:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    512              unsigned short numBlocks =
    513                              ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped));
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000014   0xE1B06000         MOVS     R6,R0
    514              signed short logicalBlock;
    515          
    516              ASSERT(
    517                 physicalBlock < ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped)),
    518                 "MappedNandFlash_PhysicalToLogical: physicalBlock out-of-range\n\r");
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000020   0xE1A05805         LSL      R5,R5,#+16
   \   00000024   0xE1B05825         LSRS     R5,R5,#+16
   \   00000028   0xE1550000         CMP      R5,R0
   \   0000002C   0x3A000004         BCC      ??MappedNandFlash_PhysicalToLogical_0
   \   00000030   0x........         LDR      R0,??DataTable9_18
   \   00000034   0x........         BL       printf
   \   00000038   0x........         LDR      R0,??DataTable9_24
   \   0000003C   0x........         BL       printf
   \                     ??MappedNandFlash_PhysicalToLogical_1:
   \   00000040   0xEAFFFFFE         B        ??MappedNandFlash_PhysicalToLogical_1
    519          
    520              // Search the mapping for the desired physical block
    521              for (logicalBlock=0; logicalBlock < numBlocks; logicalBlock++) {
   \                     ??MappedNandFlash_PhysicalToLogical_0:
   \   00000044   0xE3A00000         MOV      R0,#+0
   \   00000048   0xE1B07000         MOVS     R7,R0
   \                     ??MappedNandFlash_PhysicalToLogical_2:
   \   0000004C   0xE1B00007         MOVS     R0,R7
   \   00000050   0xE1A00800         LSL      R0,R0,#+16
   \   00000054   0xE1B00840         ASRS     R0,R0,#+16
   \   00000058   0xE1B01006         MOVS     R1,R6
   \   0000005C   0xE1A01801         LSL      R1,R1,#+16
   \   00000060   0xE1B01821         LSRS     R1,R1,#+16
   \   00000064   0xE1500001         CMP      R0,R1
   \   00000068   0xAA000012         BGE      ??MappedNandFlash_PhysicalToLogical_3
    522          
    523                  if (mapped->logicalMapping[logicalBlock] == physicalBlock) {
   \   0000006C   0xE3A00034         MOV      R0,#+52
   \   00000070   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000074   0xE1B01007         MOVS     R1,R7
   \   00000078   0xE1A01801         LSL      R1,R1,#+16
   \   0000007C   0xE1B01841         ASRS     R1,R1,#+16
   \   00000080   0xE1B01081         LSLS     R1,R1,#+1
   \   00000084   0xE0911004         ADDS     R1,R1,R4
   \   00000088   0xE19000F1         LDRSH    R0,[R0, +R1]
   \   0000008C   0xE1B01005         MOVS     R1,R5
   \   00000090   0xE1A01801         LSL      R1,R1,#+16
   \   00000094   0xE1B01821         LSRS     R1,R1,#+16
   \   00000098   0xE1500001         CMP      R0,R1
   \   0000009C   0x1A000003         BNE      ??MappedNandFlash_PhysicalToLogical_4
    524          
    525                      return logicalBlock;
   \   000000A0   0xE1B00007         MOVS     R0,R7
   \   000000A4   0xE1A00800         LSL      R0,R0,#+16
   \   000000A8   0xE1B00840         ASRS     R0,R0,#+16
   \   000000AC   0xEA000002         B        ??MappedNandFlash_PhysicalToLogical_5
    526                  }
    527              }
   \                     ??MappedNandFlash_PhysicalToLogical_4:
   \   000000B0   0xE2977001         ADDS     R7,R7,#+1
   \   000000B4   0xEAFFFFE4         B        ??MappedNandFlash_PhysicalToLogical_2
    528          
    529              return -1;
   \                     ??MappedNandFlash_PhysicalToLogical_3:
   \   000000B8   0xE3E00000         MVN      R0,#+0
   \                     ??MappedNandFlash_PhysicalToLogical_5:
   \   000000BC   0xE8BD40F2         POP      {R1,R4-R7,LR}
   \   000000C0   0xE12FFF1E         BX       LR               ;; return
    530          }
    531          
    532          //------------------------------------------------------------------------------
    533          /// Saves the logical mapping on a FREE, unmapped physical block. Allocates the
    534          /// new block, releases the previous one (if any) and save the mapping.
    535          /// Returns 0 if successful; otherwise, returns NandCommon_ERROR_WRONGSTATUS
    536          /// if the block is not LIVE, or a NandCommon_ERROR code.
    537          /// \param mapped  Pointer to a MappedNandFlash instance.
    538          /// \param physicalBlock  Physical block number.
    539          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    540          unsigned char MappedNandFlash_SaveLogicalMapping(
    541              struct MappedNandFlash *mapped,
    542              unsigned short physicalBlock)
    543          {
   \                     MappedNandFlash_SaveLogicalMapping:
   \   00000000   0xE92D4FF0         PUSH     {R4-R11,LR}
   \   00000004   0xE24DD00C         SUB      SP,SP,#+12
   \   00000008   0xE24DDE80         SUB      SP,SP,#+2048
   \   0000000C   0xE1B04000         MOVS     R4,R0
   \   00000010   0xE1B05001         MOVS     R5,R1
    544              unsigned char error;
    545              unsigned char data[NandCommon_MAXPAGEDATASIZE];
    546              unsigned short pageDataSize =
    547                              NandFlashModel_GetPageDataSize(MODEL(mapped));
   \   00000014   0xE1B00004         MOVS     R0,R4
   \   00000018   0x........         BL       NandFlashModel_GetPageDataSize
   \   0000001C   0xE1CD00B4         STRH     R0,[SP, #+4]
    548              //unsigned short numBlocks =
    549              //                ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped));
    550              unsigned int i;
    551              unsigned int remainingSize;
    552              unsigned char *currentBuffer;
    553              unsigned short currentPage;
    554              unsigned int writeSize;
    555              signed short previousPhysicalBlock;
    556          
    557              TRACE_INFO("MappedNandFlash_SaveLogicalMapping(B#%d)\n\r", physicalBlock);
   \   00000020   0xE1B01005         MOVS     R1,R5
   \   00000024   0xE1A01801         LSL      R1,R1,#+16
   \   00000028   0xE1B01821         LSRS     R1,R1,#+16
   \   0000002C   0x........         LDR      R0,??DataTable9_25
   \   00000030   0x........         BL       printf
    558          
    559              // If mapping has not been modified, do nothing
    560              if (!mapped->mappingModified) {
   \   00000034   0xE3A00036         MOV      R0,#+54
   \   00000038   0xE3800D60         ORR      R0,R0,#0x1800
   \   0000003C   0xE7D00004         LDRB     R0,[R0, +R4]
   \   00000040   0xE3500000         CMP      R0,#+0
   \   00000044   0x1A000001         BNE      ??MappedNandFlash_SaveLogicalMapping_0
    561          
    562                  return 0;
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xEA000078         B        ??MappedNandFlash_SaveLogicalMapping_1
    563              }
    564          
    565              // Allocate new block
    566              error = ManagedNandFlash_AllocateBlock(MANAGED(mapped), physicalBlock);
   \                     ??MappedNandFlash_SaveLogicalMapping_0:
   \   00000050   0xE1B01005         MOVS     R1,R5
   \   00000054   0xE1A01801         LSL      R1,R1,#+16
   \   00000058   0xE1B01821         LSRS     R1,R1,#+16
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       ManagedNandFlash_AllocateBlock
   \   00000064   0xE1B06000         MOVS     R6,R0
    567              if (error) {
   \   00000068   0xE21660FF         ANDS     R6,R6,#0xFF      ;; Zero extend
   \   0000006C   0xE3560000         CMP      R6,#+0
   \   00000070   0x0A000002         BEQ      ??MappedNandFlash_SaveLogicalMapping_2
    568          
    569                  return error;
   \   00000074   0xE1B00006         MOVS     R0,R6
   \   00000078   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000007C   0xEA00006C         B        ??MappedNandFlash_SaveLogicalMapping_1
    570              }
    571          
    572              // Save mapping
    573              previousPhysicalBlock = mapped->logicalMappingBlock;
   \                     ??MappedNandFlash_SaveLogicalMapping_2:
   \   00000080   0xE3A01034         MOV      R1,#+52
   \   00000084   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000088   0xE19110F4         LDRSH    R1,[R1, +R4]
   \   0000008C   0xE1CD10B6         STRH     R1,[SP, #+6]
    574              mapped->logicalMappingBlock = physicalBlock;
   \   00000090   0xE3A00034         MOV      R0,#+52
   \   00000094   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000098   0xE18050B4         STRH     R5,[R0, +R4]
    575          
    576              // Save actual mapping in pages #1-#XXX
    577              currentBuffer = (unsigned char *) mapped->logicalMapping;
   \   0000009C   0xE3A00034         MOV      R0,#+52
   \   000000A0   0xE3800D40         ORR      R0,R0,#0x1000
   \   000000A4   0xE0900004         ADDS     R0,R0,R4
   \   000000A8   0xE1B09000         MOVS     R9,R0
    578              remainingSize = sizeof(mapped->logicalMapping);
   \   000000AC   0xE3A00E80         MOV      R0,#+2048
   \   000000B0   0xE1B08000         MOVS     R8,R0
    579              currentPage = 1;
   \   000000B4   0xE3A00001         MOV      R0,#+1
   \   000000B8   0xE1B0A000         MOVS     R10,R0
    580              while (remainingSize > 0) {
   \                     ??MappedNandFlash_SaveLogicalMapping_3:
   \   000000BC   0xE3580000         CMP      R8,#+0
   \   000000C0   0x0A000023         BEQ      ??MappedNandFlash_SaveLogicalMapping_4
    581          
    582                  writeSize = min(remainingSize, pageDataSize);
   \   000000C4   0xE1DD10B4         LDRH     R1,[SP, #+4]
   \   000000C8   0xE1B00008         MOVS     R0,R8
   \   000000CC   0x........         BL       min
   \   000000D0   0xE1B0B000         MOVS     R11,R0
    583                  memset(data, 0xFF, pageDataSize);
   \   000000D4   0xE1DD20B4         LDRH     R2,[SP, #+4]
   \   000000D8   0xE3A010FF         MOV      R1,#+255
   \   000000DC   0xE28D0008         ADD      R0,SP,#+8
   \   000000E0   0x........         BL       memset
    584                  memcpy(data, currentBuffer, writeSize);
   \   000000E4   0xE1B0200B         MOVS     R2,R11
   \   000000E8   0xE1B01009         MOVS     R1,R9
   \   000000EC   0xE28D0008         ADD      R0,SP,#+8
   \   000000F0   0x........         BL       memcpy
    585                  error = ManagedNandFlash_WritePage(MANAGED(mapped),
    586                                                     physicalBlock,
    587                                                     currentPage,
    588                                                     data,
    589                                                     0);
   \   000000F4   0xE3A00000         MOV      R0,#+0
   \   000000F8   0xE58D0000         STR      R0,[SP, #+0]
   \   000000FC   0xE28D3008         ADD      R3,SP,#+8
   \   00000100   0xE1B0200A         MOVS     R2,R10
   \   00000104   0xE1A02802         LSL      R2,R2,#+16
   \   00000108   0xE1B02822         LSRS     R2,R2,#+16
   \   0000010C   0xE1B01005         MOVS     R1,R5
   \   00000110   0xE1A01801         LSL      R1,R1,#+16
   \   00000114   0xE1B01821         LSRS     R1,R1,#+16
   \   00000118   0xE1B00004         MOVS     R0,R4
   \   0000011C   0x........         BL       ManagedNandFlash_WritePage
   \   00000120   0xE1B06000         MOVS     R6,R0
    590                  if (error) {
   \   00000124   0xE21660FF         ANDS     R6,R6,#0xFF      ;; Zero extend
   \   00000128   0xE3560000         CMP      R6,#+0
   \   0000012C   0x0A000004         BEQ      ??MappedNandFlash_SaveLogicalMapping_5
    591          
    592                      TRACE_ERROR(
    593                       "MappedNandFlash_SaveLogicalMapping: Failed to write mapping\n\r");
   \   00000130   0x........         LDR      R0,??DataTable9_26
   \   00000134   0x........         BL       printf
    594                      return error;
   \   00000138   0xE1B00006         MOVS     R0,R6
   \   0000013C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000140   0xEA00003B         B        ??MappedNandFlash_SaveLogicalMapping_1
    595                  }
    596          
    597                  currentBuffer += writeSize;
   \                     ??MappedNandFlash_SaveLogicalMapping_5:
   \   00000144   0xE09B9009         ADDS     R9,R11,R9
    598                  remainingSize -= writeSize;
   \   00000148   0xE058800B         SUBS     R8,R8,R11
    599                  currentPage++;
   \   0000014C   0xE29AA001         ADDS     R10,R10,#+1
   \   00000150   0xEAFFFFD9         B        ??MappedNandFlash_SaveLogicalMapping_3
    600              }
    601          
    602              // Mark page #0 of block with a distinguishible pattern, so the mapping can
    603              // be retrieved at startup
    604              for (i=0; i < pageDataSize; i++) {
   \                     ??MappedNandFlash_SaveLogicalMapping_4:
   \   00000154   0xE3A00000         MOV      R0,#+0
   \   00000158   0xE1B07000         MOVS     R7,R0
   \                     ??MappedNandFlash_SaveLogicalMapping_6:
   \   0000015C   0xE1DD00B4         LDRH     R0,[SP, #+4]
   \   00000160   0xE1570000         CMP      R7,R0
   \   00000164   0x2A000006         BCS      ??MappedNandFlash_SaveLogicalMapping_7
    605          
    606                  data[i] = PATTERN(i);
   \   00000168   0xE1B00007         MOVS     R0,R7
   \   0000016C   0xE3A01073         MOV      R1,#+115
   \   00000170   0xE0110080         ANDS     R0,R1,R0, LSL #+1
   \   00000174   0xE28D1008         ADD      R1,SP,#+8
   \   00000178   0xE7C70001         STRB     R0,[R7, +R1]
    607              }
   \   0000017C   0xE2977001         ADDS     R7,R7,#+1
   \   00000180   0xEAFFFFF5         B        ??MappedNandFlash_SaveLogicalMapping_6
    608              error = ManagedNandFlash_WritePage(MANAGED(mapped),
    609                                                 physicalBlock, 0,
    610                                                 data, 0);
   \                     ??MappedNandFlash_SaveLogicalMapping_7:
   \   00000184   0xE3A00000         MOV      R0,#+0
   \   00000188   0xE58D0000         STR      R0,[SP, #+0]
   \   0000018C   0xE28D3008         ADD      R3,SP,#+8
   \   00000190   0xE3A02000         MOV      R2,#+0
   \   00000194   0xE1B01005         MOVS     R1,R5
   \   00000198   0xE1A01801         LSL      R1,R1,#+16
   \   0000019C   0xE1B01821         LSRS     R1,R1,#+16
   \   000001A0   0xE1B00004         MOVS     R0,R4
   \   000001A4   0x........         BL       ManagedNandFlash_WritePage
   \   000001A8   0xE1B06000         MOVS     R6,R0
    611              if (error) {
   \   000001AC   0xE21660FF         ANDS     R6,R6,#0xFF      ;; Zero extend
   \   000001B0   0xE3560000         CMP      R6,#+0
   \   000001B4   0x0A000004         BEQ      ??MappedNandFlash_SaveLogicalMapping_8
    612          
    613                  TRACE_ERROR(
    614                      "MappedNandFlash_SaveLogicalMapping: Failed to write pattern\n\r");
   \   000001B8   0x........         LDR      R0,??DataTable9_27
   \   000001BC   0x........         BL       printf
    615                  return error;
   \   000001C0   0xE1B00006         MOVS     R0,R6
   \   000001C4   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000001C8   0xEA000019         B        ??MappedNandFlash_SaveLogicalMapping_1
    616              }
    617          
    618              // Mapping is not modified anymore
    619              mapped->mappingModified = 0;
   \                     ??MappedNandFlash_SaveLogicalMapping_8:
   \   000001CC   0xE3A00036         MOV      R0,#+54
   \   000001D0   0xE3800D60         ORR      R0,R0,#0x1800
   \   000001D4   0xE3A01000         MOV      R1,#+0
   \   000001D8   0xE7C01004         STRB     R1,[R0, +R4]
    620          
    621              // Release previous block (if any)
    622              if (previousPhysicalBlock != -1) {
   \   000001DC   0xE1DD00F6         LDRSH    R0,[SP, #+6]
   \   000001E0   0xE3E01000         MVN      R1,#+0
   \   000001E4   0xE1500001         CMP      R0,R1
   \   000001E8   0x0A00000B         BEQ      ??MappedNandFlash_SaveLogicalMapping_9
    623          
    624                  TRACE_DEBUG("Previous physical block was #%d\n\r",
    625                              previousPhysicalBlock);
    626                  error = ManagedNandFlash_ReleaseBlock(MANAGED(mapped),
    627                                                        previousPhysicalBlock);
   \   000001EC   0xE1DD10B6         LDRH     R1,[SP, #+6]
   \   000001F0   0xE1A01801         LSL      R1,R1,#+16
   \   000001F4   0xE1B01821         LSRS     R1,R1,#+16
   \   000001F8   0xE1B00004         MOVS     R0,R4
   \   000001FC   0x........         BL       ManagedNandFlash_ReleaseBlock
   \   00000200   0xE1B06000         MOVS     R6,R0
    628                  if (error) {
   \   00000204   0xE21660FF         ANDS     R6,R6,#0xFF      ;; Zero extend
   \   00000208   0xE3560000         CMP      R6,#+0
   \   0000020C   0x0A000002         BEQ      ??MappedNandFlash_SaveLogicalMapping_9
    629          
    630                      return error;
   \   00000210   0xE1B00006         MOVS     R0,R6
   \   00000214   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000218   0xEA000005         B        ??MappedNandFlash_SaveLogicalMapping_1
    631                  }
    632              }
    633          
    634              TRACE_INFO("Mapping saved on block #%d\n\r", physicalBlock);
   \                     ??MappedNandFlash_SaveLogicalMapping_9:
   \   0000021C   0xE1B01005         MOVS     R1,R5
   \   00000220   0xE1A01801         LSL      R1,R1,#+16
   \   00000224   0xE1B01821         LSRS     R1,R1,#+16
   \   00000228   0x........         LDR      R0,??DataTable9_28
   \   0000022C   0x........         BL       printf
    635          
    636              return 0;
   \   00000230   0xE3A00000         MOV      R0,#+0
   \                     ??MappedNandFlash_SaveLogicalMapping_1:
   \   00000234   0xE28DD00C         ADD      SP,SP,#+12       ;; stack cleaning
   \   00000238   0xE28DDE80         ADD      SP,SP,#+2048
   \   0000023C   0xE8BD4FF0         POP      {R4-R11,LR}
   \   00000240   0xE12FFF1E         BX       LR               ;; return
    637          }
    638          
    639          //------------------------------------------------------------------------------
    640          /// Erase all blocks in the mapped area of nand flash.
    641          /// \param managed  Pointer to a MappedNandFlash instance.
    642          /// \param level    Erase level.
    643          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    644          unsigned char MappedNandFlash_EraseAll(
    645              struct MappedNandFlash *mapped,
    646              unsigned char level)
    647          {
   \                     MappedNandFlash_EraseAll:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    648              unsigned int block;
    649              ManagedNandFlash_EraseAll(MANAGED(mapped), level);
   \   0000000C   0xE1B01005         MOVS     R1,R5
   \   00000010   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000014   0xE1B00004         MOVS     R0,R4
   \   00000018   0x........         BL       ManagedNandFlash_EraseAll
    650              // Reset to no block mapped
    651              if (level > NandEraseDIRTY) {
   \   0000001C   0xE21550FF         ANDS     R5,R5,#0xFF      ;; Zero extend
   \   00000020   0xE3550001         CMP      R5,#+1
   \   00000024   0x3A000015         BCC      ??MappedNandFlash_EraseAll_0
    652                  mapped->logicalMappingBlock = -1;
   \   00000028   0xE3A00034         MOV      R0,#+52
   \   0000002C   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000030   0xE3E01000         MVN      R1,#+0
   \   00000034   0xE18010B4         STRH     R1,[R0, +R4]
    653                  mapped->mappingModified = 0;
   \   00000038   0xE3A00036         MOV      R0,#+54
   \   0000003C   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000040   0xE3A01000         MOV      R1,#+0
   \   00000044   0xE7C01004         STRB     R1,[R0, +R4]
    654                  for (block=0;
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xE1B06000         MOVS     R6,R0
    655                       block < ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(mapped));
   \                     ??MappedNandFlash_EraseAll_1:
   \   00000050   0xE1B00004         MOVS     R0,R4
   \   00000054   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000058   0xE1560000         CMP      R6,R0
   \   0000005C   0x2A000007         BCS      ??MappedNandFlash_EraseAll_0
    656                       block++) {
    657                      mapped->logicalMapping[block] = -1;
   \   00000060   0xE3A00034         MOV      R0,#+52
   \   00000064   0xE3800D40         ORR      R0,R0,#0x1000
   \   00000068   0xE1B01086         LSLS     R1,R6,#+1
   \   0000006C   0xE0911004         ADDS     R1,R1,R4
   \   00000070   0xE3E02000         MVN      R2,#+0
   \   00000074   0xE18020B1         STRH     R2,[R0, +R1]
    658                  }
   \   00000078   0xE2966001         ADDS     R6,R6,#+1
   \   0000007C   0xEAFFFFF3         B        ??MappedNandFlash_EraseAll_1
    659              }
    660              return 0;
   \                     ??MappedNandFlash_EraseAll_0:
   \   00000080   0xE3A00000         MOV      R0,#+0
   \   00000084   0xE8BD4070         POP      {R4-R6,LR}
   \   00000088   0xE12FFF1E         BX       LR               ;; return
    661          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9:
   \   00000000   0x........         DC32     `?<Constant "-I- FindLogicalMappin...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_1:
   \   00000000   0x........         DC32     `?<Constant "-I- Checking LIVE blo...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_2:
   \   00000000   0x........         DC32     `?<Constant "-I- Logical mapping i...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_3:
   \   00000000   0x........         DC32     `?<Constant "-E- FindLogicalMappin...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_4:
   \   00000000   0x........         DC32     `?<Constant "-W- No logical mappin...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_5:
   \   00000000   0x........         DC32     `?<Constant "-I- LoadLogicalMappin...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_6:
   \   00000000   0x........         DC32     `?<Constant "-E- LoadLogicalMappin...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_7:
   \   00000000   0x........         DC32     `?<Constant "-I- Release unmapped ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_8:
   \   00000000   0x........         DC32     `?<Constant "-I- Mark mapped DIRTY...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_9:
   \   00000000   0x........         DC32     `?<Constant "-I- Unmap FREE or BAD...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_10:
   \   00000000   0x........         DC32     `?<Constant "-I- Mapping loaded fr...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_11:
   \   00000000   0x........         DC32     `?<Constant "-I- MappedNandFlash_I...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_12:
   \   00000000   0x........         DC32     `?<Constant "-E- MappedNandFlash_I...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_13:
   \   00000000   0x........         DC32     `?<Constant "-I- MappedNandFlash_R...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_14:
   \   00000000   0x........         DC32     `?<Constant "-I- MappedNandFlash_R...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_15:
   \   00000000   0x........         DC32     `?<Constant "-I- MappedNandFlash_W...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_16:
   \   00000000   0x........         DC32     `?<Constant "-E- MappedNandFlash_W...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_17:
   \   00000000   0x........         DC32     `?<Constant "-I- MappedNandFlash_M...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_18:
   \   00000000   0x........         DC32     `?<Constant "-F- ASSERT: ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_19:
   \   00000000   0x........         DC32     `?<Constant "MappedNandFlash_Map: ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_20:
   \   00000000   0x........         DC32     `?<Constant "MappedNandFlash_Map: ...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_21:
   \   00000000   0x........         DC32     `?<Constant "-I- MappedNandFlash_U...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_22:
   \   00000000   0x........         DC32     `?<Constant "MappedNandFlash_Unmap...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_23:
   \   00000000   0x........         DC32     `?<Constant "MappedNandFlash_Logic...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_24:
   \   00000000   0x........         DC32     `?<Constant "MappedNandFlash_Physi...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_25:
   \   00000000   0x........         DC32     `?<Constant "-I- MappedNandFlash_S...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_26:
   \   00000000   0x........         DC32     `?<Constant "-E- MappedNandFlash_S...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_27:
   \   00000000   0x........         DC32     `?<Constant "-E- MappedNandFlash_S...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable9_28:
   \   00000000   0x........         DC32     `?<Constant "-I- Mapping saved on ...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- FindLogicalMappin...">`:
   \   00000000   0x2D 0x49          DC8 "-I- FindLogicalMappingBlock()~%d\012\015"
   \              0x2D 0x20    
   \              0x46 0x69    
   \              0x6E 0x64    
   \              0x4C 0x6F    
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x4D    
   \              0x61 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x28    
   \              0x29 0x7E    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- Checking LIVE blo...">`:
   \   00000000   0x2D 0x49          DC8 "-I- Checking LIVE block #%d\012\015"
   \              0x2D 0x20    
   \              0x43 0x68    
   \              0x65 0x63    
   \              0x6B 0x69    
   \              0x6E 0x67    
   \              0x20 0x4C    
   \              0x49 0x56    
   \              0x45 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x23 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- Logical mapping i...">`:
   \   00000000   0x2D 0x49          DC8 "-I- Logical mapping in block #%d\012\015"
   \              0x2D 0x20    
   \              0x4C 0x6F    
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x20    
   \              0x6D 0x61    
   \              0x70 0x70    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x69 0x6E    
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x23    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- FindLogicalMappin...">`:
   \   00000000   0x2D 0x45          DC8 2DH, 45H, 2DH, 20H, 46H, 69H, 6EH, 64H
   \              0x2D 0x20    
   \              0x46 0x69    
   \              0x6E 0x64    
   \   00000008   0x4C 0x6F          DC8 4CH, 6FH, 67H, 69H, 63H, 61H, 6CH, 4DH
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x4D    
   \   00000010   0x61 0x70          DC8 61H, 70H, 70H, 69H, 6EH, 67H, 42H, 6CH
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x42 0x6C    
   \   00000018   0x6F 0x63          DC8 6FH, 63H, 6BH, 3AH, 20H, 46H, 61H, 69H
   \              0x6B 0x3A    
   \              0x20 0x46    
   \              0x61 0x69    
   \   00000020   0x6C 0x65          DC8 6CH, 65H, 64H, 20H, 74H, 6FH, 20H, 73H
   \              0x64 0x20    
   \              0x74 0x6F    
   \              0x20 0x73    
   \   00000028   0x63 0x61          DC8 63H, 61H, 6EH, 20H, 62H, 6CH, 6FH, 63H
   \              0x6E 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \   00000030   0x6B 0x20          DC8 6BH, 20H, 23H, 25H, 64H, 0AH, 0DH, 0
   \              0x23 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-W- No logical mappin...">`:
   \   00000000   0x2D 0x57          DC8 "-W- No logical mapping found in device\012\015"
   \              0x2D 0x20    
   \              0x4E 0x6F    
   \              0x20 0x6C    
   \              0x6F 0x67    
   \              0x69 0x63    
   \              0x61 0x6C    
   \              0x20 0x6D    
   \              0x61 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x20 0x66    
   \              0x6F 0x75    
   \              0x6E 0x64    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x64 0x65    
   \              0x76 0x69    
   \              0x63 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- LoadLogicalMappin...">`:
   \   00000000   0x2D 0x49          DC8 "-I- LoadLogicalMapping(B#%d)\012\015"
   \              0x2D 0x20    
   \              0x4C 0x6F    
   \              0x61 0x64    
   \              0x4C 0x6F    
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x4D    
   \              0x61 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x28 0x42    
   \              0x23 0x25    
   \              0x64 0x29    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- LoadLogicalMappin...">`:
   \   00000000   0x2D 0x45          DC8 "-E- LoadLogicalMapping: Failed to load mapping\012\015"
   \              0x2D 0x20    
   \              0x4C 0x6F    
   \              0x61 0x64    
   \              0x4C 0x6F    
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x4D    
   \              0x61 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x20 0x6D    
   \              0x61 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- Release unmapped ...">`:
   \   00000000   0x2D 0x49          DC8 "-I- Release unmapped LIVE #%d\012\015"
   \              0x2D 0x20    
   \              0x52 0x65    
   \              0x6C 0x65    
   \              0x61 0x73    
   \              0x65 0x20    
   \              0x75 0x6E    
   \              0x6D 0x61    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x20 0x4C    
   \              0x49 0x56    
   \              0x45 0x20    
   \              0x23 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- Mark mapped DIRTY...">`:
   \   00000000   0x2D 0x49          DC8 "-I- Mark mapped DIRTY #%d -> LIVE\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x72 0x6B    
   \              0x20 0x6D    
   \              0x61 0x70    
   \              0x70 0x65    
   \              0x64 0x20    
   \              0x44 0x49    
   \              0x52 0x54    
   \              0x59 0x20    
   \              0x23 0x25    
   \              0x64 0x20    
   \              0x2D 0x3E    
   \              0x20 0x4C    
   \              0x49 0x56    
   \              0x45 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- Unmap FREE or BAD...">`:
   \   00000000   0x2D 0x49          DC8 "-I- Unmap FREE or BAD #%d\012\015"
   \              0x2D 0x20    
   \              0x55 0x6E    
   \              0x6D 0x61    
   \              0x70 0x20    
   \              0x46 0x52    
   \              0x45 0x45    
   \              0x20 0x6F    
   \              0x72 0x20    
   \              0x42 0x41    
   \              0x44 0x20    
   \              0x23 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- Mapping loaded fr...">`:
   \   00000000   0x2D 0x49          DC8 "-I- Mapping loaded from block #%d\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x6C 0x6F    
   \              0x61 0x64    
   \              0x65 0x64    
   \              0x20 0x66    
   \              0x72 0x6F    
   \              0x6D 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x23 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- MappedNandFlash_I...">`:
   \   00000000   0x2D 0x49          DC8 "-I- MappedNandFlash_Initialize()\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \              0x7A 0x65    
   \              0x28 0x29    
   \              0x0A 0x0D    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- MappedNandFlash_I...">`:
   \   00000000   0x2D 0x45          DC8 2DH, 45H, 2DH, 20H, 4DH, 61H, 70H, 70H
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \   00000008   0x65 0x64          DC8 65H, 64H, 4EH, 61H, 6EH, 64H, 46H, 6CH
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \   00000010   0x61 0x73          DC8 61H, 73H, 68H, 5FH, 49H, 6EH, 69H, 74H
   \              0x68 0x5F    
   \              0x49 0x6E    
   \              0x69 0x74    
   \   00000018   0x69 0x61          DC8 69H, 61H, 6CH, 69H, 7AH, 65H, 3AH, 20H
   \              0x6C 0x69    
   \              0x7A 0x65    
   \              0x3A 0x20    
   \   00000020   0x49 0x6E          DC8 49H, 6EH, 69H, 74H, 69H, 61H, 6CH, 69H
   \              0x69 0x74    
   \              0x69 0x61    
   \              0x6C 0x69    
   \   00000028   0x7A 0x65          DC8 7AH, 65H, 20H, 64H, 65H, 76H, 69H, 63H
   \              0x20 0x64    
   \              0x65 0x76    
   \              0x69 0x63    
   \   00000030   0x65 0x0A          DC8 65H, 0AH, 0DH, 0
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- MappedNandFlash_R...">`:
   \   00000000   0x2D 0x49          DC8 "-I- MappedNandFlash_ReadPage(LB#%d:P#%d)\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x50 0x61    
   \              0x67 0x65    
   \              0x28 0x4C    
   \              0x42 0x23    
   \              0x25 0x64    
   \              0x3A 0x50    
   \              0x23 0x25    
   \              0x64 0x29    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- MappedNandFlash_R...">_1`:
   \   00000000   0x2D 0x49          DC8 2DH, 49H, 2DH, 20H, 4DH, 61H, 70H, 70H
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \   00000008   0x65 0x64          DC8 65H, 64H, 4EH, 61H, 6EH, 64H, 46H, 6CH
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \   00000010   0x61 0x73          DC8 61H, 73H, 68H, 5FH, 52H, 65H, 61H, 64H
   \              0x68 0x5F    
   \              0x52 0x65    
   \              0x61 0x64    
   \   00000018   0x50 0x61          DC8 50H, 61H, 67H, 65H, 3AH, 20H, 42H, 6CH
   \              0x67 0x65    
   \              0x3A 0x20    
   \              0x42 0x6C    
   \   00000020   0x6F 0x63          DC8 6FH, 63H, 6BH, 20H, 25H, 64H, 20H, 6EH
   \              0x6B 0x20    
   \              0x25 0x64    
   \              0x20 0x6E    
   \   00000028   0x6F 0x74          DC8 6FH, 74H, 20H, 6DH, 61H, 70H, 70H, 65H
   \              0x20 0x6D    
   \              0x61 0x70    
   \              0x70 0x65    
   \   00000030   0x64 0x0A          DC8 64H, 0AH, 0DH, 0
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- MappedNandFlash_W...">`:
   \   00000000   0x2D 0x49          DC8 "-I- MappedNandFlash_WritePage(LB#%d:P#%d)\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x50    
   \              0x61 0x67    
   \              0x65 0x28    
   \              0x4C 0x42    
   \              0x23 0x25    
   \              0x64 0x3A    
   \              0x50 0x23    
   \              0x25 0x64    
   \              0x29 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- MappedNandFlash_W...">`:
   \   00000000   0x2D 0x45          DC8 2DH, 45H, 2DH, 20H, 4DH, 61H, 70H, 70H
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \   00000008   0x65 0x64          DC8 65H, 64H, 4EH, 61H, 6EH, 64H, 46H, 6CH
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \   00000010   0x61 0x73          DC8 61H, 73H, 68H, 5FH, 57H, 72H, 69H, 74H
   \              0x68 0x5F    
   \              0x57 0x72    
   \              0x69 0x74    
   \   00000018   0x65 0x50          DC8 65H, 50H, 61H, 67H, 65H, 3AH, 20H, 42H
   \              0x61 0x67    
   \              0x65 0x3A    
   \              0x20 0x42    
   \   00000020   0x6C 0x6F          DC8 6CH, 6FH, 63H, 6BH, 20H, 6DH, 75H, 73H
   \              0x63 0x6B    
   \              0x20 0x6D    
   \              0x75 0x73    
   \   00000028   0x74 0x20          DC8 74H, 20H, 62H, 65H, 20H, 6DH, 61H, 70H
   \              0x62 0x65    
   \              0x20 0x6D    
   \              0x61 0x70    
   \   00000030   0x70 0x65          DC8 70H, 65H, 64H, 0AH, 0DH, 0
   \              0x64 0x0A    
   \              0x0D 0x00    
   \   00000036   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- MappedNandFlash_M...">`:
   \   00000000   0x2D 0x49          DC8 "-I- MappedNandFlash_Map(LB#%d -> PB#%d)\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x4D 0x61    
   \              0x70 0x28    
   \              0x4C 0x42    
   \              0x23 0x25    
   \              0x64 0x20    
   \              0x2D 0x3E    
   \              0x20 0x50    
   \              0x42 0x23    
   \              0x25 0x64    
   \              0x29 0x0A    
   \              0x0D 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- ASSERT: ">`:
   \   00000000   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "MappedNandFlash_Map: ...">`:
   \   00000000   0x4D 0x61          DC8 "MappedNandFlash_Map: logicalBlock out-of-range\012\015"
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x4D 0x61    
   \              0x70 0x3A    
   \              0x20 0x6C    
   \              0x6F 0x67    
   \              0x69 0x63    
   \              0x61 0x6C    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \              0x6F 0x75    
   \              0x74 0x2D    
   \              0x6F 0x66    
   \              0x2D 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "MappedNandFlash_Map: ...">_1`:
   \   00000000   0x4D 0x61          DC8 "MappedNandFlash_Map: physicalBlock out-of-range\012\015"
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x4D 0x61    
   \              0x70 0x3A    
   \              0x20 0x70    
   \              0x68 0x79    
   \              0x73 0x69    
   \              0x63 0x61    
   \              0x6C 0x42    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x2D 0x6F    
   \              0x66 0x2D    
   \              0x72 0x61    
   \              0x6E 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    
   \   00000032   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- MappedNandFlash_U...">`:
   \   00000000   0x2D 0x49          DC8 "-I- MappedNandFlash_Unmap(LB#%d)\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x55 0x6E    
   \              0x6D 0x61    
   \              0x70 0x28    
   \              0x4C 0x42    
   \              0x23 0x25    
   \              0x64 0x29    
   \              0x0A 0x0D    
   \              0x00         
   \   00000023   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "MappedNandFlash_Unmap...">`:
   \   00000000   0x4D 0x61          DC8 4DH, 61H, 70H, 70H, 65H, 64H, 4EH, 61H
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \   00000008   0x6E 0x64          DC8 6EH, 64H, 46H, 6CH, 61H, 73H, 68H, 5FH
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \   00000010   0x55 0x6E          DC8 55H, 6EH, 6DH, 61H, 70H, 3AH, 20H, 6CH
   \              0x6D 0x61    
   \              0x70 0x3A    
   \              0x20 0x6C    
   \   00000018   0x6F 0x67          DC8 6FH, 67H, 69H, 63H, 61H, 6CH, 42H, 6CH
   \              0x69 0x63    
   \              0x61 0x6C    
   \              0x42 0x6C    
   \   00000020   0x6F 0x63          DC8 6FH, 63H, 6BH, 20H, 6FH, 75H, 74H, 2DH
   \              0x6B 0x20    
   \              0x6F 0x75    
   \              0x74 0x2D    
   \   00000028   0x6F 0x66          DC8 6FH, 66H, 2DH, 72H, 61H, 6EH, 67H, 65H
   \              0x2D 0x72    
   \              0x61 0x6E    
   \              0x67 0x65    
   \   00000030   0x0A 0x0D          DC8 0AH, 0DH, 0
   \              0x00         
   \   00000033   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "MappedNandFlash_Logic...">`:
   \   00000000   0x4D 0x61          DC8 4DH, 61H, 70H, 70H, 65H, 64H, 4EH, 61H
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \   00000008   0x6E 0x64          DC8 6EH, 64H, 46H, 6CH, 61H, 73H, 68H, 5FH
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \   00000010   0x4C 0x6F          DC8 4CH, 6FH, 67H, 69H, 63H, 61H, 6CH, 54H
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x54    
   \   00000018   0x6F 0x50          DC8 6FH, 50H, 68H, 79H, 73H, 69H, 63H, 61H
   \              0x68 0x79    
   \              0x73 0x69    
   \              0x63 0x61    
   \   00000020   0x6C 0x3A          DC8 6CH, 3AH, 20H, 6CH, 6FH, 67H, 69H, 63H
   \              0x20 0x6C    
   \              0x6F 0x67    
   \              0x69 0x63    
   \   00000028   0x61 0x6C          DC8 61H, 6CH, 42H, 6CH, 6FH, 63H, 6BH, 20H
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x20    
   \   00000030   0x6F 0x75          DC8 6FH, 75H, 74H, 2DH, 6FH, 66H, 2DH, 72H
   \              0x74 0x2D    
   \              0x6F 0x66    
   \              0x2D 0x72    
   \   00000038   0x61 0x6E          DC8 61H, 6EH, 67H, 65H, 0AH, 0DH, 0
   \              0x67 0x65    
   \              0x0A 0x0D    
   \              0x00         
   \   0000003F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "MappedNandFlash_Physi...">`:
   \   00000000   0x4D 0x61          DC8 4DH, 61H, 70H, 70H, 65H, 64H, 4EH, 61H
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \   00000008   0x6E 0x64          DC8 6EH, 64H, 46H, 6CH, 61H, 73H, 68H, 5FH
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \   00000010   0x50 0x68          DC8 50H, 68H, 79H, 73H, 69H, 63H, 61H, 6CH
   \              0x79 0x73    
   \              0x69 0x63    
   \              0x61 0x6C    
   \   00000018   0x54 0x6F          DC8 54H, 6FH, 4CH, 6FH, 67H, 69H, 63H, 61H
   \              0x4C 0x6F    
   \              0x67 0x69    
   \              0x63 0x61    
   \   00000020   0x6C 0x3A          DC8 6CH, 3AH, 20H, 70H, 68H, 79H, 73H, 69H
   \              0x20 0x70    
   \              0x68 0x79    
   \              0x73 0x69    
   \   00000028   0x63 0x61          DC8 63H, 61H, 6CH, 42H, 6CH, 6FH, 63H, 6BH
   \              0x6C 0x42    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \   00000030   0x20 0x6F          DC8 20H, 6FH, 75H, 74H, 2DH, 6FH, 66H, 2DH
   \              0x75 0x74    
   \              0x2D 0x6F    
   \              0x66 0x2D    
   \   00000038   0x72 0x61          DC8 72H, 61H, 6EH, 67H, 65H, 0AH, 0DH, 0
   \              0x6E 0x67    
   \              0x65 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- MappedNandFlash_S...">`:
   \   00000000   0x2D 0x49          DC8 "-I- MappedNandFlash_SaveLogicalMapping(B#%d)\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x53 0x61    
   \              0x76 0x65    
   \              0x4C 0x6F    
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x4D    
   \              0x61 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x28 0x42    
   \              0x23 0x25    
   \              0x64 0x29    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- MappedNandFlash_S...">`:
   \   00000000   0x2D 0x45          DC8 2DH, 45H, 2DH, 20H, 4DH, 61H, 70H, 70H
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \   00000008   0x65 0x64          DC8 65H, 64H, 4EH, 61H, 6EH, 64H, 46H, 6CH
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \   00000010   0x61 0x73          DC8 61H, 73H, 68H, 5FH, 53H, 61H, 76H, 65H
   \              0x68 0x5F    
   \              0x53 0x61    
   \              0x76 0x65    
   \   00000018   0x4C 0x6F          DC8 4CH, 6FH, 67H, 69H, 63H, 61H, 6CH, 4DH
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x4D    
   \   00000020   0x61 0x70          DC8 61H, 70H, 70H, 69H, 6EH, 67H, 3AH, 20H
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x3A 0x20    
   \   00000028   0x46 0x61          DC8 46H, 61H, 69H, 6CH, 65H, 64H, 20H, 74H
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \   00000030   0x6F 0x20          DC8 6FH, 20H, 77H, 72H, 69H, 74H, 65H, 20H
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x65 0x20    
   \   00000038   0x6D 0x61          DC8 6DH, 61H, 70H, 70H, 69H, 6EH, 67H, 0AH
   \              0x70 0x70    
   \              0x69 0x6E    
   \              0x67 0x0A    
   \   00000040   0x0D 0x00          DC8 0DH, 0
   \   00000042   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- MappedNandFlash_S...">_1`:
   \   00000000   0x2D 0x45          DC8 2DH, 45H, 2DH, 20H, 4DH, 61H, 70H, 70H
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \   00000008   0x65 0x64          DC8 65H, 64H, 4EH, 61H, 6EH, 64H, 46H, 6CH
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \   00000010   0x61 0x73          DC8 61H, 73H, 68H, 5FH, 53H, 61H, 76H, 65H
   \              0x68 0x5F    
   \              0x53 0x61    
   \              0x76 0x65    
   \   00000018   0x4C 0x6F          DC8 4CH, 6FH, 67H, 69H, 63H, 61H, 6CH, 4DH
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x4D    
   \   00000020   0x61 0x70          DC8 61H, 70H, 70H, 69H, 6EH, 67H, 3AH, 20H
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x3A 0x20    
   \   00000028   0x46 0x61          DC8 46H, 61H, 69H, 6CH, 65H, 64H, 20H, 74H
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \   00000030   0x6F 0x20          DC8 6FH, 20H, 77H, 72H, 69H, 74H, 65H, 20H
   \              0x77 0x72    
   \              0x69 0x74    
   \              0x65 0x20    
   \   00000038   0x70 0x61          DC8 70H, 61H, 74H, 74H, 65H, 72H, 6EH, 0AH
   \              0x74 0x74    
   \              0x65 0x72    
   \              0x6E 0x0A    
   \   00000040   0x0D 0x00          DC8 0DH, 0
   \   00000042   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-I- Mapping saved on ...">`:
   \   00000000   0x2D 0x49          DC8 "-I- Mapping saved on block #%d\012\015"
   \              0x2D 0x20    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x73 0x61    
   \              0x76 0x65    
   \              0x64 0x20    
   \              0x6F 0x6E    
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x20 0x23    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     2088  FindLogicalMappingBlock
             2088 -> ManagedNandFlash_GetDeviceSizeInBlocks
             2088 -> ManagedNandFlash_ReadPage
             2088 -> NandFlashModel_GetPageDataSize
             2088 -> printf
     2096  LoadLogicalMapping
             2096 -> ManagedNandFlash_GetDeviceSizeInBlocks
             2096 -> ManagedNandFlash_ReadPage
             2096 -> ManagedNandFlash_ReleaseBlock
             2096 -> MappedNandFlash_PhysicalToLogical
             2096 -> NandFlashModel_GetPageDataSize
             2096 -> memcpy
             2096 -> min
             2096 -> printf
       16  MappedNandFlash_EraseAll
               16 -> ManagedNandFlash_EraseAll
               16 -> ManagedNandFlash_GetDeviceSizeInBlocks
       88  MappedNandFlash_Initialize
               88 -> FindLogicalMappingBlock
               88 -> LoadLogicalMapping
               88 -> ManagedNandFlash_GetDeviceSizeInBlocks
               88 -> ManagedNandFlash_Initialize
               88 -> printf
       16  MappedNandFlash_LogicalToPhysical
               16 -> ManagedNandFlash_GetDeviceSizeInBlocks
               16 -> printf
       24  MappedNandFlash_Map
               24 -> ManagedNandFlash_AllocateBlock
               24 -> ManagedNandFlash_GetDeviceSizeInBlocks
               24 -> ManagedNandFlash_ReleaseBlock
               24 -> printf
       24  MappedNandFlash_PhysicalToLogical
               24 -> ManagedNandFlash_GetDeviceSizeInBlocks
               24 -> printf
       32  MappedNandFlash_ReadPage
               32 -> ManagedNandFlash_ReadPage
               32 -> printf
     2096  MappedNandFlash_SaveLogicalMapping
             2096 -> ManagedNandFlash_AllocateBlock
             2096 -> ManagedNandFlash_ReleaseBlock
             2096 -> ManagedNandFlash_WritePage
             2096 -> NandFlashModel_GetPageDataSize
             2096 -> memcpy
             2096 -> memset
             2096 -> min
             2096 -> printf
       24  MappedNandFlash_Unmap
               24 -> ManagedNandFlash_GetDeviceSizeInBlocks
               24 -> ManagedNandFlash_ReleaseBlock
               24 -> printf
       32  MappedNandFlash_WritePage
               32 -> ManagedNandFlash_WritePage
               32 -> printf
       16  memcpy
               16 -> __aeabi_memcpy
       16  memset
               16 -> __aeabi_memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      56  ?<Constant "-E- FindLogicalMappin...">
      52  ?<Constant "-E- LoadLogicalMappin...">
      52  ?<Constant "-E- MappedNandFlash_I...">
      68  ?<Constant "-E- MappedNandFlash_S...">
      68  ?<Constant "-E- MappedNandFlash_S...">_1
      56  ?<Constant "-E- MappedNandFlash_W...">
      16  ?<Constant "-F- ASSERT: ">
      32  ?<Constant "-I- Checking LIVE blo...">
      36  ?<Constant "-I- FindLogicalMappin...">
      32  ?<Constant "-I- LoadLogicalMappin...">
      36  ?<Constant "-I- Logical mapping i...">
      36  ?<Constant "-I- MappedNandFlash_I...">
      44  ?<Constant "-I- MappedNandFlash_M...">
      44  ?<Constant "-I- MappedNandFlash_R...">
      52  ?<Constant "-I- MappedNandFlash_R...">_1
      48  ?<Constant "-I- MappedNandFlash_S...">
      36  ?<Constant "-I- MappedNandFlash_U...">
      44  ?<Constant "-I- MappedNandFlash_W...">
      36  ?<Constant "-I- Mapping loaded fr...">
      36  ?<Constant "-I- Mapping saved on ...">
      36  ?<Constant "-I- Mark mapped DIRTY...">
      32  ?<Constant "-I- Release unmapped ...">
      28  ?<Constant "-I- Unmap FREE or BAD...">
      44  ?<Constant "-W- No logical mappin...">
      64  ?<Constant "MappedNandFlash_Logic...">
      52  ?<Constant "MappedNandFlash_Map: ...">
      52  ?<Constant "MappedNandFlash_Map: ...">_1
      64  ?<Constant "MappedNandFlash_Physi...">
      52  ?<Constant "MappedNandFlash_Unmap...">
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_10
       4  ??DataTable9_11
       4  ??DataTable9_12
       4  ??DataTable9_13
       4  ??DataTable9_14
       4  ??DataTable9_15
       4  ??DataTable9_16
       4  ??DataTable9_17
       4  ??DataTable9_18
       4  ??DataTable9_19
       4  ??DataTable9_2
       4  ??DataTable9_20
       4  ??DataTable9_21
       4  ??DataTable9_22
       4  ??DataTable9_23
       4  ??DataTable9_24
       4  ??DataTable9_25
       4  ??DataTable9_26
       4  ??DataTable9_27
       4  ??DataTable9_28
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
       4  ??DataTable9_6
       4  ??DataTable9_7
       4  ??DataTable9_8
       4  ??DataTable9_9
     448  FindLogicalMappingBlock
     588  LoadLogicalMapping
     140  MappedNandFlash_EraseAll
     420  MappedNandFlash_Initialize
      92  MappedNandFlash_LogicalToPhysical
     348  MappedNandFlash_Map
     196  MappedNandFlash_PhysicalToLogical
     188  MappedNandFlash_ReadPage
     580  MappedNandFlash_SaveLogicalMapping
     240  MappedNandFlash_Unmap
     176  MappedNandFlash_WritePage
      44  memcpy
      44  memset

 
 1 304 bytes in section .rodata
 3 620 bytes in section .text
 
 3 532 bytes of CODE  memory (+ 88 bytes shared)
 1 304 bytes of CONST memory

Errors: none
Warnings: none
