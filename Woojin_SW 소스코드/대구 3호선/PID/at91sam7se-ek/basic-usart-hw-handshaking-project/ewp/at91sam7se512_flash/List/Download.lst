###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     06/Apr/2015  18:37:28 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\Down #
#                    load.c                                                   #
#    Command line =  "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\Down #
#                    load.c" -D at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC   #
#                    "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내           #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\List\" --remarks --diag_suppress     #
#                    Pe826,Pe1375 -o "C:\Users\jang                           #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_ #
#                    flash\Obj\" --no_cse --no_unroll --no_inline             #
#                    --no_code_motion --no_tbaa --no_clustering               #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/peripherals\" -I "C:\Users\jang         #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib/memories\" -I "C:\Users\jang                          #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib\" -I "C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내   #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    ..\..\..\at91lib/components\" -I "C:\Users\jang          #
#                    duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구            #
#                    모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se- #
#                    ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91l #
#                    ib/boards/at91sam7se-ek\" --interwork --cpu_mode arm     #
#                    -On --use_c++_inline                                     #
#    List file    =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\List\Download.lst                    #
#    Object file  =  C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내            #
#                    프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_L #
#                    ED\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\ #
#                    at91sam7se512_flash\Obj\Download.o                       #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c
      1          #include <stdio.h>
      2          #include "Download.h"

  #endif
        ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\main.h",44  Remark[Pe001]: 
          last line of file ends without a newline

  #endif
        ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.h",32  Remark[Pe001]: 
          last line of file ends without a newline
      3          #include "LED_Display.h"

  #endif
        ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\UART.h",43  Remark[Pe001]: 
          last line of file ends without a newline

  #endif
        ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\LED_Display.h",121  Remark[Pe001]: 
          last line of file ends without a newline
      4          #include "main.h"
      5          #include "UART.h"
      6          #include <board.h>
      7          #include <usart/usart.h>
      8          #include <memories/norflash/NorFlashCFI.h>
      9          #include <memories/norflash/NorFlashApi.h>
     10          
     11          #define VERSION 0x10 // 버젼
     12          
     13          #define SCC_DOWNLOAD_CODE 0x13 // 다운로드 하기
     14          #define SCC_ERASE_CODE 0x01 // Flash 메모리 지우기
     15          #define SCC_DOWNLOAD_START_CODE 0x1F // 다운로드를 시작한다.
     16          #define SCC_STATUS_REQ 0x07 // 상태요구
     17          #define SCC_STATUS_RLY 0x08 // 상태요구응답
     18          
     19          #define TX_ENABLE_TIME 20 // 데이터를 전송하기전에 지연시간
     20          #define TX_DISABLE_TIME 5 // 데이터를 전송후 지연시간
     21          
     22          #define IDD 0xF1 // 차내
     23          #define FDD 0xF5 // 정면
     24          #define SDD 0xF6 // 측면
     25          #define TN  0xF7 // 열번
     26          #define LDD 0xF9 // 노선
     27          #define HDD 0xF4 // 호차
     28          
     29          #define IS_IDD_NO(x) (x >= 1 && x <= 4)
     30          #define IS_FDD_NO(x) (x == 0x0F)
     31          #define IS_SDD_NO(x) (x == 0x0A || x == 0x0B)
     32          #define IS_TN_NO(x) (x == 0x0D)
     33          #define IS_LDD_NO(x) (x >= 5 && x <= 8)
     34          #define IS_HDD_NO(x) (x == 0x09 || x == 0x0E)
     35          
     36          #define MEMORY_ERASE_OK 0x10 // 메모리 ERASE OK
     37          #define MEMORY_ERASE_NG 0x11 // 메모리 ERASE NG
     38          
     39          #define OK 0 // OK
     40          #define NG 1 // NG
     41          
     42          #define MEM_RECORD_SIZE 128 // 다운로드시 한 레코드 크기
     43          
     44          #define FIRMWARE_EXECUTION_TIME 10000 // 2000ms
     45          
     46          #define SCREEN_CENTER_POS ((SCREEN_WIDTH_MAX / 2)-16)
     47          

   \                                 In section .bss, align 4
     48          int mBlackChick[100]; // 삭제 블럭 사이즈 리턴.
   \                     mBlackChick:
   \   00000000                      DS8 400

   \                                 In section .bss, align 4
     49          int mBlockSize = 0;
   \                     mBlockSize:
   \   00000000                      DS8 4
     50          
     51          

   \                                 In section .data, align 4
     52          DWORD gVerName[16]=
   \                     gVerName:
   \   00000000   0x00000000         DC32 0, 262148, 545537924, 545522748, 545524228, 545526020, 1065619716
   \              0x00040004   
   \              0x20843F84   
   \              0x2084043C   
   \              0x20840A04   
   \              0x20841104   
   \              0x3F841104   
   \   0000001C   0x20BC20BC         DC32 549200060, 545529988, 545521668, 545521664, 545529856, 545529856
   \              0x20842084   
   \              0x20840004   
   \              0x20840000   
   \              0x20842000   
   \              0x20842000   
   \   00000034   0x3F842000         DC32 1065623552, 278524, 0
   \              0x00043FFC   
   \              0x00000000   
     53          {
     54          	0x00000000,
     55          	0x00040004,
     56          	0x20843F84,
     57          	0x2084043C,
     58          	0x20840A04,
     59          	0x20841104,
     60          	0x3F841104,
     61          	0x20BC20BC,
     62          	0x20842084,
     63          	0x20840004,
     64          	0x20840000,
     65          	0x20842000,
     66          	0x20842000,
     67          	0x3F842000,
     68          	0x00043FFC,
     69          	0x00000000
     70          };
     71          

   \                                 In section .data, align 4
     72          UCHAR gDigitName[16*16]=
   \                     gDigitName:
   \   00000000   0x00 0x00          DC8 0, 0, 124, 98, 99, 115, 123, 123, 111, 103, 103, 99, 35, 31, 0, 0
   \              0x7C 0x62    
   \              0x63 0x73    
   \              0x7B 0x7B    
   \              0x6F 0x67    
   \              0x67 0x63    
   \              0x23 0x1F    
   \              0x00 0x00    
   \   00000010   0x00 0x00          DC8 0, 0, 24, 60, 108, 12, 12, 12, 12, 12, 12, 12, 12, 12, 0, 0, 0, 0
   \              0x18 0x3C    
   \              0x6C 0x0C    
   \              0x0C 0x0C    
   \              0x0C 0x0C    
   \              0x0C 0x0C    
   \              0x0C 0x0C    
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000022   0x7C 0x62          DC8 124, 98, 99, 99, 103, 14, 28, 56, 112, 96, 96, 127, 0, 0, 0, 0, 124
   \              0x63 0x63    
   \              0x67 0x0E    
   \              0x1C 0x38    
   \              0x70 0x60    
   \              0x60 0x7F    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x7C         
   \   00000033   0x62 0x63          DC8 98, 99, 3, 3, 30, 3, 3, 99, 99, 35, 31, 0, 0, 0, 0, 24, 60, 102
   \              0x03 0x03    
   \              0x1E 0x03    
   \              0x03 0x63    
   \              0x63 0x23    
   \              0x1F 0x00    
   \              0x00 0x00    
   \              0x00 0x18    
   \              0x3C 0x66    
   \   00000045   0x66 0x66          DC8 102, 102, 102, 102, 102, 102, 127, 6, 6, 0, 0, 0, 0, 126, 96, 96
   \              0x66 0x66    
   \              0x66 0x66    
   \              0x7F 0x06    
   \              0x06 0x00    
   \              0x00 0x00    
   \              0x00 0x7E    
   \              0x60 0x60    
   \   00000055   0x60 0x60          DC8 96, 96, 127, 3, 3, 99, 99, 35, 31, 0, 0, 0, 0, 124, 98, 99, 96, 96
   \              0x7F 0x03    
   \              0x03 0x63    
   \              0x63 0x23    
   \              0x1F 0x00    
   \              0x00 0x00    
   \              0x00 0x7C    
   \              0x62 0x63    
   \              0x60 0x60    
   \   00000067   0x7F 0x63          DC8 127, 99, 99, 99, 99, 35, 31, 0, 0, 0, 0, 124, 2, 3, 3, 3, 3, 3, 3
   \              0x63 0x63    
   \              0x63 0x23    
   \              0x1F 0x00    
   \              0x00 0x00    
   \              0x00 0x7C    
   \              0x02 0x03    
   \              0x03 0x03    
   \              0x03 0x03    
   \              0x03         
   \   0000007A   0x03 0x03          DC8 3, 3, 3, 3, 0, 0, 0, 0, 124, 98, 99, 99, 99, 62, 99, 99, 99, 99, 35
   \              0x03 0x03    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x7C 0x62    
   \              0x63 0x63    
   \              0x63 0x3E    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x23         
   \   0000008D   0x1F 0x00          DC8 31, 0, 0, 0, 0, 124, 98, 99, 99, 99, 99, 127, 3, 3, 99, 35, 31, 0
   \              0x00 0x00    
   \              0x00 0x7C    
   \              0x62 0x63    
   \              0x63 0x63    
   \              0x63 0x7F    
   \              0x03 0x03    
   \              0x63 0x23    
   \              0x1F 0x00    
   \   0000009F   0x00 0x00          DC8 0, 0, 0, 124, 102, 99, 99, 99, 99, 127, 99, 99, 99, 99, 99, 0, 0, 0
   \              0x00 0x7C    
   \              0x66 0x63    
   \              0x63 0x63    
   \              0x63 0x7F    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x63 0x00    
   \              0x00 0x00    
   \   000000B1   0x00 0x78          DC8 0, 120, 108, 108, 108, 108, 127, 99, 99, 99, 99, 99, 127, 0, 0, 0
   \              0x6C 0x6C    
   \              0x6C 0x6C    
   \              0x7F 0x63    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x7F 0x00    
   \              0x00 0x00    
   \   000000C1   0x00 0x7C          DC8 0, 124, 102, 99, 97, 96, 96, 96, 96, 96, 96, 96, 127, 0, 0, 0, 0
   \              0x66 0x63    
   \              0x61 0x60    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x7F 0x00    
   \              0x00 0x00    
   \              0x00         
   \   000000D2   0x78 0x6C          DC8 120, 108, 102, 99, 99, 99, 99, 99, 99, 99, 99, 127, 0, 0, 0, 0, 124
   \              0x66 0x63    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x63 0x63    
   \              0x63 0x7F    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x7C         
   \   000000E3   0x60 0x60          DC8 96, 96, 96, 96, 126, 96, 96, 96, 96, 96, 127, 0, 0, 0, 0, 124, 96
   \              0x60 0x60    
   \              0x7E 0x60    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x7F 0x00    
   \              0x00 0x00    
   \              0x00 0x7C    
   \              0x60         
   \   000000F4   0x60 0x60          DC8 96, 96, 96, 126, 96, 96, 96, 96, 96, 96, 0, 0
   \              0x60 0x7E    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x60 0x60    
   \              0x00 0x00    
     73          {
     74          	0x00,0x00,0x7C,0x62,0x63,0x73,0x7B,0x7B,0x6F,0x67,0x67,0x63,0x23,0x1F,0x00,0x00,
     75          	0x00,0x00,0x18,0x3C,0x6C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x00,0x00,
     76          	0x00,0x00,0x7C,0x62,0x63,0x63,0x67,0x0E,0x1C,0x38,0x70,0x60,0x60,0x7F,0x00,0x00,
     77          	0x00,0x00,0x7C,0x62,0x63,0x03,0x03,0x1E,0x03,0x03,0x63,0x63,0x23,0x1F,0x00,0x00,
     78          	0x00,0x00,0x18,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x7F,0x06,0x06,0x00,0x00,
     79          	0x00,0x00,0x7E,0x60,0x60,0x60,0x60,0x7F,0x03,0x03,0x63,0x63,0x23,0x1F,0x00,0x00,
     80          	0x00,0x00,0x7C,0x62,0x63,0x60,0x60,0x7F,0x63,0x63,0x63,0x63,0x23,0x1F,0x00,0x00,
     81          	0x00,0x00,0x7C,0x02,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x03,0x00,0x00,
     82          	0x00,0x00,0x7C,0x62,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x23,0x1F,0x00,0x00,
     83          	0x00,0x00,0x7C,0x62,0x63,0x63,0x63,0x63,0x7F,0x03,0x03,0x63,0x23,0x1F,0x00,0x00,
     84          	0x00,0x00,0x7C,0x66,0x63,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x63,0x63,0x00,0x00,
     85          	0x00,0x00,0x78,0x6C,0x6C,0x6C,0x6C,0x7F,0x63,0x63,0x63,0x63,0x63,0x7F,0x00,0x00,
     86          	0x00,0x00,0x7C,0x66,0x63,0x61,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7F,0x00,0x00,
     87          	0x00,0x00,0x78,0x6C,0x66,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x7F,0x00,0x00,
     88          	0x00,0x00,0x7C,0x60,0x60,0x60,0x60,0x7E,0x60,0x60,0x60,0x60,0x60,0x7F,0x00,0x00,
     89          	0x00,0x00,0x7C,0x60,0x60,0x60,0x60,0x7E,0x60,0x60,0x60,0x60,0x60,0x60,0x00,0x00
     90          };
     91          
     92          
     93          extern SCC_INIT_SHAPE SCC1_Init_AChl; // 85C30의 송수신 버퍼 및 플래그
     94          extern struct NorFlash norFlash;
     95          
     96          extern int mScanVidioFlag;
     97          /***********************************************************************
     98          	변수 정의
     99          ************************************************************************/
    100          //int glDebugCnt = 0;
    101          
    102          typedef struct
    103          {
    104          	int nComm;
    105          	int nErase;
    106          	int nDownload;
    107          } STATUS_FLAG;
    108          

   \                                 In section .bss, align 4
    109          int gTxEnableTimerCnt = 0; // 전송하기전 몇 ms는 기다림
   \                     gTxEnableTimerCnt:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    110          int gTxDisableTimerCnt = 0; // 전송후 몇 ms 기다리고 RTS닫음
   \                     gTxDisableTimerCnt:
   \   00000000                      DS8 4
    111          

   \                                 In section .bss, align 4
    112          int gVersionPrintFlag = FALSE;
   \                     gVersionPrintFlag:
   \   00000000                      DS8 4
    113          

   \                                 In section .data, align 4
    114          int SCREEN_WIDTH_MAX = 128; // 가로 쩜의 갯수
   \                     SCREEN_WIDTH_MAX:
   \   00000000   0x00000080         DC32 128
    115          

   \                                 In section .bss, align 4
    116          int gFirmWareExeTime = 0;
   \                     gFirmWareExeTime:
   \   00000000                      DS8 4

   \                                 In section .data, align 4
    117          int gFirmWareExeFlag = TRUE;
   \                     gFirmWareExeFlag:
   \   00000000   0x00000001         DC32 1
    118          

   \                                 In section .bss, align 4
    119          UINT gERASE_OkFlag = 0;
   \                     gERASE_OkFlag:
   \   00000000                      DS8 4
    120          
    121          
    122          

   \                                 In section .text, align 4, keep-with-next
    123          void Download_Init(void)
    124          {
    125          
    126          }
   \                     Download_Init:
   \   00000000   0xE12FFF1E         BX       LR               ;; return
    127          /***********************************************************************
    128          	메인 프로그램
    129          ************************************************************************/
    130          

   \                                 In section .text, align 4, keep-with-next
    131          void Download_main(void)
    132          {
   \                     Download_main:
   \   00000000   0xE92D4FF0         PUSH     {R4-R11,LR}
   \   00000004   0xE24DD0DC         SUB      SP,SP,#+220
    133          	int i,j,blockSize,pageSize;
    134          	UINT nLen;
    135          	UINT nCrc;
    136          	int nOkPtcCnt;
    137          	int nOkPtcOldCnt;
    138          	UCHAR pText[200];
    139          	UCHAR *pNorFlshAddr = (UCHAR *)(BOARD_NORFLASH_ADDR);
   \   00000008   0xE3A08540         MOV      R8,#+268435456
    140          	UCHAR *pNorFlshProgAddr = (UCHAR *)(BOARD_NORFLASH_ADDR + 0x3C0000);
   \   0000000C   0xE3A09540         MOV      R9,#+268435456
   \   00000010   0xE38999F0         ORR      R9,R9,#0x3C0000
    141          	UCHAR *pVideoMem = (UCHAR *)DOT_VIDEO_DATA;
   \   00000014   0xE3E0A4DF         MVN      R10,#-553648128
   \   00000018   0xE3CAA8FE         BIC      R10,R10,#0xFE0000
    142          
    143          	UINT nFlshWrAddr;
    144                  
    145                  /*
    146          	ScreenWidth();
    147                  VersionImagePut();
    148          
    149          	//memset(&pVideoMem[0],NG,512*1024); // Erase&Program 상태 NG 초기화
    150          	
    151          	
    152          	//nOkPtcCnt = nOkPtcOldCnt = 0;
    153          	
    154          	//gFirmWareExeTime = 0; // 2초 안에 다운로드 시작 프로토콜이 안들어오면 표시기 Firmware 수행
    155          	//gFirmWareExeFlag = TRUE;
    156          
    157          
    158          	// 처음엔 버젼을 출력하지않는다.
    159          	//gVersionPrintFlag = FALSE;
    160          	// 다운로드 준비이면 화면에 버젼을 출력한다.
    161          	//VersionImagePut();
    162          
    163          	//while(SCC1_Init_AChl.RxDownloadStart)
    164          	//{
    165          
    166          		/*
                 		^
Warning[Pe009]: nested comment is not allowed
    167          		if((gFirmWareExeTime >= FIRMWARE_EXECUTION_TIME) && (gFirmWareExeFlag == TRUE))
    168          		{
    169          			
    170          			if((WORD_L(pNorFlshProgAddr[0]) != 0xFF)) // 프로그램 영역이 전부 지워졌다면 수행하지 않는다.
    171          			{
    172          				// Video Memory에 전송되어진 데이터를 0x00를 쓴다.
    173          				memset(DOT_VIDEO,0x00,0x1000);
    174                                          SCC1_Init_AChl.RxDownloadStart = FALSE;
    175          	
    176          			}			
    177          		}
    178          
    179                  */
    180          		// 전부 수신되었다면..
    181          		if(SCC1_Init_AChl.RxOK == TRUE)
   \   0000001C   0x........         LDR      R0,??DataTable5
   \   00000020   0xE5900018         LDR      R0,[R0, #+24]
   \   00000024   0xE3500001         CMP      R0,#+1
   \   00000028   0x1A0000D5         BNE      ??Download_main_0
    182          		{
    183                                  TC_Stop(AT91C_BASE_TC1);
                                         ^
Warning[Pe223]: function "TC_Stop" declared implicitly
   \   0000002C   0x........         LDR      R0,??DataTable5_1  ;; 0xfffa0040
   \   00000030   0x........         BL       TC_Stop
    184                                  
    185          			SCC1_Init_AChl.RxOK = FALSE;			
   \   00000034   0x........         LDR      R0,??DataTable5
   \   00000038   0xE3A01000         MOV      R1,#+0
   \   0000003C   0xE5801018         STR      R1,[R0, #+24]
    186          			
    187          			//pText = &SCC1_Init_AChl.pRxBufferBackup[7]; 
    188                                  
    189                                  memcpy(pText,&SCC1_Init_AChl.pRxBufferBackup[7],SCC1_Init_AChl.RxOKDataLen+3);
                                         ^
Warning[Pe223]: function "memcpy" declared implicitly

  	int i,j,blockSize,pageSize;
  	      ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",133  Warning[Pe177]: 
          variable "j" was declared but never referenced

  	int i,j,blockSize,pageSize;
  	                  ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",133  Warning[Pe550]: 
          variable "pageSize" was set but never used

  	UINT nLen;
  	     ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",134  Warning[Pe177]: 
          variable "nLen" was declared but never referenced

  	UINT nCrc;
  	     ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",135  Warning[Pe177]: 
          variable "nCrc" was declared but never referenced

  	int nOkPtcCnt;
  	    ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",136  Warning[Pe550]: 
          variable "nOkPtcCnt" was set but never used

  	UCHAR *pNorFlshProgAddr = (UCHAR *)(BOARD_NORFLASH_ADDR + 0x3C0000);
  	       ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",140  Warning[Pe177]: 
          variable "pNorFlshProgAddr" was declared but never referenced
   \   00000040   0x........         LDR      R0,??DataTable5
   \   00000044   0xE5900020         LDR      R0,[R0, #+32]
   \   00000048   0xE2902003         ADDS     R2,R0,#+3
   \   0000004C   0x........         LDR      R0,??DataTable5
   \   00000050   0xE5900030         LDR      R0,[R0, #+48]
   \   00000054   0xE2901007         ADDS     R1,R0,#+7
   \   00000058   0xE28D0010         ADD      R0,SP,#+16
   \   0000005C   0x........         BL       memcpy
    190          				
    191          			// 통신을 받을때마다 LED를 하나씩 켠다.
    192                                  /*
    193          			switch(pText[2])
    194          			{
    195          			case SCC_DOWNLOAD_START_CODE:
    196          			case SCC_ERASE_CODE:
    197          			case SCC_DOWNLOAD_CODE:				
    198          				if(IsDisplayAddressOk(pText[0]) == FALSE) break; // 원하는 표시기 종류가 아니면 리턴
    199          
    200          				PixelPut(SCREEN_CENTER_POS + nOkPtcOldCnt%32,nOkPtcOldCnt/32 + 16,0);
    201          				nOkPtcOldCnt = nOkPtcCnt;
    202          					
    203          				PixelPut(SCREEN_CENTER_POS + nOkPtcCnt%32,nOkPtcCnt/32 + 16,3);
    204          				nOkPtcCnt = (nOkPtcCnt + 1) % (32*16);
    205          				break;
    206          					
    207          			case SCC_STATUS_REQ:
    208          				if((UCHAR )ADD_CHECK() != pText[0]) break;// 나의 상태를 요구하는것인지 체크
    209          				
    210          				PixelPut(SCREEN_CENTER_POS + nOkPtcOldCnt%32,nOkPtcOldCnt/32 + 16,0);
    211          				nOkPtcOldCnt = nOkPtcCnt;
    212          					
    213          				PixelPut(SCREEN_CENTER_POS + nOkPtcCnt%32,nOkPtcCnt/32 + 16,3);
    214          				nOkPtcCnt = (nOkPtcCnt + 1) % (32*16);
    215          				break;
    216          			}
    217                                  */
    218          				
    219          							
    220          			// Text의 위치를 가르킨다.				
    221          			switch(pText[2])
   \   00000060   0xE5DD0012         LDRB     R0,[SP, #+18]
   \   00000064   0xE3500001         CMP      R0,#+1
   \   00000068   0x0A00002F         BEQ      ??Download_main_1
   \   0000006C   0xE3500007         CMP      R0,#+7
   \   00000070   0x0A0000B4         BEQ      ??Download_main_2
   \   00000074   0xE3500008         CMP      R0,#+8
   \   00000078   0x0A0000C0         BEQ      ??Download_main_3
   \   0000007C   0xE3500013         CMP      R0,#+19
   \   00000080   0x0A000066         BEQ      ??Download_main_4
   \   00000084   0xE350001F         CMP      R0,#+31
   \   00000088   0x1A0000BD         BNE      ??Download_main_5
    222          			{
    223          			// 다운로드 시작.
    224          			case SCC_DOWNLOAD_START_CODE:
    225                                    
    226          
    227          				if(IsDisplayAddressOk(pText[0]) == FALSE) break; // 원하는 표시기 종류가 아니면 리턴
   \                     ??Download_main_6:
   \   0000008C   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000090   0x........         BL       IsDisplayAddressOk
   \   00000094   0xE3500000         CMP      R0,#+0
   \   00000098   0x0A0000B9         BEQ      ??Download_main_0
    228          
    229                                          mBlockSize =0; // 
   \                     ??Download_main_7:
   \   0000009C   0x........         LDR      R0,??DataTable5_2
   \   000000A0   0xE3A01000         MOV      R1,#+0
   \   000000A4   0xE5801000         STR      R1,[R0, #+0]
    230          
    231          				nOkPtcCnt = nOkPtcOldCnt = 0;
   \   000000A8   0xE3A00000         MOV      R0,#+0
   \   000000AC   0xE1B07000         MOVS     R7,R0
   \   000000B0   0xE58D0008         STR      R0,[SP, #+8]
    232          				PixelPut(SCREEN_CENTER_POS + nOkPtcOldCnt%32,nOkPtcOldCnt/32 + 16,0);
   \   000000B4   0xE3A02000         MOV      R2,#+0
   \   000000B8   0xE1B04002         MOVS     R4,R2
   \   000000BC   0xE1B00007         MOVS     R0,R7
   \   000000C0   0xE3A01020         MOV      R1,#+32
   \   000000C4   0x........         BL       __aeabi_idiv
   \   000000C8   0xE2901010         ADDS     R1,R0,#+16
   \   000000CC   0xE1B02004         MOVS     R2,R4
   \   000000D0   0xE58D1000         STR      R1,[SP, #+0]
   \   000000D4   0xE58D2004         STR      R2,[SP, #+4]
   \   000000D8   0x........         LDR      R0,??DataTable5_3
   \   000000DC   0xE5900000         LDR      R0,[R0, #+0]
   \   000000E0   0xE3A01002         MOV      R1,#+2
   \   000000E4   0x........         BL       __aeabi_idiv
   \   000000E8   0xE1B04000         MOVS     R4,R0
   \   000000EC   0xE1B00007         MOVS     R0,R7
   \   000000F0   0xE3A01020         MOV      R1,#+32
   \   000000F4   0x........         BL       __aeabi_idivmod
   \   000000F8   0xE0910004         ADDS     R0,R1,R4
   \   000000FC   0xE2500010         SUBS     R0,R0,#+16
   \   00000100   0xE59D2004         LDR      R2,[SP, #+4]
   \   00000104   0xE59D1000         LDR      R1,[SP, #+0]
   \   00000108   0x........         BL       PixelPut
    233          
    234          				gFirmWareExeFlag = FALSE; // 2초후 자동으로 수행하지 못하도록 한다.
   \   0000010C   0x........         LDR      R0,??DataTable5_4
   \   00000110   0xE3A01000         MOV      R1,#+0
   \   00000114   0xE5801000         STR      R1,[R0, #+0]
    235          					
    236          				VersionImagePut();
   \   00000118   0x........         BL       VersionImagePut
    237          				gVersionPrintFlag = IsPrintOfVersion();
   \   0000011C   0x........         BL       IsPrintOfVersion
   \   00000120   0x........         LDR      R1,??DataTable5_5
   \   00000124   0xE5810000         STR      R0,[R1, #+0]
    238          				break;
   \   00000128   0xEA000095         B        ??Download_main_0
    239          					
    240          			// 특정 메모리를 지움.
    241          			case SCC_ERASE_CODE:
    242          				if(IsDisplayAddressOk(pText[0]) == FALSE) break; // 원하는 표시기 종류가 아니면 리턴
   \                     ??Download_main_1:
   \   0000012C   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000130   0x........         BL       IsDisplayAddressOk
   \   00000134   0xE3500000         CMP      R0,#+0
   \   00000138   0x0A000091         BEQ      ??Download_main_0
    243          				
    244                                          blockSize =  NorFlash_GetDeviceBlockSize(&(norFlash.norFlashInfo), (UINT)WORD_L(pText[5])); // 현재 블럭 사이즈를 리턴한다.
   \                     ??Download_main_8:
   \   0000013C   0xE5DD1015         LDRB     R1,[SP, #+21]
   \   00000140   0x........         LDR      R0,??DataTable5_6
   \   00000144   0x........         BL       NorFlash_GetDeviceBlockSize
   \   00000148   0xE1B06000         MOVS     R6,R0
    245                                          
    246                                          pageSize = NorFlash_GetDeviceNumOfBlocks(&(norFlash.norFlashInfo)); // 전체 블럭 사이즈를 지정
   \   0000014C   0x........         LDR      R0,??DataTable5_6
   \   00000150   0x........         BL       NorFlash_GetDeviceNumOfBlocks
   \   00000154   0xE58D000C         STR      R0,[SP, #+12]
    247                                          
    248                                          
    249                                          for(i=0;i<(65536/blockSize);i++)
   \   00000158   0xE3A00000         MOV      R0,#+0
   \   0000015C   0xE1B05000         MOVS     R5,R0
   \                     ??Download_main_9:
   \   00000160   0xE3A00B40         MOV      R0,#+65536
   \   00000164   0xE1B01006         MOVS     R1,R6
   \   00000168   0x........         BL       __aeabi_idiv
   \   0000016C   0xE1550000         CMP      R5,R0
   \   00000170   0xAA000012         BGE      ??Download_main_10
    250                                          {
    251                                                  NORFLASH_EraseSector(&norFlash, NorFlash_GetDeviceSectorAddress(&(norFlash.norFlashInfo),mBlockSize));
   \   00000174   0x........         LDR      R0,??DataTable5_2
   \   00000178   0xE5901000         LDR      R1,[R0, #+0]
   \   0000017C   0x........         LDR      R0,??DataTable5_6
   \   00000180   0x........         BL       NorFlash_GetDeviceSectorAddress
   \   00000184   0xE1B01000         MOVS     R1,R0
   \   00000188   0x........         LDR      R0,??DataTable5_7
   \   0000018C   0x........         BL       NORFLASH_EraseSector
    252                                                  mBlackChick[mBlockSize] = blockSize;
   \   00000190   0x........         LDR      R0,??DataTable5_2
   \   00000194   0xE5900000         LDR      R0,[R0, #+0]
   \   00000198   0xE1B00100         LSLS     R0,R0,#+2
   \   0000019C   0x........         LDR      R1,??DataTable5_8
   \   000001A0   0xE7806001         STR      R6,[R0, +R1]
    253                                                  mBlockSize++;
   \   000001A4   0x........         LDR      R0,??DataTable5_2
   \   000001A8   0xE5900000         LDR      R0,[R0, #+0]
   \   000001AC   0xE2900001         ADDS     R0,R0,#+1
   \   000001B0   0x........         LDR      R1,??DataTable5_2
   \   000001B4   0xE5810000         STR      R0,[R1, #+0]
    254                                          }
   \   000001B8   0xE2955001         ADDS     R5,R5,#+1
   \   000001BC   0xEAFFFFE7         B        ??Download_main_9
    255          
    256          				// 메모리를 소거했으므로 소거된 부분의 다운로드 플래그는 NG시킨다.
    257          				for(i=0;i<(pText[5]*64*1024)/MEM_RECORD_SIZE;i++)
   \                     ??Download_main_10:
   \   000001C0   0xE3A00000         MOV      R0,#+0
   \   000001C4   0xE1B05000         MOVS     R5,R0
   \                     ??Download_main_11:
   \   000001C8   0xE5DD0015         LDRB     R0,[SP, #+21]
   \   000001CC   0xE1B00800         LSLS     R0,R0,#+16
   \   000001D0   0xE3A01080         MOV      R1,#+128
   \   000001D4   0x........         BL       __aeabi_idiv
   \   000001D8   0xE1550000         CMP      R5,R0
   \   000001DC   0xAA000008         BGE      ??Download_main_12
    258          				{
    259          					pVideoMem[(pText[5]*64*1024)/MEM_RECORD_SIZE + i] = NG;
   \   000001E0   0xE5DD0015         LDRB     R0,[SP, #+21]
   \   000001E4   0xE1B00800         LSLS     R0,R0,#+16
   \   000001E8   0xE3A01080         MOV      R1,#+128
   \   000001EC   0x........         BL       __aeabi_idiv
   \   000001F0   0xE0950000         ADDS     R0,R5,R0
   \   000001F4   0xE3A01001         MOV      R1,#+1
   \   000001F8   0xE7C0100A         STRB     R1,[R0, +R10]
    260          				}
   \   000001FC   0xE2955001         ADDS     R5,R5,#+1
   \   00000200   0xEAFFFFF0         B        ??Download_main_11
    261          
    262          				gFirmWareExeFlag = FALSE; // 2초후 자동으로 수행하지 못하도록 한다.
   \                     ??Download_main_12:
   \   00000204   0x........         LDR      R0,??DataTable5_4
   \   00000208   0xE3A01000         MOV      R1,#+0
   \   0000020C   0xE5801000         STR      R1,[R0, #+0]
    263          
    264          				gVersionPrintFlag = IsPrintOfVersion();
   \   00000210   0x........         BL       IsPrintOfVersion
   \   00000214   0x........         LDR      R1,??DataTable5_5
   \   00000218   0xE5810000         STR      R0,[R1, #+0]
    265                                          
    266          				break;
   \   0000021C   0xEA000058         B        ??Download_main_0
    267          				
    268          			// 데이터를 다운로드.
    269          			case SCC_DOWNLOAD_CODE:	
    270          				if(IsDisplayAddressOk(pText[0]) == FALSE) break; // 원하는 표시기 종류가 아니면 리턴
   \                     ??Download_main_4:
   \   00000220   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   00000224   0x........         BL       IsDisplayAddressOk
   \   00000228   0xE3500000         CMP      R0,#+0
   \   0000022C   0x0A000054         BEQ      ??Download_main_0
    271          
    272          				nFlshWrAddr = MAKE_WORD(pText[4],pText[5]);
   \                     ??Download_main_13:
   \   00000230   0xE5DD0014         LDRB     R0,[SP, #+20]
   \   00000234   0xE5DD1015         LDRB     R1,[SP, #+21]
   \   00000238   0xE1910400         ORRS     R0,R1,R0, LSL #+8
   \   0000023C   0xE1B0B000         MOVS     R11,R0
    273          	
    274                                          
    275          				// 전부 지워졌는지 검사한다.				
    276          				for(i=0;i<MEM_RECORD_SIZE;i++)
   \   00000240   0xE3A00000         MOV      R0,#+0
   \   00000244   0xE1B05000         MOVS     R5,R0
   \                     ??Download_main_14:
   \   00000248   0xE3550080         CMP      R5,#+128
   \   0000024C   0xAA000006         BGE      ??Download_main_15
    277          				{
    278          					if(WORD_L(pNorFlshAddr[(nFlshWrAddr*MEM_RECORD_SIZE) + i]) != 0xFF) break;
   \   00000250   0xE3A00080         MOV      R0,#+128
   \   00000254   0xE0215B90         MLA      R1,R0,R11,R5
   \   00000258   0xE7D10008         LDRB     R0,[R1, +R8]
   \   0000025C   0xE35000FF         CMP      R0,#+255
   \   00000260   0x1A000001         BNE      ??Download_main_15
    279          				}
   \                     ??Download_main_16:
   \   00000264   0xE2955001         ADDS     R5,R5,#+1
   \   00000268   0xEAFFFFF6         B        ??Download_main_14
    280          					
    281          				if(i != MEM_RECORD_SIZE)
   \                     ??Download_main_15:
   \   0000026C   0xE3550080         CMP      R5,#+128
   \   00000270   0x0A000014         BEQ      ??Download_main_17
    282          				{
    283          					// 지워지지 않았다면 잘 써졌있는지 검사한다.
    284          					for(i=0;i<MEM_RECORD_SIZE;i++)
   \   00000274   0xE3A00000         MOV      R0,#+0
   \   00000278   0xE1B05000         MOVS     R5,R0
   \                     ??Download_main_18:
   \   0000027C   0xE3550080         CMP      R5,#+128
   \   00000280   0xAA000009         BGE      ??Download_main_19
    285          					{
    286          						if(WORD_L(pNorFlshAddr[(nFlshWrAddr*MEM_RECORD_SIZE) + i]) != WORD_L(pText[6 + i])) break;
   \   00000284   0xE3A00080         MOV      R0,#+128
   \   00000288   0xE0215B90         MLA      R1,R0,R11,R5
   \   0000028C   0xE7D10008         LDRB     R0,[R1, +R8]
   \   00000290   0xE28D1010         ADD      R1,SP,#+16
   \   00000294   0xE0951001         ADDS     R1,R5,R1
   \   00000298   0xE5D11006         LDRB     R1,[R1, #+6]
   \   0000029C   0xE1500001         CMP      R0,R1
   \   000002A0   0x1A000001         BNE      ??Download_main_19
    287          					}
   \                     ??Download_main_20:
   \   000002A4   0xE2955001         ADDS     R5,R5,#+1
   \   000002A8   0xEAFFFFF3         B        ??Download_main_18
    288          						
    289          					// 다운로드가 정상적으로 되었다면 비디오 메모리에 0으로쓰고 아니면 1을 쓴다.
    290          					pVideoMem[nFlshWrAddr] = (i == MEM_RECORD_SIZE) ? OK : NG;
   \                     ??Download_main_19:
   \   000002AC   0xE3550080         CMP      R5,#+128
   \   000002B0   0x1A000001         BNE      ??Download_main_21
   \   000002B4   0xE3A00000         MOV      R0,#+0
   \   000002B8   0xEA000000         B        ??Download_main_22
   \                     ??Download_main_21:
   \   000002BC   0xE3A00001         MOV      R0,#+1
   \                     ??Download_main_22:
   \   000002C0   0xE7CB000A         STRB     R0,[R11, +R10]
    291          						
    292          					break;
   \   000002C4   0xEA00002E         B        ??Download_main_0
    293          				}
    294          					
    295          				
    296          
    297          				NORFLASH_WriteData(&norFlash, (nFlshWrAddr*MEM_RECORD_SIZE), &pText[6], MEM_RECORD_SIZE);
   \                     ??Download_main_17:
   \   000002C8   0xE3A03080         MOV      R3,#+128
   \   000002CC   0xE28D2016         ADD      R2,SP,#+22
   \   000002D0   0xE1B0138B         LSLS     R1,R11,#+7
   \   000002D4   0x........         LDR      R0,??DataTable5_7
   \   000002D8   0x........         BL       NORFLASH_WriteData
    298          					
    299                                          
    300          				// 잘 써졌는지 검사한다.
    301          				for(i=0;i<MEM_RECORD_SIZE;i++)
   \   000002DC   0xE3A00000         MOV      R0,#+0
   \   000002E0   0xE1B05000         MOVS     R5,R0
   \                     ??Download_main_23:
   \   000002E4   0xE3550080         CMP      R5,#+128
   \   000002E8   0xAA000009         BGE      ??Download_main_24
    302          				{
    303          					if(WORD_L(pNorFlshAddr[(nFlshWrAddr*MEM_RECORD_SIZE) + i]) != WORD_L(pText[6 + i])) break;
   \   000002EC   0xE3A00080         MOV      R0,#+128
   \   000002F0   0xE0215B90         MLA      R1,R0,R11,R5
   \   000002F4   0xE7D10008         LDRB     R0,[R1, +R8]
   \   000002F8   0xE28D1010         ADD      R1,SP,#+16
   \   000002FC   0xE0951001         ADDS     R1,R5,R1
   \   00000300   0xE5D11006         LDRB     R1,[R1, #+6]
   \   00000304   0xE1500001         CMP      R0,R1
   \   00000308   0x1A000001         BNE      ??Download_main_24
    304          				}
   \                     ??Download_main_25:
   \   0000030C   0xE2955001         ADDS     R5,R5,#+1
   \   00000310   0xEAFFFFF3         B        ??Download_main_23
    305          				
    306          				// 다운로드가 정상적으로 되었다면 비디오 메모리에 0으로쓰고 아니면 1을 쓴다.
    307          				pVideoMem[nFlshWrAddr] = (i == MEM_RECORD_SIZE) ?  OK : NG;					
   \                     ??Download_main_24:
   \   00000314   0xE3550080         CMP      R5,#+128
   \   00000318   0x1A000001         BNE      ??Download_main_26
   \   0000031C   0xE3A00000         MOV      R0,#+0
   \   00000320   0xEA000000         B        ??Download_main_27
   \                     ??Download_main_26:
   \   00000324   0xE3A00001         MOV      R0,#+1
   \                     ??Download_main_27:
   \   00000328   0xE7CB000A         STRB     R0,[R11, +R10]
    308          
    309          				gFirmWareExeFlag = FALSE; // 2초후 자동으로 수행하지 못하도록 한다.
   \   0000032C   0x........         LDR      R0,??DataTable5_4
   \   00000330   0xE3A01000         MOV      R1,#+0
   \   00000334   0xE5801000         STR      R1,[R0, #+0]
    310                                          
    311                                        
    312          				gVersionPrintFlag = IsPrintOfVersion();
   \   00000338   0x........         BL       IsPrintOfVersion
   \   0000033C   0x........         LDR      R1,??DataTable5_5
   \   00000340   0xE5810000         STR      R0,[R1, #+0]
    313          				break;				
   \   00000344   0xEA00000E         B        ??Download_main_0
    314          		
    315          			// 상태를 요구.
    316          			case SCC_STATUS_REQ:
    317          				if((UCHAR)ADD_CHECK() != pText[0]) break; // 나의 상태를 요구하는것인지 체크
   \                     ??Download_main_2:
   \   00000348   0x........         BL       ADD_CHECK
   \   0000034C   0xE5DD1010         LDRB     R1,[SP, #+16]
   \   00000350   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000354   0xE1500001         CMP      R0,R1
   \   00000358   0x1A000009         BNE      ??Download_main_0
    318          
    319          				SendStatusReq(pText);
   \                     ??Download_main_28:
   \   0000035C   0xE28D0010         ADD      R0,SP,#+16
   \   00000360   0x........         BL       SendStatusReq
    320          				gFirmWareExeFlag = FALSE; // 2초후 자동으로 수행하지 못하도록 한다.						
   \   00000364   0x........         LDR      R0,??DataTable5_4
   \   00000368   0xE3A01000         MOV      R1,#+0
   \   0000036C   0xE5801000         STR      R1,[R0, #+0]
    321          				gVersionPrintFlag = IsPrintOfVersion();
   \   00000370   0x........         BL       IsPrintOfVersion
   \   00000374   0x........         LDR      R1,??DataTable5_5
   \   00000378   0xE5810000         STR      R0,[R1, #+0]
    322          				break;
   \   0000037C   0xEA000000         B        ??Download_main_0
    323          				
    324          			// 상태 응답 프로토콜을 무시한다.
    325          			case SCC_STATUS_RLY:
    326          				break;
   \                     ??Download_main_3:
   \   00000380   0xEAFFFFFF         B        ??Download_main_0
    327          				
    328          			// 아무런 해당사항이 없는 프로토콜이면 본 프로그램을 수행
    329          			default:
    330          					
    331          				break;
    332          			}
    333          			
    334          		}
    335          
    336          		//glDebugCnt++;
    337          	//}	
    338          }
   \                     ??Download_main_5:
   \                     ??Download_main_0:
   \   00000384   0xE28DD0DC         ADD      SP,SP,#+220      ;; stack cleaning
   \   00000388   0xE8BD4FF0         POP      {R4-R11,LR}
   \   0000038C   0xE12FFF1E         BX       LR               ;; return
    339          
    340          /***********************************************************************
    341          	화면의 중앙을 계산한다.
    342          ************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    343          void ScreenWidth()
    344          {
   \                     ScreenWidth:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    345          	if(IS_IDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 224; // 차내표시기
   \   00000004   0x........         BL       ADD_CHECK
   \   00000008   0xE210000F         ANDS     R0,R0,#0xF
   \   0000000C   0xE3500001         CMP      R0,#+1
   \   00000010   0xBA000007         BLT      ??ScreenWidth_0
   \   00000014   0x........         BL       ADD_CHECK
   \   00000018   0xE210000F         ANDS     R0,R0,#0xF
   \   0000001C   0xE3500005         CMP      R0,#+5
   \   00000020   0xAA000003         BGE      ??ScreenWidth_0
   \   00000024   0x........         LDR      R0,??DataTable5_3
   \   00000028   0xE3A010E0         MOV      R1,#+224
   \   0000002C   0xE5801000         STR      R1,[R0, #+0]
   \   00000030   0xEA000036         B        ??ScreenWidth_1
    346          	else
    347          	if(IS_FDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 96; // 정면 표시기
   \                     ??ScreenWidth_0:
   \   00000034   0x........         BL       ADD_CHECK
   \   00000038   0xE210000F         ANDS     R0,R0,#0xF
   \   0000003C   0xE350000F         CMP      R0,#+15
   \   00000040   0x1A000003         BNE      ??ScreenWidth_2
   \   00000044   0x........         LDR      R0,??DataTable5_3
   \   00000048   0xE3A01060         MOV      R1,#+96
   \   0000004C   0xE5801000         STR      R1,[R0, #+0]
   \   00000050   0xEA00002E         B        ??ScreenWidth_1
    348          	else
    349          	if(IS_SDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 96; // 측면 표시기
   \                     ??ScreenWidth_2:
   \   00000054   0x........         BL       ADD_CHECK
   \   00000058   0xE210000F         ANDS     R0,R0,#0xF
   \   0000005C   0xE350000A         CMP      R0,#+10
   \   00000060   0x0A000003         BEQ      ??ScreenWidth_3
   \   00000064   0x........         BL       ADD_CHECK
   \   00000068   0xE210000F         ANDS     R0,R0,#0xF
   \   0000006C   0xE350000B         CMP      R0,#+11
   \   00000070   0x1A000003         BNE      ??ScreenWidth_4
   \                     ??ScreenWidth_3:
   \   00000074   0x........         LDR      R0,??DataTable5_3
   \   00000078   0xE3A01060         MOV      R1,#+96
   \   0000007C   0xE5801000         STR      R1,[R0, #+0]
   \   00000080   0xEA000022         B        ??ScreenWidth_1
    350          	else
    351          	if(IS_TN_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 64; // 열차번호
   \                     ??ScreenWidth_4:
   \   00000084   0x........         BL       ADD_CHECK
   \   00000088   0xE210000F         ANDS     R0,R0,#0xF
   \   0000008C   0xE350000D         CMP      R0,#+13
   \   00000090   0x1A000003         BNE      ??ScreenWidth_5
   \   00000094   0x........         LDR      R0,??DataTable5_3
   \   00000098   0xE3A01040         MOV      R1,#+64
   \   0000009C   0xE5801000         STR      R1,[R0, #+0]
   \   000000A0   0xEA00001A         B        ??ScreenWidth_1
    352          	else
    353          	if(IS_LDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 0; // 노선
   \                     ??ScreenWidth_5:
   \   000000A4   0x........         BL       ADD_CHECK
   \   000000A8   0xE210000F         ANDS     R0,R0,#0xF
   \   000000AC   0xE3500005         CMP      R0,#+5
   \   000000B0   0xBA000007         BLT      ??ScreenWidth_6
   \   000000B4   0x........         BL       ADD_CHECK
   \   000000B8   0xE210000F         ANDS     R0,R0,#0xF
   \   000000BC   0xE3500009         CMP      R0,#+9
   \   000000C0   0xAA000003         BGE      ??ScreenWidth_6
   \   000000C4   0x........         LDR      R0,??DataTable5_3
   \   000000C8   0xE3A01000         MOV      R1,#+0
   \   000000CC   0xE5801000         STR      R1,[R0, #+0]
   \   000000D0   0xEA00000E         B        ??ScreenWidth_1
    354          	else
    355          	if(IS_HDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) SCREEN_WIDTH_MAX = 16; // 호차 표시기
   \                     ??ScreenWidth_6:
   \   000000D4   0x........         BL       ADD_CHECK
   \   000000D8   0xE210000F         ANDS     R0,R0,#0xF
   \   000000DC   0xE3500009         CMP      R0,#+9
   \   000000E0   0x0A000003         BEQ      ??ScreenWidth_7
   \   000000E4   0x........         BL       ADD_CHECK
   \   000000E8   0xE210000F         ANDS     R0,R0,#0xF
   \   000000EC   0xE350000E         CMP      R0,#+14
   \   000000F0   0x1A000003         BNE      ??ScreenWidth_8
   \                     ??ScreenWidth_7:
   \   000000F4   0x........         LDR      R0,??DataTable5_3
   \   000000F8   0xE3A01010         MOV      R1,#+16
   \   000000FC   0xE5801000         STR      R1,[R0, #+0]
   \   00000100   0xEA000002         B        ??ScreenWidth_1
    356          	else
    357          		SCREEN_WIDTH_MAX = 0;
   \                     ??ScreenWidth_8:
   \   00000104   0x........         LDR      R0,??DataTable5_3
   \   00000108   0xE3A01000         MOV      R1,#+0
   \   0000010C   0xE5801000         STR      R1,[R0, #+0]
    358          }
   \                     ??ScreenWidth_1:
   \   00000110   0xE8BD4001         POP      {R0,LR}
   \   00000114   0xE12FFF1E         BX       LR               ;; return
    359          
    360          /***********************************************************************
    361          	차내표시기(0x1F), 정면표시기(0xF5), 측면표시기(0xF6)
    362          	열차번호표시기(0xF7), 노선표시기(0xF9)
    363          ************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    364          int IsDisplayAddressOk(UCHAR nToAddr)
    365          {
   \                     IsDisplayAddressOk:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    366          	switch(nToAddr)
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000010   0xE24000F1         SUB      R0,R0,#+241
   \   00000014   0xE3500008         CMP      R0,#+8
   \   00000018   0x8A00003E         BHI      ??IsDisplayAddressOk_1
   \   0000001C   0xE7DF1000         LDRB     R1,[PC, R0]
   \   00000020   0xE08FF101         ADD      PC,PC,R1, LSL #+2
   \                     ??IsDisplayAddressOk_0:
   \   00000024   0x02 0x3C          DC8      0x2,0x3C,0x3C,0x31
   \              0x3C 0x31    
   \   00000028   0x0D 0x14          DC8      0xD,0x14,0x1F,0x3C
   \              0x1F 0x3C    
   \   0000002C   0x26 0x00          DC8      0x26,0x0,0x0,0x0
   \              0x00 0x00    
    367          	{
    368          	case IDD:if(IS_IDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
   \                     ??IsDisplayAddressOk_2:
   \   00000030   0x........         BL       ADD_CHECK
   \   00000034   0xE210000F         ANDS     R0,R0,#0xF
   \   00000038   0xE3500001         CMP      R0,#+1
   \   0000003C   0xBA000005         BLT      ??IsDisplayAddressOk_3
   \   00000040   0x........         BL       ADD_CHECK
   \   00000044   0xE210000F         ANDS     R0,R0,#0xF
   \   00000048   0xE3500005         CMP      R0,#+5
   \   0000004C   0xAA000001         BGE      ??IsDisplayAddressOk_3
   \   00000050   0xE3A00001         MOV      R0,#+1
   \   00000054   0xEA000032         B        ??IsDisplayAddressOk_4
   \                     ??IsDisplayAddressOk_3:
   \   00000058   0xEA000030         B        ??IsDisplayAddressOk_5
    369          	case FDD:if(IS_FDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
   \                     ??IsDisplayAddressOk_6:
   \   0000005C   0x........         BL       ADD_CHECK
   \   00000060   0xE210000F         ANDS     R0,R0,#0xF
   \   00000064   0xE350000F         CMP      R0,#+15
   \   00000068   0x1A000001         BNE      ??IsDisplayAddressOk_7
   \   0000006C   0xE3A00001         MOV      R0,#+1
   \   00000070   0xEA00002B         B        ??IsDisplayAddressOk_4
   \                     ??IsDisplayAddressOk_7:
   \   00000074   0xEA000029         B        ??IsDisplayAddressOk_5
    370          	case SDD:if(IS_SDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
   \                     ??IsDisplayAddressOk_8:
   \   00000078   0x........         BL       ADD_CHECK
   \   0000007C   0xE210000F         ANDS     R0,R0,#0xF
   \   00000080   0xE350000A         CMP      R0,#+10
   \   00000084   0x0A000003         BEQ      ??IsDisplayAddressOk_9
   \   00000088   0x........         BL       ADD_CHECK
   \   0000008C   0xE210000F         ANDS     R0,R0,#0xF
   \   00000090   0xE350000B         CMP      R0,#+11
   \   00000094   0x1A000001         BNE      ??IsDisplayAddressOk_10
   \                     ??IsDisplayAddressOk_9:
   \   00000098   0xE3A00001         MOV      R0,#+1
   \   0000009C   0xEA000020         B        ??IsDisplayAddressOk_4
   \                     ??IsDisplayAddressOk_10:
   \   000000A0   0xEA00001E         B        ??IsDisplayAddressOk_5
    371          	case TN:if(IS_TN_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
   \                     ??IsDisplayAddressOk_11:
   \   000000A4   0x........         BL       ADD_CHECK
   \   000000A8   0xE210000F         ANDS     R0,R0,#0xF
   \   000000AC   0xE350000D         CMP      R0,#+13
   \   000000B0   0x1A000001         BNE      ??IsDisplayAddressOk_12
   \   000000B4   0xE3A00001         MOV      R0,#+1
   \   000000B8   0xEA000019         B        ??IsDisplayAddressOk_4
   \                     ??IsDisplayAddressOk_12:
   \   000000BC   0xEA000017         B        ??IsDisplayAddressOk_5
    372          	case LDD:if(IS_LDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
   \                     ??IsDisplayAddressOk_13:
   \   000000C0   0x........         BL       ADD_CHECK
   \   000000C4   0xE210000F         ANDS     R0,R0,#0xF
   \   000000C8   0xE3500005         CMP      R0,#+5
   \   000000CC   0xBA000005         BLT      ??IsDisplayAddressOk_14
   \   000000D0   0x........         BL       ADD_CHECK
   \   000000D4   0xE210000F         ANDS     R0,R0,#0xF
   \   000000D8   0xE3500009         CMP      R0,#+9
   \   000000DC   0xAA000001         BGE      ??IsDisplayAddressOk_14
   \   000000E0   0xE3A00001         MOV      R0,#+1
   \   000000E4   0xEA00000E         B        ??IsDisplayAddressOk_4
   \                     ??IsDisplayAddressOk_14:
   \   000000E8   0xEA00000C         B        ??IsDisplayAddressOk_5
    373          	case HDD:if(IS_HDD_NO(BYTE_L((UCHAR)ADD_CHECK()))) return TRUE;break;	
   \                     ??IsDisplayAddressOk_15:
   \   000000EC   0x........         BL       ADD_CHECK
   \   000000F0   0xE210000F         ANDS     R0,R0,#0xF
   \   000000F4   0xE3500009         CMP      R0,#+9
   \   000000F8   0x0A000003         BEQ      ??IsDisplayAddressOk_16
   \   000000FC   0x........         BL       ADD_CHECK
   \   00000100   0xE210000F         ANDS     R0,R0,#0xF
   \   00000104   0xE350000E         CMP      R0,#+14
   \   00000108   0x1A000001         BNE      ??IsDisplayAddressOk_17
   \                     ??IsDisplayAddressOk_16:
   \   0000010C   0xE3A00001         MOV      R0,#+1
   \   00000110   0xEA000003         B        ??IsDisplayAddressOk_4
   \                     ??IsDisplayAddressOk_17:
   \   00000114   0xEA000001         B        ??IsDisplayAddressOk_5
    374          	default:
    375          		return FALSE;
   \                     ??IsDisplayAddressOk_1:
   \   00000118   0xE3A00000         MOV      R0,#+0
   \   0000011C   0xEA000000         B        ??IsDisplayAddressOk_4
    376          	}
    377          
    378          	return FALSE;
   \                     ??IsDisplayAddressOk_5:
   \   00000120   0xE3A00000         MOV      R0,#+0
   \                     ??IsDisplayAddressOk_4:
   \   00000124   0xE8BD4010         POP      {R4,LR}
   \   00000128   0xE12FFF1E         BX       LR               ;; return
    379          }
    380          
    381          /***********************************************************************
    382          	화면에 출력할 수 있는 표시기인지 리턴한다.
    383          ************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    384          int IsPrintOfVersion()
    385          {
   \                     IsPrintOfVersion:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    386          	if(LO_NIBBLE((UCHAR)ADD_CHECK()) < 5 || LO_NIBBLE((UCHAR)ADD_CHECK()) > 8) return TRUE; else return FALSE;
   \   00000004   0x........         BL       ADD_CHECK
   \   00000008   0xE210000F         ANDS     R0,R0,#0xF
   \   0000000C   0xE3500005         CMP      R0,#+5
   \   00000010   0x3A000003         BCC      ??IsPrintOfVersion_0
   \   00000014   0x........         BL       ADD_CHECK
   \   00000018   0xE210000F         ANDS     R0,R0,#0xF
   \   0000001C   0xE3500009         CMP      R0,#+9
   \   00000020   0x3A000001         BCC      ??IsPrintOfVersion_1
   \                     ??IsPrintOfVersion_0:
   \   00000024   0xE3A00001         MOV      R0,#+1
   \   00000028   0xEA000000         B        ??IsPrintOfVersion_2
   \                     ??IsPrintOfVersion_1:
   \   0000002C   0xE3A00000         MOV      R0,#+0
   \                     ??IsPrintOfVersion_2:
   \   00000030   0xE8BD4002         POP      {R1,LR}
   \   00000034   0xE12FFF1E         BX       LR               ;; return
    387          }
    388          
    389          /***********************************************************************
    390          	상태를 리턴한다.
    391          ************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    392          void SendStatusReq(UCHAR *pRevPtcTextBuff)
    393          {
   \                     SendStatusReq:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE24DD018         SUB      SP,SP,#+24
   \   00000008   0xE1B04000         MOVS     R4,R0
    394          	int i,blockSize;
    395          	int nTemp;
    396          	UCHAR nPtcBuff[20];
    397          	UINT nLen;
    398          	UINT nCrc;
    399          	UCHAR *pNorFlshAddr = (UCHAR *)(BOARD_NORFLASH_ADDR);
   \   0000000C   0xE3A09540         MOV      R9,#+268435456
    400          	UCHAR *pVideoMem = (UCHAR *)DOT_VIDEO_DATA;
   \   00000010   0xE3E0A4DF         MVN      R10,#-553648128
   \   00000014   0xE3CAA8FE         BIC      R10,R10,#0xFE0000
    401          	UCHAR sMeroTestBuf[1024];
    402          	
    403          	nLen = 10;
   \   00000018   0xE3A0000A         MOV      R0,#+10
   \   0000001C   0xE1B07000         MOVS     R7,R0
    404          	
    405          	nPtcBuff[0] = 0xAA;
   \   00000020   0xE3A010AA         MOV      R1,#+170
   \   00000024   0xE5CD1000         STRB     R1,[SP, #+0]
    406          	nPtcBuff[1] = 0xBB;
   \   00000028   0xE3A010BB         MOV      R1,#+187
   \   0000002C   0xE5CD1001         STRB     R1,[SP, #+1]
    407          	nPtcBuff[2] = 0xCC;
   \   00000030   0xE3A010CC         MOV      R1,#+204
   \   00000034   0xE5CD1002         STRB     R1,[SP, #+2]
    408          	
    409          	nPtcBuff[3] = WORD_H(nLen);
   \   00000038   0xE1B00427         LSRS     R0,R7,#+8
   \   0000003C   0xE5CD0003         STRB     R0,[SP, #+3]
    410          	nPtcBuff[4] = WORD_L(nLen);
   \   00000040   0xE5CD7004         STRB     R7,[SP, #+4]
    411          	
    412          	nPtcBuff[5] = ~WORD_H(nLen);
   \   00000044   0xE1F00427         MVNS     R0,R7, LSR #+8
   \   00000048   0xE5CD0005         STRB     R0,[SP, #+5]
    413          	nPtcBuff[6] = ~WORD_L(nLen);
   \   0000004C   0xE1F01007         MVNS     R1,R7
   \   00000050   0xE5CD1006         STRB     R1,[SP, #+6]
    414          	
    415          	nPtcBuff[7] = pRevPtcTextBuff[1];	
   \   00000054   0xE5D41001         LDRB     R1,[R4, #+1]
   \   00000058   0xE5CD1007         STRB     R1,[SP, #+7]
    416          	nPtcBuff[8] = pRevPtcTextBuff[0];
   \   0000005C   0xE5D41000         LDRB     R1,[R4, #+0]
   \   00000060   0xE5CD1008         STRB     R1,[SP, #+8]
    417          	
    418          	nPtcBuff[9] = SCC_STATUS_RLY; // Code
   \   00000064   0xE3A01008         MOV      R1,#+8
   \   00000068   0xE5CD1009         STRB     R1,[SP, #+9]
    419          	
    420          	nPtcBuff[10] = 0x01; // Downloader Reply Code
   \   0000006C   0xE3A01001         MOV      R1,#+1
   \   00000070   0xE5CD100A         STRB     R1,[SP, #+10]
    421          	
    422          	nPtcBuff[12] = 0x00;
   \   00000074   0xE3A01000         MOV      R1,#+0
   \   00000078   0xE5CD100C         STRB     R1,[SP, #+12]
    423          	nPtcBuff[13] = 0x00;
   \   0000007C   0xE3A01000         MOV      R1,#+0
   \   00000080   0xE5CD100D         STRB     R1,[SP, #+13]
    424          
    425          	switch(pRevPtcTextBuff[4]&0xff)
   \   00000084   0xE5D40004         LDRB     R0,[R4, #+4]
   \   00000088   0xE3500000         CMP      R0,#+0
   \   0000008C   0x0A000004         BEQ      ??SendStatusReq_0
   \   00000090   0xE3500010         CMP      R0,#+16
   \   00000094   0x0A000005         BEQ      ??SendStatusReq_1
   \   00000098   0xE3500020         CMP      R0,#+32
   \   0000009C   0x0A000017         BEQ      ??SendStatusReq_2
    426          	{
    427          	default:	
    428          		return;
   \                     ??SendStatusReq_3:
   \   000000A0   0xEA00004C         B        ??SendStatusReq_4
    429          	
    430          	// 통신 상태 OK,NG
    431          	case 0x00:
    432          		nPtcBuff[11] = 0x00;
   \                     ??SendStatusReq_0:
   \   000000A4   0xE3A01000         MOV      R1,#+0
   \   000000A8   0xE5CD100B         STRB     R1,[SP, #+11]
    433          		break;
   \   000000AC   0xEA000032         B        ??SendStatusReq_5
    434          				
    435          	// 메모리 Erase OK,NG
    436          	case 0x10:		
    437          		nTemp = pRevPtcTextBuff[5]*0x10000;
   \                     ??SendStatusReq_1:
   \   000000B0   0xE5D40005         LDRB     R0,[R4, #+5]
   \   000000B4   0xE1B00800         LSLS     R0,R0,#+16
   \   000000B8   0xE1B06000         MOVS     R6,R0
    438          		// 블럭이 지워졌는지 검사
    439          
    440          
    441          		for(i=0;i<0x10000;i++)
   \   000000BC   0xE3A00000         MOV      R0,#+0
   \   000000C0   0xE1B05000         MOVS     R5,R0
   \                     ??SendStatusReq_6:
   \   000000C4   0xE3550B40         CMP      R5,#+65536
   \   000000C8   0xAA000005         BGE      ??SendStatusReq_7
    442                          {
    443          		  if(WORD_L(pNorFlshAddr[nTemp + i]) != 0xFF) break;	
   \   000000CC   0xE0950006         ADDS     R0,R5,R6
   \   000000D0   0xE7D00009         LDRB     R0,[R0, +R9]
   \   000000D4   0xE35000FF         CMP      R0,#+255
   \   000000D8   0x1A000001         BNE      ??SendStatusReq_7
    444                          }
   \                     ??SendStatusReq_8:
   \   000000DC   0xE2955001         ADDS     R5,R5,#+1
   \   000000E0   0xEAFFFFF7         B        ??SendStatusReq_6
    445          		
    446          		nPtcBuff[11] = (i == 0x10000 ? MEMORY_ERASE_OK : MEMORY_ERASE_NG);
   \                     ??SendStatusReq_7:
   \   000000E4   0xE3550B40         CMP      R5,#+65536
   \   000000E8   0x1A000001         BNE      ??SendStatusReq_9
   \   000000EC   0xE3A00010         MOV      R0,#+16
   \   000000F0   0xEA000000         B        ??SendStatusReq_10
   \                     ??SendStatusReq_9:
   \   000000F4   0xE3A00011         MOV      R0,#+17
   \                     ??SendStatusReq_10:
   \   000000F8   0xE5CD000B         STRB     R0,[SP, #+11]
    447                          
    448                          
    449          		break;
   \   000000FC   0xEA00001E         B        ??SendStatusReq_5
    450          
    451          	// Data Download OK,NG
    452          	case 0x20:
    453          		for(i=MAKE_WORD(pRevPtcTextBuff[6],pRevPtcTextBuff[7]);i<=MAKE_WORD(pRevPtcTextBuff[8],pRevPtcTextBuff[9]);i++)
   \                     ??SendStatusReq_2:
   \   00000100   0xE5D40006         LDRB     R0,[R4, #+6]
   \   00000104   0xE5D41007         LDRB     R1,[R4, #+7]
   \   00000108   0xE1910400         ORRS     R0,R1,R0, LSL #+8
   \   0000010C   0xE1B05000         MOVS     R5,R0
   \                     ??SendStatusReq_11:
   \   00000110   0xE5D40008         LDRB     R0,[R4, #+8]
   \   00000114   0xE5D41009         LDRB     R1,[R4, #+9]
   \   00000118   0xE1910400         ORRS     R0,R1,R0, LSL #+8
   \   0000011C   0xE1500005         CMP      R0,R5
   \   00000120   0xBA000004         BLT      ??SendStatusReq_12
    454          		{
    455          			// 쓰여지지 않은 메모리라면 현 루프를 중지한다.
    456          			if(WORD_L(pVideoMem[i]) == NG) break;
   \   00000124   0xE7D5000A         LDRB     R0,[R5, +R10]
   \   00000128   0xE3500001         CMP      R0,#+1
   \   0000012C   0x0A000001         BEQ      ??SendStatusReq_12
    457          		}
   \                     ??SendStatusReq_13:
   \   00000130   0xE2955001         ADDS     R5,R5,#+1
   \   00000134   0xEAFFFFF5         B        ??SendStatusReq_11
    458          
    459          		if(i > MAKE_WORD(pRevPtcTextBuff[8],pRevPtcTextBuff[9]))
   \                     ??SendStatusReq_12:
   \   00000138   0xE5D40008         LDRB     R0,[R4, #+8]
   \   0000013C   0xE5D41009         LDRB     R1,[R4, #+9]
   \   00000140   0xE1910400         ORRS     R0,R1,R0, LSL #+8
   \   00000144   0xE1500005         CMP      R0,R5
   \   00000148   0xAA000006         BGE      ??SendStatusReq_14
    460          		{
    461          			nPtcBuff[11] = 0x20; // OK
   \   0000014C   0xE3A01020         MOV      R1,#+32
   \   00000150   0xE5CD100B         STRB     R1,[SP, #+11]
    462          
    463          			nPtcBuff[12] = 0x00;
   \   00000154   0xE3A01000         MOV      R1,#+0
   \   00000158   0xE5CD100C         STRB     R1,[SP, #+12]
    464          			nPtcBuff[13] = 0x00;
   \   0000015C   0xE3A01000         MOV      R1,#+0
   \   00000160   0xE5CD100D         STRB     R1,[SP, #+13]
   \   00000164   0xEA000004         B        ??SendStatusReq_15
    465          		}
    466          		else
    467          		{		
    468          			nPtcBuff[11] = 0x21; // NG
   \                     ??SendStatusReq_14:
   \   00000168   0xE3A01021         MOV      R1,#+33
   \   0000016C   0xE5CD100B         STRB     R1,[SP, #+11]
    469          
    470          			nPtcBuff[12] = WORD_H(i);
   \   00000170   0xE1B00445         ASRS     R0,R5,#+8
   \   00000174   0xE5CD000C         STRB     R0,[SP, #+12]
    471          			nPtcBuff[13] = WORD_L(i);
   \   00000178   0xE5CD500D         STRB     R5,[SP, #+13]
    472          		}
    473          		
    474          		break;
    475          	}	
    476          	
    477          	nPtcBuff[14] = 0x00; // TEXT(7)
   \                     ??SendStatusReq_15:
   \                     ??SendStatusReq_5:
   \   0000017C   0xE3A01000         MOV      R1,#+0
   \   00000180   0xE5CD100E         STRB     R1,[SP, #+14]
    478          	nPtcBuff[15] = VERSION; // TEXT(8) - 다운로더 번호
   \   00000184   0xE3A01010         MOV      R1,#+16
   \   00000188   0xE5CD100F         STRB     R1,[SP, #+15]
    479          	nPtcBuff[16] = 11;//GetFirmWareVersion(); // TEXT(9) - 표시기 Firmware Version(0x10 ~ 0x90)
   \   0000018C   0xE3A0100B         MOV      R1,#+11
   \   00000190   0xE5CD1010         STRB     R1,[SP, #+16]
    480          	
    481          	nPtcBuff[17] = 0x03; // ETX
   \   00000194   0xE3A01003         MOV      R1,#+3
   \   00000198   0xE5CD1011         STRB     R1,[SP, #+17]
    482          	
    483          	
    484                  nCrc = cal_CRC16(nLen+5,(UCHAR *)&nPtcBuff[3]);
   \   0000019C   0xE28D1003         ADD      R1,SP,#+3
   \   000001A0   0xE2970005         ADDS     R0,R7,#+5
   \   000001A4   0x........         BL       cal_CRC16
   \   000001A8   0xE1B08000         MOVS     R8,R0
    485          
    486          	nPtcBuff[18] = WORD_H(nCrc); // CRC
   \   000001AC   0xE1B00428         LSRS     R0,R8,#+8
   \   000001B0   0xE5CD0012         STRB     R0,[SP, #+18]
    487          	nPtcBuff[19] = WORD_L(nCrc); // CRC
   \   000001B4   0xE5CD8013         STRB     R8,[SP, #+19]
    488          
    489          
    490          	memcpy(SCC1_Init_AChl.pTxBuffer,nPtcBuff,20);
                 	^
Warning[Pe223]: function "memcpy" declared implicitly

  	int i,blockSize;
  	      ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",394  Warning[Pe177]: 
          variable "blockSize" was declared but never referenced

  	UCHAR sMeroTestBuf[1024];
  	      ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",401  Warning[Pe177]: 
          variable "sMeroTestBuf" was declared but never referenced
   \   000001B8   0xE3A02014         MOV      R2,#+20
   \   000001BC   0xE1B0100D         MOVS     R1,SP
   \   000001C0   0x........         LDR      R0,??DataTable5
   \   000001C4   0xE5900010         LDR      R0,[R0, #+16]
   \   000001C8   0x........         BL       memcpy
    491          
    492          	SCC1_Init_AChl.TxDelTime = 10;
   \   000001CC   0x........         LDR      R0,??DataTable5
   \   000001D0   0xE3A0100A         MOV      R1,#+10
   \   000001D4   0xE580100C         STR      R1,[R0, #+12]
    493          
    494          }
   \                     ??SendStatusReq_4:
   \   000001D8   0xE28DD018         ADD      SP,SP,#+24       ;; stack cleaning
   \   000001DC   0xE8BD47F0         POP      {R4-R10,LR}
   \   000001E0   0xE12FFF1E         BX       LR               ;; return
    495          
    496          /************************************************************************
    497          	Firmware 버젼 얻기
    498          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    499          UCHAR GetFirmWareVersion()
    500          {
    501            /*
    502          	int i;
    503          	int nPos;	
    504          	DWORD nDat;
    505          	DWORD nReadBlkSize;
    506          	UCHAR *pAddr = (UCHAR *)(NORFLASH_ADDR + 0x3C0000);
    507          	UCHAR nBuff[2];
    508          
    509          	if(WORD_L(pAddr[0]) == 0xFF || WORD_L(pAddr[1]) == 0xFF || WORD_L(pAddr[2]) == 0xFF || WORD_L(pAddr[3]) == 0xFF)
    510          	 return 0xFF;
    511          	
    512          	nPos = 4;
    513          
    514          	for(;;)
    515          	{
    516          		WDI_CS;
    517          		
    518          		// Block Size
    519          		nDat = MAKE_DWORD(pAddr[nPos*4+3],pAddr[nPos*4+2],pAddr[nPos*4+1],pAddr[nPos*4+0]);
    520          		nReadBlkSize = nDat;
    521          		if(nReadBlkSize == 0x00000000)
    522          		{
    523          			nPos-=3;			
    524          			nBuff[0] = nDat = MAKE_DWORD(pAddr[nPos*4+3],pAddr[nPos*4+2],pAddr[nPos*4+1],pAddr[nPos*4+0]);
    525          			nPos++;			
    526          			nBuff[1] = nDat = MAKE_DWORD(pAddr[nPos*4+3],pAddr[nPos*4+2],pAddr[nPos*4+1],pAddr[nPos*4+0]);
    527          			
    528          			return TwoChar2HEX(WORD_L(nBuff[0]),WORD_L(nBuff[1])); // 블럭 크기가 0이면 종료한다.
    529          		}
    530          		else
    531          		if(nReadBlkSize >= 0x00040000 || nPos >= 0x00040000) // 256KB이상이면 프로그램이 잘못 다운로드 된것으로 보고 중지
    532          		{
    533          			return 0xFF;
    534          		}
    535          			
    536          		nPos++;
    537          		
    538          		// Destination Address
    539          		nPos++;
    540          
    541          		// Destination Strobe
    542          		nPos++;
    543          
    544          		// Data
    545          		nPos += nReadBlkSize;
    546          	}
    547            */
    548          }
                 ^
Warning[Pe940]: missing return statement at end of non-void function
          "GetFirmWareVersion"
   \                     GetFirmWareVersion:
   \   00000000   0xE12FFF1E         BX       LR               ;; return
    549          
    550          /************************************************************************
    551          	한개의 문자를 헥사 코드로 만든다.
    552          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    553          UCHAR OneChar2HEX(char Ch)
    554          {
   \                     OneChar2HEX:
   \   00000000   0xE1B01000         MOVS     R1,R0
    555          	if((UCHAR)Ch >= 'a' && (UCHAR)Ch <= 'f') return Ch - 'a' + 10;
   \   00000004   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000008   0xE3510061         CMP      R1,#+97
   \   0000000C   0x3A000005         BCC      ??OneChar2HEX_0
   \   00000010   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000014   0xE3510067         CMP      R1,#+103
   \   00000018   0x2A000002         BCS      ??OneChar2HEX_0
   \   0000001C   0xE2510057         SUBS     R0,R1,#+87
   \   00000020   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000024   0xEA000012         B        ??OneChar2HEX_1
    556          	else
    557          		if((UCHAR)Ch >= 'A' && (UCHAR)Ch <= 'F') return Ch - 'A' + 10;
   \                     ??OneChar2HEX_0:
   \   00000028   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   0000002C   0xE3510041         CMP      R1,#+65
   \   00000030   0x3A000005         BCC      ??OneChar2HEX_2
   \   00000034   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000038   0xE3510047         CMP      R1,#+71
   \   0000003C   0x2A000002         BCS      ??OneChar2HEX_2
   \   00000040   0xE2510037         SUBS     R0,R1,#+55
   \   00000044   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000048   0xEA000009         B        ??OneChar2HEX_1
    558          		else
    559          			if((UCHAR)Ch >= '0' && (UCHAR)Ch <= '9') return Ch - '0';
   \                     ??OneChar2HEX_2:
   \   0000004C   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000050   0xE3510030         CMP      R1,#+48
   \   00000054   0x3A000005         BCC      ??OneChar2HEX_3
   \   00000058   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   0000005C   0xE351003A         CMP      R1,#+58
   \   00000060   0x2A000002         BCS      ??OneChar2HEX_3
   \   00000064   0xE2510030         SUBS     R0,R1,#+48
   \   00000068   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000006C   0xEA000000         B        ??OneChar2HEX_1
    560          			else return 0;
   \                     ??OneChar2HEX_3:
   \   00000070   0xE3A00000         MOV      R0,#+0
   \                     ??OneChar2HEX_1:
   \   00000074   0xE12FFF1E         BX       LR               ;; return
    561          }
    562          
    563          /************************************************************************
    564          	두개의 문자를 헥사 코드로 만든다.
    565          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    566          UCHAR TwoChar2HEX(char Ch1,char Ch2)
    567          {
   \                     TwoChar2HEX:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    568          	return ((UCHAR)OneChar2HEX(Ch1)&0xf)<<4 | ((UCHAR)OneChar2HEX(Ch2)&0xf);
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000014   0x........         BL       OneChar2HEX
   \   00000018   0xE1B06000         MOVS     R6,R0
   \   0000001C   0xE1B00005         MOVS     R0,R5
   \   00000020   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000024   0x........         BL       OneChar2HEX
   \   00000028   0xE210000F         ANDS     R0,R0,#0xF
   \   0000002C   0xE1900206         ORRS     R0,R0,R6, LSL #+4
   \   00000030   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000034   0xE8BD4070         POP      {R4-R6,LR}
   \   00000038   0xE12FFF1E         BX       LR               ;; return
    569          }
    570          
    571          /************************************************************************
    572          	LENGTH~ETX CRC16
    573          *************************************************************************
    574          WORD CalCrc16(UCHAR *pDat,int nNo)
    575          {
    576          	WORD CRC = 0;
    577          	int i;
    578          
    579          	for(i=0; i<nNo; i++)
    580          		CRC = (CRC >> 8) ^ gCRC_Table[(CRC^pDat[i])&0x00ff];
    581          
    582          	return ((~CRC) & 0x0000ffff);
    583          }
    584          
    585          
    586          /************************************************************************
                 ^
Warning[Pe009]: nested comment is not allowed
    587          	LDM Address Setting
    588          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    589          void LdmLatchClk(int Line)
    590          {	
   \                     LdmLatchClk:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    591          	switch(Line)
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x0A000002         BEQ      ??LdmLatchClk_0
   \   00000010   0xE3540001         CMP      R4,#+1
   \   00000014   0x0A00000B         BEQ      ??LdmLatchClk_1
   \   00000018   0xEA000014         B        ??LdmLatchClk_2
    592          	{	
    593          	case 0:
    594          		LDM_CTRL(0x0a);
                 		^
Warning[Pe223]: function "LDM_CTRL" declared implicitly
   \                     ??LdmLatchClk_0:
   \   0000001C   0xE3A0000A         MOV      R0,#+10
   \   00000020   0x........         BL       LDM_CTRL
    595          		LDM_CTRL(0x0b);
   \   00000024   0xE3A0000B         MOV      R0,#+11
   \   00000028   0x........         BL       LDM_CTRL
    596          		LDM_CTRL(0x09);
   \   0000002C   0xE3A00009         MOV      R0,#+9
   \   00000030   0x........         BL       LDM_CTRL
    597          		LDM_CTRL(0x0b);
   \   00000034   0xE3A0000B         MOV      R0,#+11
   \   00000038   0x........         BL       LDM_CTRL
    598          		LDM_CTRL(0x0a);
   \   0000003C   0xE3A0000A         MOV      R0,#+10
   \   00000040   0x........         BL       LDM_CTRL
    599          		break;
   \   00000044   0xEA000009         B        ??LdmLatchClk_2
    600          	case 1:
    601          		LDM_CTRL(0x0a);
   \                     ??LdmLatchClk_1:
   \   00000048   0xE3A0000A         MOV      R0,#+10
   \   0000004C   0x........         BL       LDM_CTRL
    602          		LDM_CTRL(0x0e);
   \   00000050   0xE3A0000E         MOV      R0,#+14
   \   00000054   0x........         BL       LDM_CTRL
    603          		LDM_CTRL(0x06);
   \   00000058   0xE3A00006         MOV      R0,#+6
   \   0000005C   0x........         BL       LDM_CTRL
    604          		LDM_CTRL(0x0e);
   \   00000060   0xE3A0000E         MOV      R0,#+14
   \   00000064   0x........         BL       LDM_CTRL
    605          		LDM_CTRL(0x0a);
   \   00000068   0xE3A0000A         MOV      R0,#+10
   \   0000006C   0x........         BL       LDM_CTRL
    606          		break;
    607          	}
    608          }
   \                     ??LdmLatchClk_2:
   \   00000070   0xE8BD4010         POP      {R4,LR}
   \   00000074   0xE12FFF1E         BX       LR               ;; return
    609          
    610          /************************************************************************
    611          	한개의 쩜을 찍는다.
    612          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    613          void PixelPut(int x,int y,UCHAR nClr)
    614          {
   \                     PixelPut:
   \   00000000   0xE92D40F0         PUSH     {R4-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
    615          	int i;
    616          	UCHAR *pAddr = (UCHAR *)AT91C_EBI_SDRAM;	
   \   00000010   0xE3A07580         MOV      R7,#+536870912
    617          
    618          	i = x+(y*SCREEN_WIDTH_MAX);
   \   00000014   0x........         LDR      R1,??DataTable5_3
   \   00000018   0xE5911000         LDR      R1,[R1, #+0]
   \   0000001C   0xE0224591         MLA      R2,R1,R5,R4
   \   00000020   0xE1B00002         MOVS     R0,R2
    619          	
    620          	if(i < (SCREEN_WIDTH_MAX*16))
   \   00000024   0x........         LDR      R1,??DataTable5_3
   \   00000028   0xE5911000         LDR      R1,[R1, #+0]
   \   0000002C   0xE1B01201         LSLS     R1,R1,#+4
   \   00000030   0xE1500001         CMP      R0,R1
   \   00000034   0xAA000001         BGE      ??PixelPut_0
    621          	{
    622          		pAddr[i] = nClr;
   \   00000038   0xE7C06007         STRB     R6,[R0, +R7]
   \   0000003C   0xEA00000C         B        ??PixelPut_1
    623          	}
    624          	else
    625          	{
    626          		i %= (SCREEN_WIDTH_MAX*16);
   \                     ??PixelPut_0:
   \   00000040   0x........         LDR      R1,??DataTable5_3
   \   00000044   0xE5911000         LDR      R1,[R1, #+0]
   \   00000048   0xE1B01201         LSLS     R1,R1,#+4
   \   0000004C   0x........         BL       __aeabi_idivmod
   \   00000050   0xE1B00001         MOVS     R0,R1
    627          		
    628          		pAddr[i] &= 0xF3;
   \   00000054   0xE7D01007         LDRB     R1,[R0, +R7]
   \   00000058   0xE3D1100C         BICS     R1,R1,#0xC
   \   0000005C   0xE7C01007         STRB     R1,[R0, +R7]
    629          		pAddr[i] |= (nClr<<2)&0x0C;
   \   00000060   0xE7D01007         LDRB     R1,[R0, +R7]
   \   00000064   0xE3A0200C         MOV      R2,#+12
   \   00000068   0xE0122106         ANDS     R2,R2,R6, LSL #+2
   \   0000006C   0xE1921001         ORRS     R1,R2,R1
   \   00000070   0xE7C01007         STRB     R1,[R0, +R7]
    630          	}
    631          	
    632          }
   \                     ??PixelPut_1:
   \   00000074   0xE8BD40F0         POP      {R4-R7,LR}
   \   00000078   0xE12FFF1E         BX       LR               ;; return
    633          
    634          /************************************************************************
    635          	한개의 숫자를 출력한다.
    636          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    637          void TextOut(int x,int y,UCHAR nChar,UCHAR nfClr,UCHAR nbClr)
    638          {
   \                     TextOut:
   \   00000000   0xE92D4FF8         PUSH     {R3-R11,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
   \   00000014   0xE5DD8028         LDRB     R8,[SP, #+40]
    639          	int i,j;
    640          	UCHAR *pAddr = (UCHAR *)AT91C_EBI_SDRAM;	
                 	       ^
Warning[Pe177]: variable "pAddr" was declared but never referenced
   \   00000018   0xE3A01580         MOV      R1,#+536870912
   \   0000001C   0xE58D1000         STR      R1,[SP, #+0]
    641          	UCHAR *pNorFlshAddr = (UCHAR *)(BOARD_NORFLASH_ADDR);
   \   00000020   0xE3A0B540         MOV      R11,#+268435456
    642          	
    643          	
    644          	nChar = nChar >= 10 ? (nChar-10)+0x21 : nChar + 0x10;
   \   00000024   0xE21660FF         ANDS     R6,R6,#0xFF      ;; Zero extend
   \   00000028   0xE356000A         CMP      R6,#+10
   \   0000002C   0x3A000001         BCC      ??TextOut_0
   \   00000030   0xE2966017         ADDS     R6,R6,#+23
   \   00000034   0xEA000000         B        ??TextOut_1
   \                     ??TextOut_0:
   \   00000038   0xE2966010         ADDS     R6,R6,#+16
    645          	
    646          	for(j=0;j<16;j++)	
   \                     ??TextOut_1:
   \   0000003C   0xE3A00000         MOV      R0,#+0
   \   00000040   0xE1B0A000         MOVS     R10,R0
   \                     ??TextOut_2:
   \   00000044   0xE35A0010         CMP      R10,#+16
   \   00000048   0xAA000019         BGE      ??TextOut_3
    647          	{
    648          		for(i=0;i<8;i++)
   \   0000004C   0xE3A00000         MOV      R0,#+0
   \   00000050   0xE1B09000         MOVS     R9,R0
   \                     ??TextOut_4:
   \   00000054   0xE3590008         CMP      R9,#+8
   \   00000058   0xAA000013         BGE      ??TextOut_5
    649          		{			
    650          			PixelPut(x+i,y+j,BitTest(pNorFlshAddr[j+nChar*16],7-i) ? nfClr : nbClr);
   \   0000005C   0xE1B00006         MOVS     R0,R6
   \   00000060   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000064   0xE3A01010         MOV      R1,#+16
   \   00000068   0xE020A091         MLA      R0,R1,R0,R10
   \   0000006C   0xE7D0000B         LDRB     R0,[R0, +R11]
   \   00000070   0xE3A01001         MOV      R1,#+1
   \   00000074   0xE1B02009         MOVS     R2,R9
   \   00000078   0xE2722007         RSBS     R2,R2,#+7
   \   0000007C   0xE1B01211         LSLS     R1,R1,R2
   \   00000080   0xE1110000         TST      R1,R0
   \   00000084   0x0A000001         BEQ      ??TextOut_6
   \   00000088   0xE1B02007         MOVS     R2,R7
   \   0000008C   0xEA000000         B        ??TextOut_7
   \                     ??TextOut_6:
   \   00000090   0xE1B02008         MOVS     R2,R8
   \                     ??TextOut_7:
   \   00000094   0xE21220FF         ANDS     R2,R2,#0xFF      ;; Zero extend
   \   00000098   0xE09A1005         ADDS     R1,R10,R5
   \   0000009C   0xE0990004         ADDS     R0,R9,R4
   \   000000A0   0x........         BL       PixelPut
    651          
    652          			//PixelPut(x+i,y+j,BitTest(gDigitName[j+LO_NIBBLE(nChar)*16],7-i) ? nfClr : nbClr);
    653          		}
   \   000000A4   0xE2999001         ADDS     R9,R9,#+1
   \   000000A8   0xEAFFFFE9         B        ??TextOut_4
    654          	}
   \                     ??TextOut_5:
   \   000000AC   0xE29AA001         ADDS     R10,R10,#+1
   \   000000B0   0xEAFFFFE3         B        ??TextOut_2
    655          }
   \                     ??TextOut_3:
   \   000000B4   0xE8BD4FF1         POP      {R0,R4-R11,LR}
   \   000000B8   0xE12FFF1E         BX       LR               ;; return
    656          
    657          /************************************************************************
    658          	이미지를 출력한다.
    659          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    660          void VersionImagePut()
    661          {
   \                     VersionImagePut:
   \   00000000   0xE92D41F0         PUSH     {R4-R8,LR}
   \   00000004   0xE24DD008         SUB      SP,SP,#+8
    662          	UCHAR i;
    663          	UCHAR *pAddr = (UCHAR *)AT91C_EBI_SDRAM;	
   \   00000008   0xE3A05580         MOV      R5,#+536870912
    664          
    665          	memset(AT91C_EBI_SDRAM,0,(SCREEN_WIDTH_MAX * 32)); // 0으로 Clear
                 	^
Warning[Pe223]: function "memset" declared implicitly

  	UCHAR *pAddr = (UCHAR *)AT91C_EBI_SDRAM;	
  	       ^
"C:\Users\jang duksu\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED\at91sam7se-ek\basic-usart-hw-handshaking-project\Download.c",663  Warning[Pe177]: 
          variable "pAddr" was declared but never referenced
   \   0000000C   0x........         LDR      R0,??DataTable5_3
   \   00000010   0xE5900000         LDR      R0,[R0, #+0]
   \   00000014   0xE1B02280         LSLS     R2,R0,#+5
   \   00000018   0xE3A01000         MOV      R1,#+0
   \   0000001C   0xE3A00580         MOV      R0,#+536870912
   \   00000020   0x........         BL       memset
    666          
    667          	// 다운로더 버젼번호
    668          	TextOut(SCREEN_CENTER_POS + 0,0,HI_NIBBLE(VERSION),1,0);
   \   00000024   0xE3A00000         MOV      R0,#+0
   \   00000028   0xE58D0000         STR      R0,[SP, #+0]
   \   0000002C   0xE3A03001         MOV      R3,#+1
   \   00000030   0xE3A02001         MOV      R2,#+1
   \   00000034   0xE3A01000         MOV      R1,#+0
   \   00000038   0xE1B06001         MOVS     R6,R1
   \   0000003C   0xE1B07002         MOVS     R7,R2
   \   00000040   0xE1B08003         MOVS     R8,R3
   \   00000044   0x........         LDR      R0,??DataTable5_3
   \   00000048   0xE5900000         LDR      R0,[R0, #+0]
   \   0000004C   0xE3A01002         MOV      R1,#+2
   \   00000050   0x........         BL       __aeabi_idiv
   \   00000054   0xE2500010         SUBS     R0,R0,#+16
   \   00000058   0xE1B03008         MOVS     R3,R8
   \   0000005C   0xE1B02007         MOVS     R2,R7
   \   00000060   0xE1B01006         MOVS     R1,R6
   \   00000064   0x........         BL       TextOut
    669          	TextOut(SCREEN_CENTER_POS + 8,0,LO_NIBBLE(VERSION),1,0);
   \   00000068   0xE3A00000         MOV      R0,#+0
   \   0000006C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000070   0xE3A03001         MOV      R3,#+1
   \   00000074   0xE3A02000         MOV      R2,#+0
   \   00000078   0xE3A01000         MOV      R1,#+0
   \   0000007C   0xE1B06001         MOVS     R6,R1
   \   00000080   0xE1B07002         MOVS     R7,R2
   \   00000084   0xE1B08003         MOVS     R8,R3
   \   00000088   0x........         LDR      R0,??DataTable5_3
   \   0000008C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000090   0xE3A01002         MOV      R1,#+2
   \   00000094   0x........         BL       __aeabi_idiv
   \   00000098   0xE2500008         SUBS     R0,R0,#+8
   \   0000009C   0xE1B03008         MOVS     R3,R8
   \   000000A0   0xE1B02007         MOVS     R2,R7
   \   000000A4   0xE1B01006         MOVS     R1,R6
   \   000000A8   0x........         BL       TextOut
    670          			
    671          	// 표시기 폼웨어 버젼번호
    672          	i = 11;//GetFirmWareVersion();
   \   000000AC   0xE3A0000B         MOV      R0,#+11
   \   000000B0   0xE1B04000         MOVS     R4,R0
    673          	TextOut(SCREEN_CENTER_POS + 16,0,HI_NIBBLE(i),2,0);
   \   000000B4   0xE3A00000         MOV      R0,#+0
   \   000000B8   0xE58D0000         STR      R0,[SP, #+0]
   \   000000BC   0xE3A03002         MOV      R3,#+2
   \   000000C0   0xE21440FF         ANDS     R4,R4,#0xFF      ;; Zero extend
   \   000000C4   0xE1B02224         LSRS     R2,R4,#+4
   \   000000C8   0xE3A01000         MOV      R1,#+0
   \   000000CC   0xE1B06001         MOVS     R6,R1
   \   000000D0   0xE1B07002         MOVS     R7,R2
   \   000000D4   0xE1B08003         MOVS     R8,R3
   \   000000D8   0x........         LDR      R0,??DataTable5_3
   \   000000DC   0xE5900000         LDR      R0,[R0, #+0]
   \   000000E0   0xE3A01002         MOV      R1,#+2
   \   000000E4   0x........         BL       __aeabi_idiv
   \   000000E8   0xE1B03008         MOVS     R3,R8
   \   000000EC   0xE1B02007         MOVS     R2,R7
   \   000000F0   0xE1B01006         MOVS     R1,R6
   \   000000F4   0x........         BL       TextOut
    674          	TextOut(SCREEN_CENTER_POS + 24,0,LO_NIBBLE(i),2,0);
   \   000000F8   0xE3A00000         MOV      R0,#+0
   \   000000FC   0xE58D0000         STR      R0,[SP, #+0]
   \   00000100   0xE3A03002         MOV      R3,#+2
   \   00000104   0xE214200F         ANDS     R2,R4,#0xF
   \   00000108   0xE3A01000         MOV      R1,#+0
   \   0000010C   0xE1B06001         MOVS     R6,R1
   \   00000110   0xE1B07002         MOVS     R7,R2
   \   00000114   0xE1B08003         MOVS     R8,R3
   \   00000118   0x........         LDR      R0,??DataTable5_3
   \   0000011C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000120   0xE3A01002         MOV      R1,#+2
   \   00000124   0x........         BL       __aeabi_idiv
   \   00000128   0xE2900008         ADDS     R0,R0,#+8
   \   0000012C   0xE1B03008         MOVS     R3,R8
   \   00000130   0xE1B02007         MOVS     R2,R7
   \   00000134   0xE1B01006         MOVS     R1,R6
   \   00000138   0x........         BL       TextOut
    675          }
   \   0000013C   0xE8BD41F3         POP      {R0,R1,R4-R8,LR}
   \   00000140   0xE12FFF1E         BX       LR               ;; return
    676          
    677          /************************************************************************
    678          	Timer0 - Interrupt Routine [1ms]
    679          *************************************************************************/

   \                                 In section .text, align 4, keep-with-next
    680          void Down_int09(void) // Timer 0
    681          {
    682          	static DWORD nBlk = 0;
                 	             ^
Warning[Pe177]: variable "nBlk" was declared but never referenced
    683          	
    684          	if(gTxEnableTimerCnt) gTxEnableTimerCnt--;
   \                     Down_int09:
   \   00000000   0x........         LDR      R0,??DataTable5_9
   \   00000004   0xE5900000         LDR      R0,[R0, #+0]
   \   00000008   0xE3500000         CMP      R0,#+0
   \   0000000C   0x0A000004         BEQ      ??Down_int09_0
   \   00000010   0x........         LDR      R0,??DataTable5_9
   \   00000014   0xE5900000         LDR      R0,[R0, #+0]
   \   00000018   0xE2500001         SUBS     R0,R0,#+1
   \   0000001C   0x........         LDR      R1,??DataTable5_9
   \   00000020   0xE5810000         STR      R0,[R1, #+0]
    685               
    686          	//if(gTxDisableTimerCnt == 1) RS485_TX_DISABLE;
    687          	if(gTxDisableTimerCnt) gTxDisableTimerCnt--;
   \                     ??Down_int09_0:
   \   00000024   0x........         LDR      R0,??DataTable5_10
   \   00000028   0xE5900000         LDR      R0,[R0, #+0]
   \   0000002C   0xE3500000         CMP      R0,#+0
   \   00000030   0x0A000004         BEQ      ??Down_int09_1
   \   00000034   0x........         LDR      R0,??DataTable5_10
   \   00000038   0xE5900000         LDR      R0,[R0, #+0]
   \   0000003C   0xE2500001         SUBS     R0,R0,#+1
   \   00000040   0x........         LDR      R1,??DataTable5_10
   \   00000044   0xE5810000         STR      R0,[R1, #+0]
    688                  
    689          
    690          	gFirmWareExeTime++;
   \                     ??Down_int09_1:
   \   00000048   0x........         LDR      R0,??DataTable5_11
   \   0000004C   0xE5900000         LDR      R0,[R0, #+0]
   \   00000050   0xE2900001         ADDS     R0,R0,#+1
   \   00000054   0x........         LDR      R1,??DataTable5_11
   \   00000058   0xE5810000         STR      R0,[R1, #+0]
    691          
    692          }
   \   0000005C   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5:
   \   00000000   0x........         DC32     SCC1_Init_AChl

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_1:
   \   00000000   0xFFFA0040         DC32     0xfffa0040

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_2:
   \   00000000   0x........         DC32     mBlockSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_3:
   \   00000000   0x........         DC32     SCREEN_WIDTH_MAX

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_4:
   \   00000000   0x........         DC32     gFirmWareExeFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_5:
   \   00000000   0x........         DC32     gVersionPrintFlag

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_6:
   \   00000000   0x........         DC32     norFlash+0x4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_7:
   \   00000000   0x........         DC32     norFlash

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_8:
   \   00000000   0x........         DC32     mBlackChick

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_9:
   \   00000000   0x........         DC32     gTxEnableTimerCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_10:
   \   00000000   0x........         DC32     gTxDisableTimerCnt

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable5_11:
   \   00000000   0x........         DC32     gFirmWareExeTime
    693          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  Down_int09
        0  Download_Init
      256  Download_main
             256 -> ADD_CHECK
             256 -> IsDisplayAddressOk
             256 -> IsPrintOfVersion
             256 -> NORFLASH_EraseSector
             256 -> NORFLASH_WriteData
             256 -> NorFlash_GetDeviceBlockSize
             256 -> NorFlash_GetDeviceNumOfBlocks
             256 -> NorFlash_GetDeviceSectorAddress
             256 -> PixelPut
             256 -> SendStatusReq
             256 -> TC_Stop
             256 -> VersionImagePut
             256 -> __aeabi_idiv
             256 -> __aeabi_idivmod
             256 -> memcpy
        0  GetFirmWareVersion
        8  IsDisplayAddressOk
               8 -> ADD_CHECK
        8  IsPrintOfVersion
               8 -> ADD_CHECK
        8  LdmLatchClk
               8 -> LDM_CTRL
        0  OneChar2HEX
       20  PixelPut
              20 -> __aeabi_idivmod
        8  ScreenWidth
               8 -> ADD_CHECK
       56  SendStatusReq
              56 -> cal_CRC16
              56 -> memcpy
       40  TextOut
              40 -> PixelPut
       16  TwoChar2HEX
              16 -> OneChar2HEX
       32  VersionImagePut
              32 -> TextOut
              32 -> __aeabi_idiv
              32 -> memset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
      96  Down_int09
       4  Download_Init
     912  Download_main
       4  GetFirmWareVersion
     300  IsDisplayAddressOk
      56  IsPrintOfVersion
     120  LdmLatchClk
     120  OneChar2HEX
     124  PixelPut
       4  SCREEN_WIDTH_MAX
     280  ScreenWidth
     484  SendStatusReq
     188  TextOut
      60  TwoChar2HEX
     324  VersionImagePut
     256  gDigitName
       4  gERASE_OkFlag
       4  gFirmWareExeFlag
       4  gFirmWareExeTime
       4  gTxDisableTimerCnt
       4  gTxEnableTimerCnt
      64  gVerName
       4  gVersionPrintFlag
     400  mBlackChick
       4  mBlockSize

 
   424 bytes in section .bss
   328 bytes in section .data
 3 120 bytes in section .text
 
 3 120 bytes of CODE memory
   752 bytes of DATA memory

Errors: none
Warnings: 19
