###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     15/Apr/2013  10:54:46 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91lib\peripherals\usart\usart.c             #
#    Command line =  "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91lib\peripherals\usart\usart.c" -D         #
#                    at91sam7se512 -D sram -D TRACE_LEVEL=4 -lC               #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\List\" --remarks              #
#                    --diag_suppress Pe826,Pe1375 -o                          #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\Obj\" --no_cse --no_unroll    #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\JDS\Desktop\JDS_PRO\국내               #
#                    프로젝트\대구 모노레일\프로그램\basic-usart-hw-handshaki #
#                    ng-project-at91sam7se-ek\at91sam7se-ek\basic-usart-hw-ha #
#                    ndshaking-project\ewp\..\..\..\at91lib/peripherals\" -I  #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib\" -I                            #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib/components\" -I                 #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"          #
#                    --interwork --cpu_mode arm -Oh --use_c++_inline          #
#    List file    =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\List\usart.lst                #
#    Object file  =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\Obj\usart.o                   #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\basic-usart-hw-handshaking-project-at91sam7se-ek\at91lib\peripherals\usart\usart.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "usart.h"
     35          #include <utility/trace.h>
     36          #include <utility/assert.h>
     37          
     38          //------------------------------------------------------------------------------
     39          //         Exported functions
     40          //------------------------------------------------------------------------------
     41          //------------------------------------------------------------------------------
     42          /// Configures an USART peripheral with the specified parameters.
     43          /// \param usart  Pointer to the USART peripheral to configure.
     44          /// \param mode  Desired value for the USART mode register (see the datasheet).
     45          /// \param baudrate  Baudrate at which the USART should operate (in Hz).
     46          /// \param masterClock  Frequency of the system master clock (in Hz).
     47          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     48          void USART_Configure(AT91S_USART *usart,
     49                                      unsigned int mode,
     50                                      unsigned int baudrate,
     51                                      unsigned int masterClock)
     52          {
   \                     USART_Configure:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1A04000         MOV      R4,R0
   \   00000008   0xE1A00003         MOV      R0,R3
     53              // Reset and disable receiver & transmitter
     54              usart->US_CR = AT91C_US_RSTRX | AT91C_US_RSTTX
     55                             | AT91C_US_RXDIS | AT91C_US_TXDIS;
   \   0000000C   0xE3A030AC         MOV      R3,#+172
   \   00000010   0xE5843000         STR      R3,[R4, #+0]
     56          
     57              // Configure mode
     58              usart->US_MR = mode;
   \   00000014   0xE5841004         STR      R1,[R4, #+4]
     59          
     60              // Configure baudrate
     61              // Asynchronous, no oversampling
     62              if (((mode & AT91C_US_SYNC) == 0)
     63                  && ((mode & AT91C_US_OVER) == 0)) {
   \   00000018   0xE3A03A80         MOV      R3,#+524288
   \   0000001C   0xE3833F40         ORR      R3,R3,#0x100
   \   00000020   0xE1130001         TST      R3,R1
   \   00000024   0x1A000003         BNE      ??USART_Configure_0
     64              
     65                  usart->US_BRGR = (masterClock / baudrate) / 16;
   \   00000028   0xE1A01002         MOV      R1,R2
   \   0000002C   0x........         BL       __aeabi_uidiv
   \   00000030   0xE1A00220         LSR      R0,R0,#+4
   \   00000034   0xE5840020         STR      R0,[R4, #+32]
     66              }
     67              // TODO other modes
     68          }
   \                     ??USART_Configure_0:
   \   00000038   0xE8BD4010         POP      {R4,LR}
   \   0000003C   0xE12FFF1E         BX       LR               ;; return
     69          
     70          //------------------------------------------------------------------------------
     71          /// Enables or disables the transmitter of an USART peripheral.
     72          /// \param usart  Pointer to an USART peripheral
     73          /// \param enabled  If true, the transmitter is enabled; otherwise it is
     74          ///                 disabled.
     75          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     76          void USART_SetTransmitterEnabled(AT91S_USART *usart,
     77                                                  unsigned char enabled)
     78          {
     79              if (enabled) {
   \                     USART_SetTransmitterEnabled:
   \   00000000   0xE3510000         CMP      R1,#+0
     80          
     81                  usart->US_CR = AT91C_US_TXEN;
   \   00000004   0x13A01040         MOVNE    R1,#+64
     82              }
     83              else {
     84          
     85                  usart->US_CR = AT91C_US_TXDIS;
   \   00000008   0x03A01080         MOVEQ    R1,#+128
   \   0000000C   0xE5801000         STR      R1,[R0, #+0]
     86              }
     87          }
   \   00000010   0xE12FFF1E         BX       LR               ;; return
     88          
     89          //------------------------------------------------------------------------------
     90          /// Enables or disables the receiver of an USART peripheral
     91          /// \param usart  Pointer to an USART peripheral
     92          /// \param enabled  If true, the receiver is enabled; otherwise it is disabled.
     93          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     94          void USART_SetReceiverEnabled(AT91S_USART *usart,
     95                                               unsigned char enabled)
     96          {
     97              if (enabled) {
   \                     USART_SetReceiverEnabled:
   \   00000000   0xE3510000         CMP      R1,#+0
     98          
     99                  usart->US_CR = AT91C_US_RXEN;
   \   00000004   0x13A01010         MOVNE    R1,#+16
    100              }
    101              else {
    102          
    103                  usart->US_CR = AT91C_US_RXDIS;
   \   00000008   0x03A01020         MOVEQ    R1,#+32
   \   0000000C   0xE5801000         STR      R1,[R0, #+0]
    104              }
    105          }
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    106          
    107          //------------------------------------------------------------------------------
    108          /// Sends one packet of data through the specified USART peripheral. This
    109          /// function operates synchronously, so it only returns when the data has been
    110          /// actually sent.
    111          /// \param usart  Pointer to an USART peripheral.
    112          /// \param data  Data to send including 9nth bit and sync field if necessary (in
    113          ///              the same format as the US_THR register in the datasheet).
    114          /// \param timeOut  Time out value (0 = no timeout).
    115          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    116          void USART_Write(
    117              AT91S_USART *usart,
    118              unsigned short data,
    119              volatile unsigned int timeOut)
    120          {
   \                     USART_Write:
   \   00000000   0xE24DD004         SUB      SP,SP,#+4
   \   00000004   0xE92D0004         PUSH     {R2}
    121              if (timeOut == 0) {
   \   00000008   0xE59D2000         LDR      R2,[SP, #+0]
   \   0000000C   0xE3520000         CMP      R2,#+0
   \   00000010   0x1A000008         BNE      ??USART_Write_0
    122          
    123                  while ((usart->US_CSR & AT91C_US_TXEMPTY) == 0);
   \                     ??USART_Write_1:
   \   00000014   0xE5902014         LDR      R2,[R0, #+20]
   \   00000018   0xE3120F80         TST      R2,#0x200
   \   0000001C   0x0AFFFFFC         BEQ      ??USART_Write_1
    124              }
    125              else {
    126          
    127                  while ((usart->US_CSR & AT91C_US_TXEMPTY) == 0) {
    128          
    129                      if (timeOut == 0) {
    130          
    131                          TRACE_ERROR("USART_Write: Timed out.\n\r");
    132                          return;
    133                      }
    134                      timeOut--;
    135                  }
    136              }
    137          
    138              usart->US_THR = data;
   \                     ??USART_Write_2:
   \   00000020   0xE580101C         STR      R1,[R0, #+28]
    139          }
   \   00000024   0xE28DD008         ADD      SP,SP,#+8        ;; stack cleaning
   \   00000028   0xE12FFF1E         BX       LR               ;; return
   \                     ??USART_Write_3:
   \   0000002C   0xE59D2000         LDR      R2,[SP, #+0]
   \   00000030   0xE2422001         SUB      R2,R2,#+1
   \   00000034   0xE58D2000         STR      R2,[SP, #+0]
   \                     ??USART_Write_0:
   \   00000038   0xE5902014         LDR      R2,[R0, #+20]
   \   0000003C   0xE3120F80         TST      R2,#0x200
   \   00000040   0x1AFFFFF6         BNE      ??USART_Write_2
   \   00000044   0xE59D2000         LDR      R2,[SP, #+0]
   \   00000048   0xE3520000         CMP      R2,#+0
   \   0000004C   0x1AFFFFF6         BNE      ??USART_Write_3
   \   00000050   0x........         LDR      R0,??DataTable2
   \   00000054   0xE28DD008         ADD      SP,SP,#+8        ;; stack cleaning
   \   00000058   0x........         B        printf           ;; tailcall
    140          
    141          //------------------------------------------------------------------------------
    142          /// Sends the contents of a data buffer through the specified USART peripheral.
    143          /// This function returns immediately (1 if the buffer has been queued, 0
    144          /// otherwise); poll the ENDTX and TXBUFE bits of the USART status register
    145          /// to check for the transfer completion.
    146          /// \param usart  Pointer to an USART peripheral.
    147          /// \param buffer  Pointer to the data buffer to send.
    148          /// \param size  Size of the data buffer (in bytes).
    149          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    150          unsigned char USART_WriteBuffer(
    151              AT91S_USART *usart,
    152              void *buffer,
    153              unsigned int size)
    154          {
    155              // Check if the first PDC bank is free
    156              if ((usart->US_TCR == 0) && (usart->US_TNCR == 0)) {
   \                     USART_WriteBuffer:
   \   00000000   0xE590310C         LDR      R3,[R0, #+268]
   \   00000004   0xE3530000         CMP      R3,#+0
   \   00000008   0x0590311C         LDREQ    R3,[R0, #+284]
   \   0000000C   0x03530000         CMPEQ    R3,#+0
   \   00000010   0x1A000003         BNE      ??USART_WriteBuffer_0
    157          
    158                  usart->US_TPR = (unsigned int) buffer;
   \   00000014   0xE5801108         STR      R1,[R0, #+264]
    159                  usart->US_TCR = size;
   \   00000018   0xE580210C         STR      R2,[R0, #+268]
    160                  usart->US_PTCR = AT91C_PDC_TXTEN;
   \   0000001C   0xE3A01F40         MOV      R1,#+256
   \   00000020   0x........         B        ?Subroutine0
    161          
    162                  return 1;
    163              }
    164              // Check if the second PDC bank is free
    165              else if (usart->US_TNCR == 0) {
   \                     ??USART_WriteBuffer_0:
   \   00000024   0xE590311C         LDR      R3,[R0, #+284]
   \   00000028   0xE3530000         CMP      R3,#+0
   \   0000002C   0x1A000002         BNE      ??USART_WriteBuffer_1
    166          
    167                  usart->US_TNPR = (unsigned int) buffer;
   \   00000030   0xE5801118         STR      R1,[R0, #+280]
    168                  usart->US_TNCR = size;
   \   00000034   0xE580211C         STR      R2,[R0, #+284]
    169          
    170                  return 1;
   \   00000038   0x........         B        ??Subroutine0_0
    171              }
    172              else {
    173          
    174                  return 0;
   \                     ??USART_WriteBuffer_1:
   \   0000003C   0xE3A00000         MOV      R0,#+0
   \   00000040   0xE12FFF1E         BX       LR               ;; return
    175              }
    176          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE5801120         STR      R1,[R0, #+288]
   \                     ??Subroutine0_0:
   \   00000004   0xE3A00001         MOV      R0,#+1
   \   00000008   0xE12FFF1E         BX       LR
    177          
    178          //------------------------------------------------------------------------------
    179          /// Reads and return a packet of data on the specified USART peripheral. This
    180          /// function operates asynchronously, so it waits until some data has been
    181          /// received.
    182          /// \param usart  Pointer to an USART peripheral.
    183          /// \param timeOut  Time out value (0 -> no timeout).
    184          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    185          unsigned short USART_Read(
    186              AT91S_USART *usart,
    187              volatile unsigned int timeOut)
    188          {
   \                     USART_Read:
   \   00000000   0xE92D4002         PUSH     {R1,LR}
    189              if (timeOut == 0) {
   \   00000004   0xE59D1000         LDR      R1,[SP, #+0]
   \   00000008   0xE3510000         CMP      R1,#+0
   \   0000000C   0x1A00000A         BNE      ??USART_Read_0
    190          
    191                  while ((usart->US_CSR & AT91C_US_RXRDY) == 0);
   \                     ??USART_Read_1:
   \   00000010   0xE5901014         LDR      R1,[R0, #+20]
   \   00000014   0xE3110001         TST      R1,#0x1
   \   00000018   0x0AFFFFFC         BEQ      ??USART_Read_1
    192              }
    193              else {
    194          
    195                  while ((usart->US_CSR & AT91C_US_RXRDY) == 0) {
    196          
    197                      if (timeOut == 0) {
    198          
    199                          TRACE_ERROR("USART_Read: Timed out.\n\r");
    200                          return 0;
    201                      }
    202                      timeOut--;
    203                  }
    204              }
    205          
    206              return usart->US_RHR;
   \                     ??USART_Read_2:
   \   0000001C   0xE5900018         LDR      R0,[R0, #+24]
   \   00000020   0xE1A00800         LSL      R0,R0,#+16
   \   00000024   0xE1A00820         LSR      R0,R0,#+16
   \                     ??USART_Read_3:
   \   00000028   0xE8BD4002         POP      {R1,LR}
   \   0000002C   0xE12FFF1E         BX       LR               ;; return
   \                     ??USART_Read_4:
   \   00000030   0xE59D1000         LDR      R1,[SP, #+0]
   \   00000034   0xE2411001         SUB      R1,R1,#+1
   \   00000038   0xE58D1000         STR      R1,[SP, #+0]
   \                     ??USART_Read_0:
   \   0000003C   0xE5901014         LDR      R1,[R0, #+20]
   \   00000040   0xE3110001         TST      R1,#0x1
   \   00000044   0x1AFFFFF4         BNE      ??USART_Read_2
   \   00000048   0xE59D1000         LDR      R1,[SP, #+0]
   \   0000004C   0xE3510000         CMP      R1,#+0
   \   00000050   0x1AFFFFF6         BNE      ??USART_Read_4
   \   00000054   0x........         LDR      R0,??DataTable2_1
   \   00000058   0x........         BL       printf
   \   0000005C   0xE3A00000         MOV      R0,#+0
   \   00000060   0xEAFFFFF0         B        ??USART_Read_3
    207          }
    208          
    209          //------------------------------------------------------------------------------
    210          /// Reads data from an USART peripheral, filling the provided buffer until it
    211          /// becomes full. This function returns immediately with 1 if the buffer has
    212          /// been queued for transmission; otherwise 0.
    213          /// \param usart  Pointer to an USART peripheral.
    214          /// \param buffer  Pointer to the buffer where the received data will be stored.
    215          /// \param size  Size of the data buffer (in bytes).
    216          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    217          unsigned char USART_ReadBuffer(AT91S_USART *usart,
    218                                                void *buffer,
    219                                                unsigned int size)
    220          {
    221              // Check if the first PDC bank is free
    222              if ((usart->US_RCR == 0) && (usart->US_RNCR == 0)) {
   \                     USART_ReadBuffer:
   \   00000000   0xE5903104         LDR      R3,[R0, #+260]
   \   00000004   0xE3530000         CMP      R3,#+0
   \   00000008   0x05903114         LDREQ    R3,[R0, #+276]
   \   0000000C   0x03530000         CMPEQ    R3,#+0
   \   00000010   0x1A000003         BNE      ??USART_ReadBuffer_0
    223          
    224                  usart->US_RPR = (unsigned int) buffer;
   \   00000014   0xE5801100         STR      R1,[R0, #+256]
    225                  usart->US_RCR = size;
   \   00000018   0xE5802104         STR      R2,[R0, #+260]
    226                  usart->US_PTCR = AT91C_PDC_RXTEN;
   \   0000001C   0xE3A01001         MOV      R1,#+1
   \   00000020   0x........         B        ?Subroutine0
    227          
    228                  return 1;
    229              }
    230              // Check if the second PDC bank is free
    231              else if (usart->US_RNCR == 0) {
   \                     ??USART_ReadBuffer_0:
   \   00000024   0xE5903114         LDR      R3,[R0, #+276]
   \   00000028   0xE3530000         CMP      R3,#+0
    232          
    233                  usart->US_RNPR = (unsigned int) buffer;
   \   0000002C   0x05801110         STREQ    R1,[R0, #+272]
    234                  usart->US_RNCR = size;
   \   00000030   0x05802114         STREQ    R2,[R0, #+276]
    235          
    236                  return 1;
   \   00000034   0x03A00001         MOVEQ    R0,#+1
    237              }
    238              else {
    239          
    240                  return 0;
   \   00000038   0x13A00000         MOVNE    R0,#+0
   \   0000003C   0xE12FFF1E         BX       LR               ;; return
    241              }
    242          }
    243          
    244          //------------------------------------------------------------------------------
    245          /// Returns 1 if some data has been received and can be read from an USART;
    246          /// otherwise returns 0.
    247          /// \param usart  Pointer to an AT91S_USART instance.
    248          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    249          unsigned char USART_IsDataAvailable(AT91S_USART *usart)
    250          {
    251              if ((usart->US_CSR & AT91C_US_RXRDY) != 0) {
   \                     USART_IsDataAvailable:
   \   00000000   0xE5900014         LDR      R0,[R0, #+20]
   \   00000004   0xE3100001         TST      R0,#0x1
    252          
    253                  return 1;
   \   00000008   0x13A00001         MOVNE    R0,#+1
    254              }
    255              else {
    256          
    257                  return 0;
   \   0000000C   0x03A00000         MOVEQ    R0,#+0
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    258              }
    259          }
    260          
    261          //------------------------------------------------------------------------------
    262          /// Sets the filter value for the IRDA demodulator.
    263          /// \param pUsart  Pointer to an AT91S_USART instance.
    264          /// \param filter  Filter value.
    265          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    266          void USART_SetIrdaFilter(AT91S_USART *pUsart, unsigned char filter)
    267          {
   \                     USART_SetIrdaFilter:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    268              SANITY_CHECK(pUsart);
   \   00000004   0xE3500000         CMP      R0,#+0
   \   00000008   0x1A000006         BNE      ??USART_SetIrdaFilter_0
   \   0000000C   0x........         LDR      R0,??DataTable2_2
   \   00000010   0x........         BL       printf
   \   00000014   0xE3A02F43         MOV      R2,#+268
   \   00000018   0x........         LDR      R1,??DataTable2_3
   \   0000001C   0x........         LDR      R0,??DataTable2_4
   \   00000020   0x........         BL       printf
   \                     ??USART_SetIrdaFilter_1:
   \   00000024   0xEAFFFFFE         B        ??USART_SetIrdaFilter_1
    269          
    270              pUsart->US_IF = filter;
   \                     ??USART_SetIrdaFilter_0:
   \   00000028   0xE580104C         STR      R1,[R0, #+76]
    271          }
   \   0000002C   0xE8BD4001         POP      {R0,LR}
   \   00000030   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2:
   \   00000000   0x........         DC32     `?<Constant "-E- USART_Write: Time...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_1:
   \   00000000   0x........         DC32     `?<Constant "-E- USART_Read: Timed...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_2:
   \   00000000   0x........         DC32     `?<Constant "-F- ASSERT: ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_3:
   \   00000000   0x........         DC32     `?<Constant "C:\\\\Users\\\\JDS\\\\Desktop\\\\...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable2_4:
   \   00000000   0x........         DC32     `?<Constant "Sanity check failed a...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- USART_Write: Time...">`:
   \   00000000   0x2D 0x45          DC8 "-E- USART_Write: Timed out.\012\015"
   \              0x2D 0x20    
   \              0x55 0x53    
   \              0x41 0x52    
   \              0x54 0x5F    
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x3A    
   \              0x20 0x54    
   \              0x69 0x6D    
   \              0x65 0x64    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x2E 0x0A    
   \              0x0D 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-E- USART_Read: Timed...">`:
   \   00000000   0x2D 0x45          DC8 "-E- USART_Read: Timed out.\012\015"
   \              0x2D 0x20    
   \              0x55 0x53    
   \              0x41 0x52    
   \              0x54 0x5F    
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x3A 0x20    
   \              0x54 0x69    
   \              0x6D 0x65    
   \              0x64 0x20    
   \              0x6F 0x75    
   \              0x74 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- ASSERT: ">`:
   \   00000000   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sanity check failed a...">`:
   \   00000000   0x53 0x61          DC8 "Sanity check failed at %s:%d\012\015"
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x20 0x63    
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x73 0x3A    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "C:\\\\Users\\\\JDS\\\\Desktop\\\\...">`:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x4A          DC8 5CH, 4AH, 44H, 53H, 5CH, 44H, 65H, 73H
   \              0x44 0x53    
   \              0x5C 0x44    
   \              0x65 0x73    
   \   00000010   0x6B 0x74          DC8 6BH, 74H, 6FH, 70H, 5CH, 4AH, 44H, 53H
   \              0x6F 0x70    
   \              0x5C 0x4A    
   \              0x44 0x53    
   \   00000018   0x5F 0x50          DC8 5FH, 50H, 52H, 4FH, 5CH, 0B1H, 0B9H, 0B3H
   \              0x52 0x4F    
   \              0x5C 0xB1    
   \              0xB9 0xB3    
   \   00000020   0xBB 0x20          DC8 0BBH, 20H, 0C7H, 0C1H, 0B7H, 0CEH, 0C1H, 0A7H
   \              0xC7 0xC1    
   \              0xB7 0xCE    
   \              0xC1 0xA7    
   \   00000028   0xC6 0xAE          DC8 0C6H, 0AEH, 5CH, 0B4H, 0EBH, 0B1H, 0B8H, 20H
   \              0x5C 0xB4    
   \              0xEB 0xB1    
   \              0xB8 0x20    
   \   00000030   0xB8 0xF0          DC8 0B8H, 0F0H, 0B3H, 0EBH, 0B7H, 0B9H, 0C0H, 0CFH
   \              0xB3 0xEB    
   \              0xB7 0xB9    
   \              0xC0 0xCF    
   \   00000038   0x5C 0xC7          DC8 5CH, 0C7H, 0C1H, 0B7H, 0CEH, 0B1H, 0D7H, 0B7H
   \              0xC1 0xB7    
   \              0xCE 0xB1    
   \              0xD7 0xB7    
   \   00000040   0xA5 0x5C          DC8 0A5H, 5CH, 62H, 61H, 73H, 69H, 63H, 2DH
   \              0x62 0x61    
   \              0x73 0x69    
   \              0x63 0x2D    
   \   00000048   0x75 0x73          DC8 75H, 73H, 61H, 72H, 74H, 2DH, 68H, 77H
   \              0x61 0x72    
   \              0x74 0x2D    
   \              0x68 0x77    
   \   00000050   0x2D 0x68          DC8 2DH, 68H, 61H, 6EH, 64H, 73H, 68H, 61H
   \              0x61 0x6E    
   \              0x64 0x73    
   \              0x68 0x61    
   \   00000058   0x6B 0x69          DC8 6BH, 69H, 6EH, 67H, 2DH, 70H, 72H, 6FH
   \              0x6E 0x67    
   \              0x2D 0x70    
   \              0x72 0x6F    
   \   00000060   0x6A 0x65          DC8 6AH, 65H, 63H, 74H, 2DH, 61H, 74H, 39H
   \              0x63 0x74    
   \              0x2D 0x61    
   \              0x74 0x39    
   \   00000068   0x31 0x73          DC8 31H, 73H, 61H, 6DH, 37H, 73H, 65H, 2DH
   \              0x61 0x6D    
   \              0x37 0x73    
   \              0x65 0x2D    
   \   00000070   0x65 0x6B          DC8 65H, 6BH, 5CH, 61H, 74H, 39H, 31H, 6CH
   \              0x5C 0x61    
   \              0x74 0x39    
   \              0x31 0x6C    
   \   00000078   0x69 0x62          DC8 69H, 62H, 5CH, 70H, 65H, 72H, 69H, 70H
   \              0x5C 0x70    
   \              0x65 0x72    
   \              0x69 0x70    
   \   00000080   0x68 0x65          DC8 68H, 65H, 72H, 61H, 6CH, 73H, 5CH, 75H
   \              0x72 0x61    
   \              0x6C 0x73    
   \              0x5C 0x75    
   \   00000088   0x73 0x61          DC8 73H, 61H, 72H, 74H, 5CH, 75H, 73H, 61H
   \              0x72 0x74    
   \              0x5C 0x75    
   \              0x73 0x61    
   \   00000090   0x72 0x74          DC8 72H, 74H, 2EH, 63H, 0
   \              0x2E 0x63    
   \              0x00         
   \   00000095   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    272          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        8  USART_Configure
             8 -> __aeabi_uidiv
        0  USART_IsDataAvailable
        8  USART_Read
             8 -> printf
        0  USART_ReadBuffer
        8  USART_SetIrdaFilter
             8 -> printf
        0  USART_SetReceiverEnabled
        0  USART_SetTransmitterEnabled
        8  USART_Write
             0 -> printf
        0  USART_WriteBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      32  ?<Constant "-E- USART_Read: Timed...">
      32  ?<Constant "-E- USART_Write: Time...">
      16  ?<Constant "-F- ASSERT: ">
     152  ?<Constant "C:\\Users\\JDS\\Desktop\\...">
      32  ?<Constant "Sanity check failed a...">
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
      12  ?Subroutine0
      64  USART_Configure
      20  USART_IsDataAvailable
     100  USART_Read
      64  USART_ReadBuffer
      52  USART_SetIrdaFilter
      20  USART_SetReceiverEnabled
      20  USART_SetTransmitterEnabled
      92  USART_Write
      68  USART_WriteBuffer

 
 264 bytes in section .rodata
 532 bytes in section .text
 
 532 bytes of CODE  memory
 264 bytes of CONST memory

Errors: none
Warnings: none
