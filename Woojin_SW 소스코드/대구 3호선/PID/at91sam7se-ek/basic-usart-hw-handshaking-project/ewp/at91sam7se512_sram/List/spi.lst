###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     15/Apr/2013  10:54:45 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91lib\peripherals\spi\spi.c                 #
#    Command line =  "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91lib\peripherals\spi\spi.c" -D             #
#                    at91sam7se512 -D sram -D TRACE_LEVEL=4 -lC               #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\List\" --remarks              #
#                    --diag_suppress Pe826,Pe1375 -o                          #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\Obj\" --no_cse --no_unroll    #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\JDS\Desktop\JDS_PRO\국내               #
#                    프로젝트\대구 모노레일\프로그램\basic-usart-hw-handshaki #
#                    ng-project-at91sam7se-ek\at91sam7se-ek\basic-usart-hw-ha #
#                    ndshaking-project\ewp\..\..\..\at91lib/peripherals\" -I  #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib\" -I                            #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib/components\" -I                 #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"          #
#                    --interwork --cpu_mode arm -Oh --use_c++_inline          #
#    List file    =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\List\spi.lst                  #
#    Object file  =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\Obj\spi.o                     #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\basic-usart-hw-handshaking-project-at91sam7se-ek\at91lib\peripherals\spi\spi.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "spi.h"
     35          
     36          //------------------------------------------------------------------------------
     37          //         Exported functions
     38          //------------------------------------------------------------------------------
     39          //------------------------------------------------------------------------------
     40          /// Enables a SPI peripheral
     41          /// \param spi  Pointer to an AT91S_SPI instance.
     42          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     43          void SPI_Enable(AT91S_SPI *spi)
     44          {
     45              spi->SPI_CR = AT91C_SPI_SPIEN;
   \                     SPI_Enable:
   \   00000000   0xE3A01001         MOV      R1,#+1
   \   00000004   0xE5801000         STR      R1,[R0, #+0]
     46          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
     47          
     48          //------------------------------------------------------------------------------
     49          /// Disables a SPI peripheral.
     50          /// \param spi  Pointer to an AT91S_SPI instance.
     51          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     52          void SPI_Disable(AT91S_SPI *spi)
     53          {
     54              spi->SPI_CR = AT91C_SPI_SPIDIS;
   \                     SPI_Disable:
   \   00000000   0xE3A01002         MOV      R1,#+2
   \   00000004   0xE5801000         STR      R1,[R0, #+0]
     55          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
     56          
     57          //------------------------------------------------------------------------------
     58          /// Configures a SPI peripheral as specified. The configuration can be computed
     59          /// using several macros (see "SPI configuration macros") and the constants
     60          /// defined in LibV3 (AT91C_SPI_*).
     61          /// \param spi  Pointer to an AT91S_SPI instance.
     62          /// \param id  Peripheral ID of the SPI.
     63          /// \param configuration  Value of the SPI configuration register.
     64          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     65          void SPI_Configure(AT91S_SPI *spi,
     66                                    unsigned int id,
     67                                    unsigned int configuration)
     68          {
     69              AT91C_BASE_PMC->PMC_PCER = 1 << id;
   \                     SPI_Configure:
   \   00000000   0xE3A03001         MOV      R3,#+1
   \   00000004   0xE1A01113         LSL      R1,R3,R1
   \   00000008   0xE3E030EF         MVN      R3,#+239
   \   0000000C   0xE3C33FC0         BIC      R3,R3,#0x300
   \   00000010   0xE5831000         STR      R1,[R3, #+0]
     70              spi->SPI_CR = AT91C_SPI_SPIDIS;
   \   00000014   0xE3A01002         MOV      R1,#+2
   \   00000018   0xE5801000         STR      R1,[R0, #+0]
     71              // Execute a software reset of the SPI twice
     72              spi->SPI_CR = AT91C_SPI_SWRST;
   \   0000001C   0xE3A01080         MOV      R1,#+128
   \   00000020   0xE5801000         STR      R1,[R0, #+0]
     73              spi->SPI_CR = AT91C_SPI_SWRST;
   \   00000024   0xE5801000         STR      R1,[R0, #+0]
     74              spi->SPI_MR = configuration;
   \   00000028   0xE5802004         STR      R2,[R0, #+4]
     75          }
   \   0000002C   0xE12FFF1E         BX       LR               ;; return
     76          
     77          //------------------------------------------------------------------------------
     78          /// Configures a chip select of a SPI peripheral. The chip select configuration
     79          /// is computed using the definition provided by the LibV3 (AT91C_SPI_*).
     80          /// \param spi  Pointer to an AT91S_SPI instance.
     81          /// \param npcs  Chip select to configure (1, 2, 3 or 4).
     82          /// \param configuration  Desired chip select configuration.
     83          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     84          void SPI_ConfigureNPCS(AT91S_SPI *spi,
     85                                        unsigned int npcs,
     86                                        unsigned int configuration)
     87          {
     88              spi->SPI_CSR[npcs] = configuration;
   \                     SPI_ConfigureNPCS:
   \   00000000   0xE0800101         ADD      R0,R0,R1, LSL #+2
   \   00000004   0xE5802030         STR      R2,[R0, #+48]
     89          }
   \   00000008   0xE12FFF1E         BX       LR               ;; return
     90          
     91          //------------------------------------------------------------------------------
     92          /// Sends data through a SPI peripheral. If the SPI is configured to use a fixed
     93          /// peripheral select, the npcs value is meaningless. Otherwise, it identifies
     94          /// the component which shall be addressed.
     95          /// \param spi  Pointer to an AT91S_SPI instance.
     96          /// \param npcs  Chip select of the component to address (1, 2, 3 or 4).
     97          /// \param data  Word of data to send.
     98          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     99          void SPI_Write(AT91S_SPI *spi, unsigned int npcs, unsigned short data)
    100          {
    101              // Discard contents of RDR register
    102              //volatile unsigned int discard = spi->SPI_RDR;
    103          
    104              // Send data
    105              while ((spi->SPI_SR & AT91C_SPI_TXEMPTY) == 0);
   \                     SPI_Write:
   \                     ??SPI_Write_0:
   \   00000000   0xE5903010         LDR      R3,[R0, #+16]
   \   00000004   0xE3130F80         TST      R3,#0x200
   \   00000008   0x0AFFFFFC         BEQ      ??SPI_Write_0
    106              spi->SPI_TDR = data | SPI_PCS(npcs);
   \   0000000C   0xE3A03001         MOV      R3,#+1
   \   00000010   0xE1E01113         MVN      R1,R3, LSL R1
   \   00000014   0xE201100F         AND      R1,R1,#0xF
   \   00000018   0xE1821801         ORR      R1,R2,R1, LSL #+16
   \   0000001C   0xE580100C         STR      R1,[R0, #+12]
    107              while ((spi->SPI_SR & AT91C_SPI_TDRE) == 0);
   \                     ??SPI_Write_1:
   \   00000020   0xE5901010         LDR      R1,[R0, #+16]
   \   00000024   0xE3110002         TST      R1,#0x2
   \   00000028   0x0AFFFFFC         BEQ      ??SPI_Write_1
    108          }
   \   0000002C   0xE12FFF1E         BX       LR               ;; return
    109          
    110          //------------------------------------------------------------------------------
    111          /// Sends the contents of buffer through a SPI peripheral, using the PDC to
    112          /// take care of the transfer.
    113          /// \param spi  Pointer to an AT91S_SPI instance.
    114          /// \param buffer  Data buffer to send.
    115          /// \param length  Length of the data buffer.
    116          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    117          unsigned char SPI_WriteBuffer(AT91S_SPI *spi,
    118                                               void *buffer,
    119                                               unsigned int length)
    120          {
    121          #if !defined(CHIP_SPI_DMA)
    122              // Check if first bank is free
    123              if (spi->SPI_TCR == 0) {
   \                     SPI_WriteBuffer:
   \   00000000   0xE590310C         LDR      R3,[R0, #+268]
   \   00000004   0xE3530000         CMP      R3,#+0
   \   00000008   0x1A000003         BNE      ??SPI_WriteBuffer_0
    124          
    125                  spi->SPI_TPR = (unsigned int) buffer;
   \   0000000C   0xE5801108         STR      R1,[R0, #+264]
    126                  spi->SPI_TCR = length;
   \   00000010   0xE580210C         STR      R2,[R0, #+268]
    127                  spi->SPI_PTCR = AT91C_PDC_TXTEN;
   \   00000014   0xE3A01F40         MOV      R1,#+256
   \   00000018   0x........         B        ?Subroutine0
    128                  return 1;
    129              }
    130              // Check if second bank is free
    131              else if (spi->SPI_TNCR == 0) {
   \                     ??SPI_WriteBuffer_0:
   \   0000001C   0xE590311C         LDR      R3,[R0, #+284]
   \   00000020   0xE3530000         CMP      R3,#+0
   \   00000024   0x1A000002         BNE      ??SPI_WriteBuffer_1
    132          
    133                  spi->SPI_TNPR = (unsigned int) buffer;
   \   00000028   0xE5801118         STR      R1,[R0, #+280]
    134                  spi->SPI_TNCR = length;
   \   0000002C   0xE580211C         STR      R2,[R0, #+284]
    135                  return 1;
   \   00000030   0x........         B        ??Subroutine0_0
    136              }
    137          #endif      
    138              // No free banks
    139              return 0;
   \                     ??SPI_WriteBuffer_1:
   \   00000034   0xE3A00000         MOV      R0,#+0
   \   00000038   0xE12FFF1E         BX       LR               ;; return
    140          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE5801120         STR      R1,[R0, #+288]
   \                     ??Subroutine0_0:
   \   00000004   0xE3A00001         MOV      R0,#+1
   \   00000008   0xE12FFF1E         BX       LR
    141          
    142          //------------------------------------------------------------------------------
    143          /// Returns 1 if there is no pending write operation on the SPI; otherwise
    144          /// returns 0.
    145          /// \param pSpi  Pointer to an AT91S_SPI instance.
    146          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    147          unsigned char SPI_IsFinished(AT91S_SPI *pSpi)
    148          {
    149              return ((pSpi->SPI_SR & AT91C_SPI_TXEMPTY) != 0);
   \                     SPI_IsFinished:
   \   00000000   0xE5900010         LDR      R0,[R0, #+16]
   \   00000004   0xE1A00800         LSL      R0,R0,#+16
   \   00000008   0xE1A00CA0         LSR      R0,R0,#+25
   \   0000000C   0xE2000001         AND      R0,R0,#0x1
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    150          }
    151          
    152          //------------------------------------------------------------------------------
    153          /// Reads and returns the last word of data received by a SPI peripheral. This
    154          /// method must be called after a successful SPI_Write call.
    155          /// \param spi  Pointer to an AT91S_SPI instance.
    156          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    157          unsigned short SPI_Read(AT91S_SPI *spi)
    158          {
    159              while ((spi->SPI_SR & AT91C_SPI_RDRF) == 0);
   \                     SPI_Read:
   \                     ??SPI_Read_0:
   \   00000000   0xE5901010         LDR      R1,[R0, #+16]
   \   00000004   0xE3110001         TST      R1,#0x1
   \   00000008   0x0AFFFFFC         BEQ      ??SPI_Read_0
    160              return spi->SPI_RDR & 0xFFFF;
   \   0000000C   0xE5900008         LDR      R0,[R0, #+8]
   \   00000010   0xE1A00800         LSL      R0,R0,#+16
   \   00000014   0xE1A00820         LSR      R0,R0,#+16
   \   00000018   0xE12FFF1E         BX       LR               ;; return
    161          }
    162          
    163          //------------------------------------------------------------------------------
    164          /// Reads data from a SPI peripheral until the provided buffer is filled. This
    165          /// method does NOT need to be called after SPI_Write or SPI_WriteBuffer.
    166          /// \param spi  Pointer to an AT91S_SPI instance.
    167          /// \param buffer  Data buffer to store incoming bytes.
    168          /// \param length  Length in bytes of the data buffer.
    169          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    170          unsigned char SPI_ReadBuffer(AT91S_SPI *spi,
    171                                              void *buffer,
    172                                              unsigned int length)
    173          {
    174          #if !defined(CHIP_SPI_DMA)
    175              // Check if the first bank is free
    176              if (spi->SPI_RCR == 0) {
   \                     SPI_ReadBuffer:
   \   00000000   0xE5903104         LDR      R3,[R0, #+260]
   \   00000004   0xE3530000         CMP      R3,#+0
   \   00000008   0x1A000003         BNE      ??SPI_ReadBuffer_0
    177          
    178                  spi->SPI_RPR = (unsigned int) buffer;
   \   0000000C   0xE5801100         STR      R1,[R0, #+256]
    179                  spi->SPI_RCR = length;
   \   00000010   0xE5802104         STR      R2,[R0, #+260]
    180                  spi->SPI_PTCR = AT91C_PDC_RXTEN;
   \   00000014   0xE3A01001         MOV      R1,#+1
   \   00000018   0x........         B        ?Subroutine0
    181                  return 1;
    182              }
    183              // Check if second bank is free
    184              else if (spi->SPI_RNCR == 0) {
   \                     ??SPI_ReadBuffer_0:
   \   0000001C   0xE5903114         LDR      R3,[R0, #+276]
   \   00000020   0xE3530000         CMP      R3,#+0
    185          
    186                  spi->SPI_RNPR = (unsigned int) buffer;
   \   00000024   0x05801110         STREQ    R1,[R0, #+272]
    187                  spi->SPI_RNCR = length;
   \   00000028   0x05802114         STREQ    R2,[R0, #+276]
    188                  return 1;
   \   0000002C   0x03A00001         MOVEQ    R0,#+1
    189              }
    190          #endif
    191              // No free bank
    192              return 0;
   \   00000030   0x13A00000         MOVNE    R0,#+0
   \   00000034   0xE12FFF1E         BX       LR               ;; return
    193          }
    194          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
        0  SPI_Configure
        0  SPI_ConfigureNPCS
        0  SPI_Disable
        0  SPI_Enable
        0  SPI_IsFinished
        0  SPI_Read
        0  SPI_ReadBuffer
        0  SPI_Write
        0  SPI_WriteBuffer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      12  ?Subroutine0
      48  SPI_Configure
      12  SPI_ConfigureNPCS
      12  SPI_Disable
      12  SPI_Enable
      20  SPI_IsFinished
      28  SPI_Read
      56  SPI_ReadBuffer
      48  SPI_Write
      60  SPI_WriteBuffer

 
 308 bytes in section .text
 
 308 bytes of CODE memory

Errors: none
Warnings: none
