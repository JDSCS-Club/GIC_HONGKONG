###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.30.6.53336/W32 for ARM     29/Apr/2013  12:37:17 #
# Copyright 1999-2012 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  arm                                                      #
#    Endian       =  little                                                   #
#    Source file  =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\SPI_FUN.c                                            #
#    Command line =  "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\SPI_FUN.c" -D at91sam7se512 -D sram -D               #
#                    TRACE_LEVEL=4 -lC "C:\Users\JDS\Desktop\JDS_PRO\국내     #
#                    프로젝트\대구 모노레일\프로그램\basic-usart-hw-handshaki #
#                    ng-project-at91sam7se-ek\at91sam7se-ek\basic-usart-hw-ha #
#                    ndshaking-project\ewp\at91sam7se512_sram\List\"          #
#                    --remarks --diag_suppress Pe826,Pe1375 -o                #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\Obj\" --no_cse --no_unroll    #
#                    --no_inline --no_code_motion --no_tbaa --no_clustering   #
#                    --no_scheduling --debug --endian=little --cpu=ARM7TDMI   #
#                    -e --fpu=None --dlib_config "C:\Program Files\IAR        #
#                    Systems\Embedded Workbench 6.0\arm\INC\c\DLib_Config_Ful #
#                    l.h" -I "C:\Users\JDS\Desktop\JDS_PRO\국내               #
#                    프로젝트\대구 모노레일\프로그램\basic-usart-hw-handshaki #
#                    ng-project-at91sam7se-ek\at91sam7se-ek\basic-usart-hw-ha #
#                    ndshaking-project\ewp\..\..\..\at91lib/peripherals\" -I  #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib\" -I                            #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib/components\" -I                 #
#                    "C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구         #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"          #
#                    --interwork --cpu_mode arm -Oh --use_c++_inline          #
#    List file    =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\List\SPI_FUN.lst              #
#    Object file  =  C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구          #
#                    모노레일\프로그램\basic-usart-hw-handshaking-project-at9 #
#                    1sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-proj #
#                    ect\ewp\at91sam7se512_sram\Obj\SPI_FUN.o                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\basic-usart-hw-handshaking-project-at91sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-project\SPI_FUN.c
      1          
      2          //------------------------------------------------------------------------------
      3          //         Headers
      4          //------------------------------------------------------------------------------
      5          
      6          #include <board.h>
      7          #include <dbgu/dbgu.h>
      8          #include <pio/pio.h>
      9          #include <aic/aic.h>
     10          #include <utility/assert.h>
     11          #include <utility/trace.h>
     12          #include <utility/math.h>
     13          #include <memories/spi-flash/at26.h>
     14          
     15          #include <string.h>
     16          
     17          #include "SPI_FUN.h"

  #endif
        ^
"C:\Users\JDS\Desktop\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\basic-usart-hw-handshaking-project-at91sam7se-ek\at91sam7se-ek\basic-usart-hw-handshaking-project\SPI_FUN.h",18  Remark[Pe001]: 
          last line of file ends without a newline
     18          
     19          
     20          /// Maximum device page size in bytes.
     21          #define MAXPAGESIZE     256
     22          
     23          #if defined(BOARD_AT45_A_SPI_BASE)
     24          
     25          /// Address of the SPI peripheral connected to the AT26.
     26          #define SPI_BASE        BOARD_AT45_A_SPI_BASE
     27          /// Peripheral identifier of the SPI connected to the AT26.
     28          #define SPI_ID          BOARD_AT45_A_SPI_ID
     29          /// Chip select value used to select the AT26 chip.
     30          #define SPI_CS          BOARD_AT45_A_NPCS
     31          /// SPI peripheral pins to configure to access the serial flash.
     32          #define SPI_PINS        BOARD_AT45_A_SPI_PINS, BOARD_AT45_A_NPCS_PIN
     33          
     34          #elif defined(AT91C_BASE_SPI0)
     35          
     36          /// Address of the SPI peripheral connected to the AT26.
     37          #define SPI_BASE        AT91C_BASE_SPI0
     38          /// Peripheral identifier of the SPI connected to the AT26.
     39          #define SPI_ID          AT91C_ID_SPI0
     40          /// Chip select value used to select the AT26 chip.
     41          #define SPI_CS          0
     42          /// SPI peripheral pins to configure to access the serial flash.
     43          #define SPI_PINS        PINS_SPI0, PIN_SPI0_NPCS0
     44          
     45          #else
     46          
     47          /// Address of the SPI peripheral connected to the AT26.
     48          #define SPI_BASE        AT91C_BASE_SPI
     49          /// Peripheral identifier of the SPI connected to the AT26.
     50          #define SPI_ID          AT91C_ID_SPI
     51          /// Chip select value used to select the AT26 chip.
     52          #define SPI_CS          0
     53          /// SPI peripheral pins to configure to access the serial flash.
     54          #define SPI_PINS        PINS_SPI, PIN_SPI_NPCS0
     55          
     56          #endif //#if defined(AT91C_BASE_SPI0)
     57          
     58          //------------------------------------------------------------------------------
     59          //         Internal functions
     60          //------------------------------------------------------------------------------
     61          
     62          
     63          //------------------------------------------------------------------------------
     64          //         Internal variables
     65          //------------------------------------------------------------------------------
     66          /// SPI driver instance.

   \                                 In section .bss, align 4
     67          Spid spid;
   \                     spid:
   \   00000000                      DS8 16
     68          
     69          /// Serial flash driver instance.

   \                                 In section .bss, align 4
     70          At26 at26;
   \                     at26:
   \   00000000                      DS8 40
     71          

   \                                 In section .data, align 4
     72          Pin Spi_pins[] = {SPI_PINS};
   \                     Spi_pins:
   \   00000000   0x00001000         DC32 4096, 0FFFFF400H
   \              0xFFFFF400   
   \   00000008   0x02 0x00          DC8 2, 0, 1, 0
   \              0x01 0x00    
   \   0000000C   0x00002000         DC32 8192, 0FFFFF400H
   \              0xFFFFF400   
   \   00000014   0x02 0x00          DC8 2, 0, 1, 0
   \              0x01 0x00    
   \   00000018   0x00004000         DC32 16384, 0FFFFF400H
   \              0xFFFFF400   
   \   00000020   0x02 0x00          DC8 2, 0, 1, 0
   \              0x01 0x00    
   \   00000024   0x00000800         DC32 2048, 0FFFFF400H
   \              0xFFFFF400   
   \   0000002C   0x02 0x00          DC8 2, 0, 1, 0
   \              0x01 0x00    
     73          
     74          //------------------------------------------------------------------------------
     75          /// Interrupt service routine for the SPI peripheral. Forwards the interrupt
     76          /// to the SPI driver.
     77          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     78           void ISR_Spi(void)
     79          {
     80              SPID_Handler(&spid);
   \                     ISR_Spi:
   \   00000000   0x........         LDR      R0,??DataTable10
   \   00000004   0x........         B        SPID_Handler     ;; tailcall
     81          }
     82          
     83          //------------------------------------------------------------------------------
     84          /// Reads and returns the status register of the serial flash.
     85          /// \param pAt26  Pointer to an AT26 driver instance.
     86          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     87          unsigned char AT26_ReadStatus(At26 *pAt26)
     88          {
   \                     AT26_ReadStatus:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE24DD018         SUB      SP,SP,#+24
   \   00000008   0xE1B04000         MOVS     R4,R0
     89              unsigned char error, status;
                                   ^
Warning[Pe550]: variable "error" was set but never used
     90          
     91              SANITY_CHECK(pAt26);
   \   0000000C   0x1A000006         BNE      ??AT26_ReadStatus_0
   \   00000010   0x........         LDR      R0,??DataTable10_1
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A0205B         MOV      R2,#+91
   \   0000001C   0x........         LDR      R1,??DataTable10_2
   \   00000020   0x........         LDR      R0,??DataTable10_3
   \   00000024   0x........         BL       printf
   \                     ??AT26_ReadStatus_1:
   \   00000028   0xEAFFFFFE         B        ??AT26_ReadStatus_1
     92          
     93              // Issue a status read command
     94              error = AT26_SendCommand(pAt26, AT26_READ_STATUS, 1, &status, 1, 0, 0, 0);
   \                     ??AT26_ReadStatus_0:
   \   0000002C   0xE3A00000         MOV      R0,#+0
   \   00000030   0xE58D000C         STR      R0,[SP, #+12]
   \   00000034   0xE58D0008         STR      R0,[SP, #+8]
   \   00000038   0xE58D0004         STR      R0,[SP, #+4]
   \   0000003C   0xE3A00001         MOV      R0,#+1
   \   00000040   0xE58D0000         STR      R0,[SP, #+0]
   \   00000044   0xE28D3010         ADD      R3,SP,#+16
   \   00000048   0xE3A02001         MOV      R2,#+1
   \   0000004C   0xE3A01005         MOV      R1,#+5
   \   00000050   0xE1A00004         MOV      R0,R4
   \   00000054   0x........         BL       AT26_SendCommand
     95              //ASSERT(!error, "-F- AT26_GetStatus: Failed to issue command.\n\r");
     96          
     97              // Wait for transfer to finish
     98              while (AT26_IsBusy(pAt26));
   \                     ??AT26_ReadStatus_2:
   \   00000058   0xE1A00004         MOV      R0,R4
   \   0000005C   0x........         BL       AT26_IsBusy
   \   00000060   0xE3500000         CMP      R0,#+0
   \   00000064   0x1AFFFFFB         BNE      ??AT26_ReadStatus_2
     99          
    100              return status;
   \   00000068   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   0000006C   0x........         B        ?Subroutine0
    101          }

   \                                 In section .text, align 4, keep-with-next
   \                     ?Subroutine0:
   \   00000000   0xE28DD018         ADD      SP,SP,#+24       ;; stack cleaning
   \                     ??Subroutine0_0:
   \   00000004   0xE8BD4010         POP      {R4,LR}
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    102          
    103          //------------------------------------------------------------------------------
    104          /// Writes the given value in the status register of the serial flash device.
    105          /// \param pAt26  Pointer to an AT26 driver instance.
    106          /// \param status  Status to write.
    107          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    108          void AT26_WriteStatus(At26 *pAt26, unsigned char status)
    109          {
   \                     AT26_WriteStatus:
   \   00000000   0xE92D4012         PUSH     {R1,R4,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
    110              unsigned char error;
    111          
    112              SANITY_CHECK(pAt26);
   \   0000000C   0x1A000006         BNE      ??AT26_WriteStatus_0
   \   00000010   0x........         LDR      R0,??DataTable10_1
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A02070         MOV      R2,#+112
   \   0000001C   0x........         LDR      R1,??DataTable10_2
   \   00000020   0x........         LDR      R0,??DataTable10_3
   \   00000024   0x........         BL       printf
   \                     ??AT26_WriteStatus_1:
   \   00000028   0xEAFFFFFE         B        ??AT26_WriteStatus_1
    113          
    114              // Issue a write status command
    115              error = AT26_SendCommand(pAt26, AT26_WRITE_STATUS, 1, &status, 1, 0, 0, 0);
    116              ASSERT(!error, "-F- AT26_WriteStatus: Failed to issue command.\n\r");
   \                     ??AT26_WriteStatus_0:
   \   0000002C   0xE3A00000         MOV      R0,#+0
   \   00000030   0xE58D000C         STR      R0,[SP, #+12]
   \   00000034   0xE58D0008         STR      R0,[SP, #+8]
   \   00000038   0xE58D0004         STR      R0,[SP, #+4]
   \   0000003C   0xE3A00001         MOV      R0,#+1
   \   00000040   0xE58D0000         STR      R0,[SP, #+0]
   \   00000044   0xE28D3014         ADD      R3,SP,#+20
   \   00000048   0xE3A02001         MOV      R2,#+1
   \   0000004C   0xE3A01001         MOV      R1,#+1
   \   00000050   0xE1A00004         MOV      R0,R4
   \   00000054   0x........         BL       AT26_SendCommand
   \   00000058   0xE3500000         CMP      R0,#+0
   \   0000005C   0x0A000004         BEQ      ??AT26_WriteStatus_2
   \   00000060   0x........         LDR      R0,??DataTable10_1
   \   00000064   0x........         BL       printf
   \   00000068   0x........         LDR      R0,??DataTable10_4
   \   0000006C   0x........         BL       printf
   \                     ??AT26_WriteStatus_3:
   \   00000070   0xEAFFFFFE         B        ??AT26_WriteStatus_3
    117              while (AT26_IsBusy(pAt26));
   \                     ??AT26_WriteStatus_2:
   \   00000074   0xE1A00004         MOV      R0,R4
   \   00000078   0x........         BL       AT26_IsBusy
   \   0000007C   0xE3500000         CMP      R0,#+0
   \   00000080   0x1AFFFFFB         BNE      ??AT26_WriteStatus_2
    118          }
   \   00000084                      REQUIRE ?Subroutine0
   \   00000084                      ;; // Fall through to label ?Subroutine0
    119          
    120          //------------------------------------------------------------------------------
    121          /// Waits for the serial flash device to become ready to accept new commands.
    122          /// \param pAt26  Pointer to an AT26 driver instance.
    123          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    124          void AT26_WaitReady(At26 *pAt26)
    125          {
   \                     AT26_WaitReady:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    126              unsigned char ready = 0;
    127          
    128              SANITY_CHECK(pAt26);
   \   00000008   0x1A000006         BNE      ??AT26_WaitReady_0
   \   0000000C   0x........         LDR      R0,??DataTable10_1
   \   00000010   0x........         BL       printf
   \   00000014   0xE3A02080         MOV      R2,#+128
   \   00000018   0x........         LDR      R1,??DataTable10_2
   \   0000001C   0x........         LDR      R0,??DataTable10_3
   \   00000020   0x........         BL       printf
   \                     ??AT26_WaitReady_1:
   \   00000024   0xEAFFFFFE         B        ??AT26_WaitReady_1
    129          
    130              // Read status register and check busy bit
    131              while (!ready) {
    132          
    133                  ready = ((AT26_ReadStatus(pAt26) & AT26_STATUS_RDYBSY) == AT26_STATUS_RDYBSY_READY);
   \                     ??AT26_WaitReady_0:
   \   00000028   0xE1A00004         MOV      R0,R4
   \   0000002C   0x........         BL       AT26_ReadStatus
   \   00000030   0xE3100001         TST      R0,#0x1
   \   00000034   0x1AFFFFFB         BNE      ??AT26_WaitReady_0
    134              }
    135          }
   \   00000038   0x........         B        ??Subroutine0_0
    136          
    137          //------------------------------------------------------------------------------
    138          /// Reads and returns the serial flash device ID.
    139          /// \param pAt26  Pointer to an AT26 driver instance.
    140          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    141          unsigned int AT26_ReadJedecId(At26 *pAt26)
    142          {
   \                     AT26_ReadJedecId:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE24DD018         SUB      SP,SP,#+24
   \   00000008   0xE1B04000         MOVS     R4,R0
    143              unsigned char error;
    144              unsigned int id = 0;
   \   0000000C   0xE3A01000         MOV      R1,#+0
   \   00000010   0xE58D1010         STR      R1,[SP, #+16]
    145          
    146              SANITY_CHECK(pAt26);
   \   00000014   0x1A000006         BNE      ??AT26_ReadJedecId_0
   \   00000018   0x........         LDR      R0,??DataTable10_1
   \   0000001C   0x........         BL       printf
   \   00000020   0xE3A02092         MOV      R2,#+146
   \   00000024   0x........         LDR      R1,??DataTable10_2
   \   00000028   0x........         LDR      R0,??DataTable10_3
   \   0000002C   0x........         BL       printf
   \                     ??AT26_ReadJedecId_1:
   \   00000030   0xEAFFFFFE         B        ??AT26_ReadJedecId_1
    147           
    148              // Issue a read ID command
    149              error = AT26_SendCommand(pAt26, AT26_READ_JEDEC_ID, 1,
    150                                       (unsigned char *) &id, 3, 0, 0, 0);
    151              ASSERT(!error, "-F- AT26_GetJedecId: Could not issue command.\n\r");
   \                     ??AT26_ReadJedecId_0:
   \   00000034   0xE58D100C         STR      R1,[SP, #+12]
   \   00000038   0xE58D1008         STR      R1,[SP, #+8]
   \   0000003C   0xE58D1004         STR      R1,[SP, #+4]
   \   00000040   0xE3A00003         MOV      R0,#+3
   \   00000044   0xE58D0000         STR      R0,[SP, #+0]
   \   00000048   0xE28D3010         ADD      R3,SP,#+16
   \   0000004C   0xE3A02001         MOV      R2,#+1
   \   00000050   0xE3A0109F         MOV      R1,#+159
   \   00000054   0xE1A00004         MOV      R0,R4
   \   00000058   0x........         BL       AT26_SendCommand
   \   0000005C   0xE3500000         CMP      R0,#+0
   \   00000060   0x0A000004         BEQ      ??AT26_ReadJedecId_2
   \   00000064   0x........         LDR      R0,??DataTable10_1
   \   00000068   0x........         BL       printf
   \   0000006C   0x........         LDR      R0,??DataTable10_5
   \   00000070   0x........         BL       printf
   \                     ??AT26_ReadJedecId_3:
   \   00000074   0xEAFFFFFE         B        ??AT26_ReadJedecId_3
    152          
    153               // Wait for transfer to finish
    154              while (AT26_IsBusy(pAt26));
   \                     ??AT26_ReadJedecId_2:
   \   00000078   0xE1A00004         MOV      R0,R4
   \   0000007C   0x........         BL       AT26_IsBusy
   \   00000080   0xE3500000         CMP      R0,#+0
   \   00000084   0x1AFFFFFB         BNE      ??AT26_ReadJedecId_2
    155          
    156              return id;
   \   00000088   0xE59D0010         LDR      R0,[SP, #+16]
   \   0000008C   0x........         B        ?Subroutine0
    157          }
    158          
    159          //------------------------------------------------------------------------------
    160          /// Enables critical writes operation on a serial flash device, such as sector
    161          /// protection, status register, etc.
    162          /// \para pAt26  Pointer to an AT26 driver instance.
    163          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    164          void AT26_EnableWrite(At26 *pAt26)
    165          {
   \                     AT26_EnableWrite:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE24DD010         SUB      SP,SP,#+16
   \   00000008   0xE1B04000         MOVS     R4,R0
    166              unsigned char error;
                                   ^
Warning[Pe550]: variable "error" was set but never used
    167          
    168              SANITY_CHECK(pAt26);
   \   0000000C   0x1A000006         BNE      ??AT26_EnableWrite_0
   \   00000010   0x........         LDR      R0,??DataTable10_1
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A020A8         MOV      R2,#+168
   \   0000001C   0x........         LDR      R1,??DataTable10_2
   \   00000020   0x........         LDR      R0,??DataTable10_3
   \   00000024   0x........         BL       printf
   \                     ??AT26_EnableWrite_1:
   \   00000028   0xEAFFFFFE         B        ??AT26_EnableWrite_1
    169          
    170              // Issue a write enable command
    171              error = AT26_SendCommand(pAt26, AT26_WRITE_ENABLE, 1, 0, 0, 0, 0, 0);
   \                     ??AT26_EnableWrite_0:
   \   0000002C   0xE3A00000         MOV      R0,#+0
   \   00000030   0xE58D000C         STR      R0,[SP, #+12]
   \   00000034   0xE58D0008         STR      R0,[SP, #+8]
   \   00000038   0xE58D0004         STR      R0,[SP, #+4]
   \   0000003C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000040   0xE3A03000         MOV      R3,#+0
   \   00000044   0xE3A02001         MOV      R2,#+1
   \   00000048   0xE3A01006         MOV      R1,#+6
   \   0000004C   0xE1A00004         MOV      R0,R4
   \   00000050   0x........         BL       AT26_SendCommand
    172              //ASSERT(!error, "-F- AT26_EnableWrite: Could not issue command.\n\r");
    173          
    174              // Wait for end of transfer
    175              while (AT26_IsBusy(pAt26));
   \                     ??AT26_EnableWrite_2:
   \   00000054   0xE1A00004         MOV      R0,R4
   \   00000058   0x........         BL       AT26_IsBusy
   \   0000005C   0xE3500000         CMP      R0,#+0
   \   00000060   0x1AFFFFFB         BNE      ??AT26_EnableWrite_2
    176          }
   \   00000064   0xE28DD010         ADD      SP,SP,#+16       ;; stack cleaning
   \   00000068   0x........         B        ??Subroutine0_0
    177          
    178          //------------------------------------------------------------------------------
    179          /// Unprotects the contents of the serial flash device.
    180          /// Returns 0 if the device has been unprotected; otherwise returns
    181          /// SF_PROTECTED.
    182          /// \param pAt26  Pointer to an AT26 driver instance.
    183          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    184          unsigned char AT26_Unprotect(At26 *pAt26)
    185          {
   \                     AT26_Unprotect:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    186              unsigned char status;
    187          
    188              SANITY_CHECK(pAt26);
   \   00000008   0x1A000006         BNE      ??AT26_Unprotect_0
   \   0000000C   0x........         LDR      R0,??DataTable10_1
   \   00000010   0x........         BL       printf
   \   00000014   0xE3A020BC         MOV      R2,#+188
   \   00000018   0x........         LDR      R1,??DataTable10_2
   \   0000001C   0x........         LDR      R0,??DataTable10_3
   \   00000020   0x........         BL       printf
   \                     ??AT26_Unprotect_1:
   \   00000024   0xEAFFFFFE         B        ??AT26_Unprotect_1
    189          
    190              // Get the status register value to check the current protection
    191              status = AT26_ReadStatus(pAt26);
   \                     ??AT26_Unprotect_0:
   \   00000028   0x........         BL       AT26_ReadStatus
   \   0000002C   0xE1A05000         MOV      R5,R0
    192              if ((status & AT26_STATUS_SWP) == AT26_STATUS_SWP_PROTNONE) {
   \   00000030   0xE315000C         TST      R5,#0xC
   \   00000034   0x0A00000E         BEQ      ??AT26_Unprotect_2
    193          
    194                  // Protection already disabled
    195                  return 0;
    196              }
    197              
    198              // Check if sector protection registers are locked
    199              if ((status & AT26_STATUS_SPRL) == AT26_STATUS_SPRL_LOCKED) {
   \   00000038   0xE3150080         TST      R5,#0x80
   \   0000003C   0x0A000004         BEQ      ??AT26_Unprotect_3
    200          
    201                  // Unprotect sector protection registers by writing the status reg.
    202                  AT26_EnableWrite(pAt26);
   \   00000040   0xE1A00004         MOV      R0,R4
   \   00000044   0x........         BL       AT26_EnableWrite
    203                  AT26_WriteStatus(pAt26, 0);
   \   00000048   0xE3A01000         MOV      R1,#+0
   \   0000004C   0xE1A00004         MOV      R0,R4
   \   00000050   0x........         BL       AT26_WriteStatus
    204              }
    205              
    206              // Perform a global unprotect command
    207                AT26_EnableWrite(pAt26);
   \                     ??AT26_Unprotect_3:
   \   00000054   0xE1A00004         MOV      R0,R4
   \   00000058   0x........         BL       AT26_EnableWrite
    208              AT26_WriteStatus(pAt26, 0);
   \   0000005C   0xE3A01000         MOV      R1,#+0
   \   00000060   0xE1A00004         MOV      R0,R4
   \   00000064   0x........         BL       AT26_WriteStatus
    209              
    210              // Check the new status
    211              if ((status & (AT26_STATUS_SPRL | AT26_STATUS_SWP)) != 0) {
   \   00000068   0xE315008C         TST      R5,#0x8C
    212          
    213                  return AT26_ERROR_PROTECTED;
   \   0000006C   0x13A00001         MOVNE    R0,#+1
   \   00000070   0x1A000000         BNE      ??AT26_Unprotect_4
    214              }
    215              else {
    216          
    217                  return 0;
   \                     ??AT26_Unprotect_2:
   \   00000074   0xE3A00000         MOV      R0,#+0
   \                     ??AT26_Unprotect_4:
   \   00000078   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   0000007C   0xE12FFF1E         BX       LR               ;; return
    218              }
    219          }
    220          
    221          //------------------------------------------------------------------------------
    222          /// Erases all the content of the memory chip.
    223          /// \param pAt26  Pointer to an AT26 driver instance.
    224          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    225          unsigned char AT26_EraseChip(At26 *pAt26)
    226          {
   \                     AT26_EraseChip:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE24DD010         SUB      SP,SP,#+16
   \   00000008   0xE1B04000         MOVS     R4,R0
    227              unsigned char status;
    228              unsigned char error;
    229          
    230              SANITY_CHECK(pAt26);
   \   0000000C   0x1A000006         BNE      ??AT26_EraseChip_0
   \   00000010   0x........         LDR      R0,??DataTable10_1
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A020E6         MOV      R2,#+230
   \   0000001C   0x........         LDR      R1,??DataTable10_2
   \   00000020   0x........         LDR      R0,??DataTable10_3
   \   00000024   0x........         BL       printf
   \                     ??AT26_EraseChip_1:
   \   00000028   0xEAFFFFFE         B        ??AT26_EraseChip_1
    231          
    232              // Check that the flash is ready an unprotected
    233              status = AT26_ReadStatus(pAt26);
    234              if ((status & AT26_STATUS_SWP) != AT26_STATUS_SWP_PROTNONE) {
   \                     ??AT26_EraseChip_0:
   \   0000002C   0x........         BL       AT26_ReadStatus
   \   00000030   0xE310000C         TST      R0,#0xC
   \   00000034   0x0A000003         BEQ      ??AT26_EraseChip_2
    235          
    236                  TRACE_WARNING("AT26_EraseBlock: Device is protected.\n\r");
   \   00000038   0x........         LDR      R0,??DataTable10_6
   \   0000003C   0x........         BL       printf
    237                  return AT26_ERROR_PROTECTED;
   \   00000040   0xE3A00001         MOV      R0,#+1
   \   00000044   0xEA000019         B        ??AT26_EraseChip_3
    238              }
    239              
    240              // Enable critical write operation
    241                AT26_EnableWrite(pAt26);
   \                     ??AT26_EraseChip_2:
   \   00000048   0xE1A00004         MOV      R0,R4
   \   0000004C   0x........         BL       AT26_EnableWrite
    242              
    243              // Erase the chip
    244              error = AT26_SendCommand(pAt26, AT26_CHIP_ERASE_2, 1, 0, 0, 0, 0, 0);
    245              ASSERT(!error, "-F- AT26_ChipErase: Could not issue command.\n\r");
   \   00000050   0xE3A00000         MOV      R0,#+0
   \   00000054   0xE58D000C         STR      R0,[SP, #+12]
   \   00000058   0xE58D0008         STR      R0,[SP, #+8]
   \   0000005C   0xE58D0004         STR      R0,[SP, #+4]
   \   00000060   0xE58D0000         STR      R0,[SP, #+0]
   \   00000064   0xE3A03000         MOV      R3,#+0
   \   00000068   0xE3A02001         MOV      R2,#+1
   \   0000006C   0xE3A010C7         MOV      R1,#+199
   \   00000070   0xE1A00004         MOV      R0,R4
   \   00000074   0x........         BL       AT26_SendCommand
   \   00000078   0xE3500000         CMP      R0,#+0
   \   0000007C   0x0A000004         BEQ      ??AT26_EraseChip_4
   \   00000080   0x........         LDR      R0,??DataTable10_1
   \   00000084   0x........         BL       printf
   \   00000088   0x........         LDR      R0,??DataTable10_7
   \   0000008C   0x........         BL       printf
   \                     ??AT26_EraseChip_5:
   \   00000090   0xEAFFFFFE         B        ??AT26_EraseChip_5
    246               while (AT26_IsBusy(pAt26));    
   \                     ??AT26_EraseChip_4:
   \   00000094   0xE1A00004         MOV      R0,R4
   \   00000098   0x........         BL       AT26_IsBusy
   \   0000009C   0xE3500000         CMP      R0,#+0
   \   000000A0   0x1AFFFFFB         BNE      ??AT26_EraseChip_4
    247              AT26_WaitReady(pAt26);
   \   000000A4   0xE1A00004         MOV      R0,R4
   \   000000A8   0x........         BL       AT26_WaitReady
    248          
    249              return 0;
   \   000000AC   0xE3A00000         MOV      R0,#+0
   \                     ??AT26_EraseChip_3:
   \   000000B0   0xE28DD010         ADD      SP,SP,#+16       ;; stack cleaning
   \   000000B4   0x........         B        ??Subroutine0_0
    250          }
    251          
    252          //------------------------------------------------------------------------------
    253          /// Erases the specified 4KB block of the serial firmware dataflash.
    254          /// Returns 0 if successful; otherwise returns AT26_ERROR_PROTECTED if the
    255          /// device is protected or AT26_ERROR_BUSY if it is busy executing a command.
    256          /// \param pAt26  Pointer to an AT26 driver instance.
    257          /// \param address  Address of the block to erase.
    258          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    259          unsigned char AT26_EraseBlock(At26 *pAt26, unsigned int address)
    260          {
   \                     AT26_EraseBlock:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1A04000         MOV      R4,R0
   \   0000000C   0xE1A05001         MOV      R5,R1
    261              unsigned char status;
    262              unsigned char error;
    263          
    264              SANITY_CHECK(pAt26);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000006         BNE      ??AT26_EraseBlock_0
   \   00000018   0x........         LDR      R0,??DataTable10_1
   \   0000001C   0x........         BL       printf
   \   00000020   0xE3A02F42         MOV      R2,#+264
   \   00000024   0x........         LDR      R1,??DataTable10_2
   \   00000028   0x........         LDR      R0,??DataTable10_3
   \   0000002C   0x........         BL       printf
   \                     ??AT26_EraseBlock_1:
   \   00000030   0xEAFFFFFE         B        ??AT26_EraseBlock_1
    265           
    266              // Check that the flash is ready an unprotected
    267              status = AT26_ReadStatus(pAt26);
   \                     ??AT26_EraseBlock_0:
   \   00000034   0x........         BL       AT26_ReadStatus
    268              if ((status & AT26_STATUS_RDYBSY) != AT26_STATUS_RDYBSY_BUSY) {
   \   00000038   0xE3100001         TST      R0,#0x1
   \   0000003C   0x1A000003         BNE      ??AT26_EraseBlock_2
    269          
    270                  TRACE_WARNING("AT26_EraseBlock: Device is not ready.\n\r");
   \   00000040   0x........         LDR      R0,??DataTable10_8
   \   00000044   0x........         BL       printf
    271                  return AT26_ERROR_BUSY;
   \   00000048   0xE3A00002         MOV      R0,#+2
   \   0000004C   0xEA00001F         B        ??AT26_EraseBlock_3
    272              }
    273              else if ((status & AT26_STATUS_SWP) != AT26_STATUS_SWP_PROTNONE) {
   \                     ??AT26_EraseBlock_2:
   \   00000050   0xE310000C         TST      R0,#0xC
   \   00000054   0x0A000003         BEQ      ??AT26_EraseBlock_4
    274          
    275                  TRACE_WARNING("AT26_EraseBlock: Device is protected.\n\r");
   \   00000058   0x........         LDR      R0,??DataTable10_6
   \   0000005C   0x........         BL       printf
    276                  return AT26_ERROR_PROTECTED;
   \   00000060   0xE3A00001         MOV      R0,#+1
   \   00000064   0xEA000019         B        ??AT26_EraseBlock_3
    277              }
    278          
    279              // Enable critical write operation
    280                AT26_EnableWrite(pAt26);
   \                     ??AT26_EraseBlock_4:
   \   00000068   0xE1A00004         MOV      R0,R4
   \   0000006C   0x........         BL       AT26_EnableWrite
    281          
    282              // Start the block erase command
    283              error = AT26_SendCommand(pAt26, AT26_BLOCK_ERASE_4K, 4, 0, 0, address, 0, 0);
    284              ASSERT(!error, "-F- AT26_EraseBlock: Could not issue command.\n\r");
   \   00000070   0xE3A00000         MOV      R0,#+0
   \   00000074   0xE58D000C         STR      R0,[SP, #+12]
   \   00000078   0xE58D0008         STR      R0,[SP, #+8]
   \   0000007C   0xE58D5004         STR      R5,[SP, #+4]
   \   00000080   0xE58D0000         STR      R0,[SP, #+0]
   \   00000084   0xE3A03000         MOV      R3,#+0
   \   00000088   0xE3A02004         MOV      R2,#+4
   \   0000008C   0xE3A01020         MOV      R1,#+32
   \   00000090   0xE1A00004         MOV      R0,R4
   \   00000094   0x........         BL       AT26_SendCommand
   \   00000098   0xE3500000         CMP      R0,#+0
   \   0000009C   0x0A000004         BEQ      ??AT26_EraseBlock_5
   \   000000A0   0x........         LDR      R0,??DataTable10_1
   \   000000A4   0x........         BL       printf
   \   000000A8   0x........         LDR      R0,??DataTable10_9
   \   000000AC   0x........         BL       printf
   \                     ??AT26_EraseBlock_6:
   \   000000B0   0xEAFFFFFE         B        ??AT26_EraseBlock_6
    285              while (AT26_IsBusy(pAt26));
   \                     ??AT26_EraseBlock_5:
   \   000000B4   0xE1A00004         MOV      R0,R4
   \   000000B8   0x........         BL       AT26_IsBusy
   \   000000BC   0xE3500000         CMP      R0,#+0
   \   000000C0   0x1AFFFFFB         BNE      ??AT26_EraseBlock_5
    286              AT26_WaitReady(pAt26);
   \   000000C4   0xE1A00004         MOV      R0,R4
   \   000000C8   0x........         BL       AT26_WaitReady
    287          
    288              return 0;
   \   000000CC   0xE3A00000         MOV      R0,#+0
   \                     ??AT26_EraseBlock_3:
   \   000000D0   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000D4   0xE8BD4030         POP      {R4,R5,LR}
   \   000000D8   0xE12FFF1E         BX       LR               ;; return
    289          }
    290          
    291          //------------------------------------------------------------------------------
    292          /// Writes data at the specified address on the serial firmware dataflash. The
    293          /// page(s) to program must have been erased prior to writing. This function
    294          /// handles page boundary crossing automatically.
    295          /// Returns 0 if successful; otherwise, returns AT26_ERROR_PROGRAM is there has
    296          /// been an error during the data programming.
    297          /// \param pAt26  Pointer to an AT26 driver instance.
    298          /// \param pData  Data buffer.
    299          /// \param size  Number of bytes in buffer.
    300          /// \param address  Write address.
    301          //------------------------------------------------------------------------------
    302          

   \                                 In section .text, align 4, keep-with-next
    303          unsigned char AT26_Write(
    304              At26 *pAt26,
    305              unsigned char *pData,
    306              unsigned int size,
    307              unsigned int address)
    308          {
   \                     AT26_Write:
   \   00000000   0xE92D43F0         PUSH     {R4-R9,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1A04000         MOV      R4,R0
   \   0000000C   0xE1A05001         MOV      R5,R1
   \   00000010   0xE1A06002         MOV      R6,R2
   \   00000014   0xE1A07003         MOV      R7,R3
    309              unsigned int pageSize;
    310              unsigned int writeSize;
    311              unsigned char error;
                                   ^
Warning[Pe550]: variable "error" was set but never used
    312              unsigned char status;
                                   ^
Warning[Pe177]: variable "status" was declared but never referenced
    313          
    314              SANITY_CHECK(pAt26);
   \   00000018   0xE3540000         CMP      R4,#+0
   \   0000001C   0x1A000007         BNE      ??AT26_Write_0
   \   00000020   0x........         LDR      R0,??DataTable10_1
   \   00000024   0x........         BL       printf
   \   00000028   0xE3A0203A         MOV      R2,#+58
   \   0000002C   0xE3822F40         ORR      R2,R2,#0x100
   \   00000030   0x........         LDR      R1,??DataTable10_2
   \   00000034   0x........         LDR      R0,??DataTable10_3
   \   00000038   0x........         BL       printf
   \                     ??AT26_Write_1:
   \   0000003C   0xEAFFFFFE         B        ??AT26_Write_1
    315              SANITY_CHECK(pData);
   \                     ??AT26_Write_0:
   \   00000040   0xE3550000         CMP      R5,#+0
   \   00000044   0x1A000007         BNE      ??AT26_Write_2
   \   00000048   0x........         LDR      R0,??DataTable10_1
   \   0000004C   0x........         BL       printf
   \   00000050   0xE3A0203B         MOV      R2,#+59
   \   00000054   0xE3822F40         ORR      R2,R2,#0x100
   \   00000058   0x........         LDR      R1,??DataTable10_2
   \   0000005C   0x........         LDR      R0,??DataTable10_3
   \   00000060   0x........         BL       printf
   \                     ??AT26_Write_3:
   \   00000064   0xEAFFFFFE         B        ??AT26_Write_3
    316          
    317              // Retrieve device page size
    318              pageSize = AT26_PageSize(&at26);
   \                     ??AT26_Write_2:
   \   00000068   0x........         LDR      R0,??DataTable10_10
   \   0000006C   0xE590001C         LDR      R0,[R0, #+28]
   \   00000070   0xE590800C         LDR      R8,[R0, #+12]
    319          
    320              // Program one page after the other
    321              while (size > 0) {
   \   00000074   0xE3560000         CMP      R6,#+0
   \   00000078   0x0A000014         BEQ      ??AT26_Write_4
    322          
    323                  // Compute number of bytes to program in page
    324                  writeSize = min(size, pageSize - (address % pageSize));
   \                     ??AT26_Write_5:
   \   0000007C   0xE1A00007         MOV      R0,R7
   \   00000080   0xE1A01008         MOV      R1,R8
   \   00000084   0x........         BL       __aeabi_uidivmod
   \   00000088   0xE0481001         SUB      R1,R8,R1
   \   0000008C   0xE1A00006         MOV      R0,R6
   \   00000090   0x........         BL       min
   \   00000094   0xE1A09000         MOV      R9,R0
    325                          
    326                  // Enable critical write operation
    327                  //AT26_EnableWrite(pAt26);
    328               
    329                  
    330                   // Program page
    331                  //error = AT26_SendCommand(pAt26, AT26_BYTE_PAGE_PROGRAM, 1,pData, writeSize, address, 0, 0);
    332                  
    333                   error = AT26_SendCommand(pAt26, AT26_BYTE_PAGE_PROGRAM, 1,pData, writeSize, address, 0, 0);
   \   00000098   0xE3A00000         MOV      R0,#+0
   \   0000009C   0xE58D000C         STR      R0,[SP, #+12]
   \   000000A0   0xE58D0008         STR      R0,[SP, #+8]
   \   000000A4   0xE58D7004         STR      R7,[SP, #+4]
   \   000000A8   0xE58D9000         STR      R9,[SP, #+0]
   \   000000AC   0xE1A03005         MOV      R3,R5
   \   000000B0   0xE3A02001         MOV      R2,#+1
   \   000000B4   0xE3A01002         MOV      R1,#+2
   \   000000B8   0xE1A00004         MOV      R0,R4
   \   000000BC   0x........         BL       AT26_SendCommand
    334                  
    335                  //ASSERT(!error, "-F- AT26_WritePage: Failed to issue command.\n\r");
    336                    
    337                 //while (AT26_IsBusy(pAt26));
    338                 //AT26_WaitReady(pAt26);
    339                   
    340                  // Make sure that write was without error
    341                  
    342                  /*
    343                  status = AT26_ReadStatus(pAt26);
    344                  
    345                  if ((status & AT26_STATUS_EPE) == AT26_STATUS_EPE_ERROR) {
    346          
    347                      return AT26_ERROR_PROGRAM;
    348                  }
    349                  */
    350                   
    351                  size -= writeSize;
   \   000000C0   0xE0466009         SUB      R6,R6,R9
    352                  address += writeSize;
   \   000000C4   0xE0897007         ADD      R7,R9,R7
   \   000000C8   0xE3560000         CMP      R6,#+0
   \   000000CC   0x1AFFFFEA         BNE      ??AT26_Write_5
    353              }
    354          
    355              return 0;
   \                     ??AT26_Write_4:
   \   000000D0   0xE3A00000         MOV      R0,#+0
   \   000000D4   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000D8   0xE8BD43F0         POP      {R4-R9,LR}
   \   000000DC   0xE12FFF1E         BX       LR               ;; return
    356          }
    357          
    358          //------------------------------------------------------------------------------
    359          /// Reads data from the specified address on the serial flash.
    360          /// \param pAt26  Pointer to an AT26 driver instance.
    361          /// \param pData  Data buffer.
    362          /// \param size  Number of bytes to read.
    363          /// \param address  Read address.
    364          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    365          void AT26_Read(
    366              At26 *pAt26,
    367              unsigned char *pData,
    368              unsigned int size,
    369              unsigned int address)
    370          {
   \                     AT26_Read:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE24DD010         SUB      SP,SP,#+16
   \   00000008   0xE1A04000         MOV      R4,R0
    371              unsigned char error;
    372              
    373               // Start a read operation
    374                error = AT26_SendCommand(pAt26, AT26_READ_ARRAY_LF, 4, pData, size, address, 0, 0);
    375              ASSERT(!error, "-F- AT26_Read: Could not issue command.\n\r");
   \   0000000C   0xE3A00000         MOV      R0,#+0
   \   00000010   0xE58D000C         STR      R0,[SP, #+12]
   \   00000014   0xE58D0008         STR      R0,[SP, #+8]
   \   00000018   0xE58D3004         STR      R3,[SP, #+4]
   \   0000001C   0xE58D2000         STR      R2,[SP, #+0]
   \   00000020   0xE1A03001         MOV      R3,R1
   \   00000024   0xE3A02004         MOV      R2,#+4
   \   00000028   0xE3A01003         MOV      R1,#+3
   \   0000002C   0xE1A00004         MOV      R0,R4
   \   00000030   0x........         BL       AT26_SendCommand
   \   00000034   0xE3500000         CMP      R0,#+0
   \   00000038   0x0A000004         BEQ      ??AT26_Read_0
   \   0000003C   0x........         LDR      R0,??DataTable10_1
   \   00000040   0x........         BL       printf
   \   00000044   0x........         LDR      R0,??DataTable10_11
   \   00000048   0x........         BL       printf
   \                     ??AT26_Read_1:
   \   0000004C   0xEAFFFFFE         B        ??AT26_Read_1
    376              while (AT26_IsBusy(pAt26));
   \                     ??AT26_Read_0:
   \   00000050   0xE1A00004         MOV      R0,R4
   \   00000054   0x........         BL       AT26_IsBusy
   \   00000058   0xE3500000         CMP      R0,#+0
   \   0000005C   0x1AFFFFFB         BNE      ??AT26_Read_0
    377          }
   \   00000060   0xE28DD010         ADD      SP,SP,#+16       ;; stack cleaning
   \   00000064   0x........         B        ??Subroutine0_0
    378          
    379          
    380          //------------------------------------------------------------------------------
    381          //
    382          //
    383          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    384          void SPI_Init(void)
    385          {
   \                     SPI_Init:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    386                 // Initialize the SPI and serial flash
    387            
    388              PIO_Configure(Spi_pins, PIO_LISTSIZE(Spi_pins));
   \   00000004   0xE3A01004         MOV      R1,#+4
   \   00000008   0x........         LDR      R0,??DataTable10_12
   \   0000000C   0x........         BL       PIO_Configure
    389              
    390              AIC_DisableIT(SPI_ID);
   \   00000010   0xE3A00005         MOV      R0,#+5
   \   00000014   0x........         BL       AIC_DisableIT
    391              
    392              AIC_ConfigureIT(SPI_ID, AT91C_AIC_PRIOR_LOWEST, ISR_Spi); 
   \   00000018   0x........         ADRL     R2,ISR_Spi
   \              0x........   
   \   00000020   0xE3A01000         MOV      R1,#+0
   \   00000024   0xE3A00005         MOV      R0,#+5
   \   00000028   0x........         BL       AIC_ConfigureIT
    393              
    394              SPID_Configure(&spid, SPI_BASE, SPI_ID);
   \   0000002C   0xE3A02005         MOV      R2,#+5
   \   00000030   0xE3A014FF         MOV      R1,#-16777216
   \   00000034   0xE38118FE         ORR      R1,R1,#0xFE0000
   \   00000038   0x........         LDR      R0,??DataTable10
   \   0000003C   0x........         BL       SPID_Configure
    395              
    396              AT26_Configure(&at26, &spid, SPI_CS);
   \   00000040   0xE3A02000         MOV      R2,#+0
   \   00000044   0x........         LDR      R1,??DataTable10
   \   00000048   0x........         LDR      R0,??DataTable10_10
   \   0000004C   0x........         BL       AT26_Configure
    397              
    398              AIC_EnableIT(SPI_ID);            
   \   00000050   0xE3A00005         MOV      R0,#+5
   \   00000054   0x........         BL       AIC_EnableIT
    399             
    400              printf("SPI and AT26 drivers initialized\n\r");
   \   00000058   0x........         LDR      R0,??DataTable10_13
   \   0000005C   0xE8BD4002         POP      {R1,LR}
   \   00000060   0x........         B        printf           ;; tailcall
    401          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10:
   \   00000000   0x........         DC32     spid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_1:
   \   00000000   0x........         DC32     `?<Constant "-F- ASSERT: ">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_2:
   \   00000000   0x........         DC32     `?<Constant "C:\\\\Users\\\\JDS\\\\Desktop\\\\...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_3:
   \   00000000   0x........         DC32     `?<Constant "Sanity check failed a...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_4:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_WriteStatus:...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_5:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_GetJedecId: ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_6:
   \   00000000   0x........         DC32     `?<Constant "-W- AT26_EraseBlock: ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_7:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_ChipErase: C...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_8:
   \   00000000   0x........         DC32     `?<Constant "-W- AT26_EraseBlock: ...">_1`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_9:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_EraseBlock: ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_10:
   \   00000000   0x........         DC32     at26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_11:
   \   00000000   0x........         DC32     `?<Constant "-F- AT26_Read: Could ...">`

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_12:
   \   00000000   0x........         DC32     Spi_pins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable10_13:
   \   00000000   0x........         DC32     `?<Constant "SPI and AT26 drivers ...">`

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- ASSERT: ">`:
   \   00000000   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "Sanity check failed a...">`:
   \   00000000   0x53 0x61          DC8 "Sanity check failed at %s:%d\012\015"
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x20 0x63    
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x73 0x3A    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "C:\\\\Users\\\\JDS\\\\Desktop\\\\...">`:
   \   00000000   0x43 0x3A          DC8 43H, 3AH, 5CH, 55H, 73H, 65H, 72H, 73H
   \              0x5C 0x55    
   \              0x73 0x65    
   \              0x72 0x73    
   \   00000008   0x5C 0x4A          DC8 5CH, 4AH, 44H, 53H, 5CH, 44H, 65H, 73H
   \              0x44 0x53    
   \              0x5C 0x44    
   \              0x65 0x73    
   \   00000010   0x6B 0x74          DC8 6BH, 74H, 6FH, 70H, 5CH, 4AH, 44H, 53H
   \              0x6F 0x70    
   \              0x5C 0x4A    
   \              0x44 0x53    
   \   00000018   0x5F 0x50          DC8 5FH, 50H, 52H, 4FH, 5CH, 0B1H, 0B9H, 0B3H
   \              0x52 0x4F    
   \              0x5C 0xB1    
   \              0xB9 0xB3    
   \   00000020   0xBB 0x20          DC8 0BBH, 20H, 0C7H, 0C1H, 0B7H, 0CEH, 0C1H, 0A7H
   \              0xC7 0xC1    
   \              0xB7 0xCE    
   \              0xC1 0xA7    
   \   00000028   0xC6 0xAE          DC8 0C6H, 0AEH, 5CH, 0B4H, 0EBH, 0B1H, 0B8H, 20H
   \              0x5C 0xB4    
   \              0xEB 0xB1    
   \              0xB8 0x20    
   \   00000030   0xB8 0xF0          DC8 0B8H, 0F0H, 0B3H, 0EBH, 0B7H, 0B9H, 0C0H, 0CFH
   \              0xB3 0xEB    
   \              0xB7 0xB9    
   \              0xC0 0xCF    
   \   00000038   0x5C 0xC7          DC8 5CH, 0C7H, 0C1H, 0B7H, 0CEH, 0B1H, 0D7H, 0B7H
   \              0xC1 0xB7    
   \              0xCE 0xB1    
   \              0xD7 0xB7    
   \   00000040   0xA5 0x5C          DC8 0A5H, 5CH, 62H, 61H, 73H, 69H, 63H, 2DH
   \              0x62 0x61    
   \              0x73 0x69    
   \              0x63 0x2D    
   \   00000048   0x75 0x73          DC8 75H, 73H, 61H, 72H, 74H, 2DH, 68H, 77H
   \              0x61 0x72    
   \              0x74 0x2D    
   \              0x68 0x77    
   \   00000050   0x2D 0x68          DC8 2DH, 68H, 61H, 6EH, 64H, 73H, 68H, 61H
   \              0x61 0x6E    
   \              0x64 0x73    
   \              0x68 0x61    
   \   00000058   0x6B 0x69          DC8 6BH, 69H, 6EH, 67H, 2DH, 70H, 72H, 6FH
   \              0x6E 0x67    
   \              0x2D 0x70    
   \              0x72 0x6F    
   \   00000060   0x6A 0x65          DC8 6AH, 65H, 63H, 74H, 2DH, 61H, 74H, 39H
   \              0x63 0x74    
   \              0x2D 0x61    
   \              0x74 0x39    
   \   00000068   0x31 0x73          DC8 31H, 73H, 61H, 6DH, 37H, 73H, 65H, 2DH
   \              0x61 0x6D    
   \              0x37 0x73    
   \              0x65 0x2D    
   \   00000070   0x65 0x6B          DC8 65H, 6BH, 5CH, 61H, 74H, 39H, 31H, 73H
   \              0x5C 0x61    
   \              0x74 0x39    
   \              0x31 0x73    
   \   00000078   0x61 0x6D          DC8 61H, 6DH, 37H, 73H, 65H, 2DH, 65H, 6BH
   \              0x37 0x73    
   \              0x65 0x2D    
   \              0x65 0x6B    
   \   00000080   0x5C 0x62          DC8 5CH, 62H, 61H, 73H, 69H, 63H, 2DH, 75H
   \              0x61 0x73    
   \              0x69 0x63    
   \              0x2D 0x75    
   \   00000088   0x73 0x61          DC8 73H, 61H, 72H, 74H, 2DH, 68H, 77H, 2DH
   \              0x72 0x74    
   \              0x2D 0x68    
   \              0x77 0x2D    
   \   00000090   0x68 0x61          DC8 68H, 61H, 6EH, 64H, 73H, 68H, 61H, 6BH
   \              0x6E 0x64    
   \              0x73 0x68    
   \              0x61 0x6B    
   \   00000098   0x69 0x6E          DC8 69H, 6EH, 67H, 2DH, 70H, 72H, 6FH, 6AH
   \              0x67 0x2D    
   \              0x70 0x72    
   \              0x6F 0x6A    
   \   000000A0   0x65 0x63          DC8 65H, 63H, 74H, 5CH, 53H, 50H, 49H, 5FH
   \              0x74 0x5C    
   \              0x53 0x50    
   \              0x49 0x5F    
   \   000000A8   0x46 0x55          DC8 46H, 55H, 4EH, 2EH, 63H, 0
   \              0x4E 0x2E    
   \              0x63 0x00    
   \   000000AE   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_WriteStatus:...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_WriteStatus: Failed to issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_GetJedecId: ...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_GetJedecId: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x47    
   \              0x65 0x74    
   \              0x4A 0x65    
   \              0x64 0x65    
   \              0x63 0x49    
   \              0x64 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-W- AT26_EraseBlock: ...">`:
   \   00000000   0x2D 0x57          DC8 "-W- AT26_EraseBlock: Device is protected.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x44    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x69 0x73    
   \              0x20 0x70    
   \              0x72 0x6F    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_ChipErase: C...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_ChipErase: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x43    
   \              0x68 0x69    
   \              0x70 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x3A 0x20    
   \              0x43 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "-W- AT26_EraseBlock: ...">_1`:
   \   00000000   0x2D 0x57          DC8 "-W- AT26_EraseBlock: Device is not ready.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x44    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x69 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_EraseBlock: ...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_EraseBlock: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     `?<Constant "-F- AT26_Read: Could ...">`:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_Read: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x52    
   \              0x65 0x61    
   \              0x64 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     `?<Constant "SPI and AT26 drivers ...">`:
   \   00000000   0x53 0x50          DC8 "SPI and AT26 drivers initialized\012\015"
   \              0x49 0x20    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x20 0x64    
   \              0x72 0x69    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x20 0x69    
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000023   0x00               DC8 0
    402          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       24  AT26_EnableWrite
             24 -> AT26_IsBusy
             24 -> AT26_SendCommand
             24 -> printf
       32  AT26_EraseBlock
             32 -> AT26_EnableWrite
             32 -> AT26_IsBusy
             32 -> AT26_ReadStatus
             32 -> AT26_SendCommand
             32 -> AT26_WaitReady
             32 -> printf
       24  AT26_EraseChip
             24 -> AT26_EnableWrite
             24 -> AT26_IsBusy
             24 -> AT26_ReadStatus
             24 -> AT26_SendCommand
             24 -> AT26_WaitReady
             24 -> printf
       24  AT26_Read
             24 -> AT26_IsBusy
             24 -> AT26_SendCommand
             24 -> printf
       32  AT26_ReadJedecId
             32 -> AT26_IsBusy
             32 -> AT26_SendCommand
             32 -> printf
       32  AT26_ReadStatus
             32 -> AT26_IsBusy
             32 -> AT26_SendCommand
             32 -> printf
       16  AT26_Unprotect
             16 -> AT26_EnableWrite
             16 -> AT26_ReadStatus
             16 -> AT26_WriteStatus
             16 -> printf
        8  AT26_WaitReady
              8 -> AT26_ReadStatus
              8 -> printf
       48  AT26_Write
             48 -> AT26_SendCommand
             48 -> __aeabi_uidivmod
             48 -> min
             48 -> printf
       32  AT26_WriteStatus
             32 -> AT26_IsBusy
             32 -> AT26_SendCommand
             32 -> printf
        0  ISR_Spi
              0 -> SPID_Handler
        8  SPI_Init
              8 -> AIC_ConfigureIT
              8 -> AIC_DisableIT
              8 -> AIC_EnableIT
              8 -> AT26_Configure
              8 -> PIO_Configure
              8 -> SPID_Configure
              0 -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?<Constant "-F- ASSERT: ">
      48  ?<Constant "-F- AT26_ChipErase: C...">
      48  ?<Constant "-F- AT26_EraseBlock: ...">
      48  ?<Constant "-F- AT26_GetJedecId: ...">
      44  ?<Constant "-F- AT26_Read: Could ...">
      52  ?<Constant "-F- AT26_WriteStatus:...">
      44  ?<Constant "-W- AT26_EraseBlock: ...">
      44  ?<Constant "-W- AT26_EraseBlock: ...">_1
     176  ?<Constant "C:\\Users\\JDS\\Desktop\\...">
      36  ?<Constant "SPI and AT26 drivers ...">
      32  ?<Constant "Sanity check failed a...">
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_2
       4  ??DataTable10_3
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
      12  ?Subroutine0
     108  AT26_EnableWrite
     220  AT26_EraseBlock
     184  AT26_EraseChip
     104  AT26_Read
     144  AT26_ReadJedecId
     112  AT26_ReadStatus
     128  AT26_Unprotect
      60  AT26_WaitReady
     224  AT26_Write
     132  AT26_WriteStatus
       8  ISR_Spi
     100  SPI_Init
      48  Spi_pins
      40  at26
      16  spid

 
    56 bytes in section .bss
    48 bytes in section .data
   588 bytes in section .rodata
 1 592 bytes in section .text
 
 1 592 bytes of CODE  memory
   588 bytes of CONST memory
   104 bytes of DATA  memory

Errors: none
Warnings: 4
