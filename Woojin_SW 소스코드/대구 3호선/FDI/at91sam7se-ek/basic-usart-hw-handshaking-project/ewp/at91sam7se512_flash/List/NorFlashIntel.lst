###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        02/Jul/2015  09:27:32
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\norflash\NorFlashIntel.c
#    Command line =  
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\norflash\NorFlashIntel.c"
#        -D at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\"
#        --remarks --diag_suppress Pe826,Pe1375 -o
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/peripherals\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/memories\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/components\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\NorFlashIntel.lst
#    Object file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\NorFlashIntel.o
#
###############################################################################

F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\norflash\NorFlashIntel.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          #include "NorFlashCFI.h"
     34          #include "NorFlashCommon.h"
     35          #include <utility/trace.h>
     36          #include <string.h>
     37          
     38          //------------------------------------------------------------------------------
     39          //        Local defination
     40          //------------------------------------------------------------------------------
     41           
     42          /// Command for vendor command set CMD_SET_INTEL. Device commands are written 
     43          /// to the Command User Interface (CUI) to control all flash memory device operations.
     44          #define INTEL_CMD_IDIN             0x0090
     45          #define INTEL_CMD_BLOCK_ERASE_1    0x0020
     46          #define INTEL_CMD_BLOCK_ERASE_2    0x00D0
     47          #define INTEL_CMD_READ_STATUS      0x0070
     48          #define INTEL_CMD_CLEAR_STATUS     0x0050
     49          #define INTEL_CMD_BLOCK_LOCKSTART  0x0060
     50          #define INTEL_CMD_BLOCK_LOCK       0x0001
     51          #define INTEL_CMD_BLOCK_UNLOCK     0x00D0
     52          #define INTEL_CMD_BLOCK_LOCKDOWN   0x002F
     53          #define INTEL_CMD_PROGRAM_WORD     0x0010
     54          #define INTEL_CMD_RESET            0x00FF
     55          
     56          
     57          /// Intel norflash status resgister
     58          #define INTEL_STATUS_DWS    0x80
     59          #define INTEL_STATUS_ESS    0x40
     60          #define INTEL_STATUS_ES     0x20
     61          #define INTEL_STATUS_PS     0x10
     62          #define INTEL_STATUS_VPPS   0x08
     63          #define INTEL_STATUS_PSS    0x04
     64          #define INTEL_STATUS_BLS    0x02
     65          #define INTEL_STATUS_BWS    0x01
     66          
     67          /// Intel norflash device Identifier infomation address offset.
     68          #define INTEL_MANU_ID       0x00
     69          #define INTEL_DEVIDE_ID     0x01
     70          #define INTEL_LOCKSTATUS    0x02
     71          
     72          /// Intel norflash device lock status.
     73          #define INTEL_LOCKSTATUS_LOCKED         0x01
     74          #define INTEL_LOCKSTATUS_LOCKDOWNED     0x02
     75          
     76          //------------------------------------------------------------------------------
     77          //         Local functions
     78          //------------------------------------------------------------------------------
     79          
     80          //------------------------------------------------------------------------------
     81          /// It implements a RESET command.
     82          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
     83          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     84          void intel_Reset(struct NorFlashInfo *pNorFlashInfo, unsigned int address)
     85          {
   \                     intel_Reset:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
     86              unsigned int busAddress;
     87              unsigned int busWidth;
     88              busWidth = NorFlash_GetDataBusWidth(pNorFlashInfo);
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       NorFlash_GetDataBusWidth
   \   00000014   0xE1B07000         MOVS     R7,R0
     89              busAddress = NorFlash_GetAddressInChip(pNorFlashInfo, address);
   \   00000018   0xE1B01005         MOVS     R1,R5
   \   0000001C   0xE1B00004         MOVS     R0,R4
   \   00000020   0x........         BL       NorFlash_GetAddressInChip
   \   00000024   0xE1B06000         MOVS     R6,R0
     90              WriteCommand(busWidth, busAddress, INTEL_CMD_RESET);
   \   00000028   0xE3A020FF         MOV      R2,#+255
   \   0000002C   0xE1B01006         MOVS     R1,R6
   \   00000030   0xE1B00007         MOVS     R0,R7
   \   00000034   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000038   0x........         BL       WriteCommand
     91          }
   \   0000003C   0xE8BD40F1         POP      {R0,R4-R7,LR}
   \   00000040   0xE12FFF1E         BX       LR               ;; return
     92          
     93          
     94          //------------------------------------------------------------------------------
     95          /// The Read Device Identifier command instructs the device to output manufacturer
     96          /// code, device identifier code, block-lock status, protection register data, 
     97          /// or configuration register data by giving offset.
     98          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
     99          /// \param offset 0: Identifier address offset.
    100          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    101          unsigned int intel_ReadIdentification(
    102              struct NorFlashInfo *pNorFlashInfo, 
    103              unsigned int offset)
    104          {
   \                     intel_ReadIdentification:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    105              unsigned int data;
    106              unsigned char busWidth;
    107              unsigned int address;
    108              
    109              // Issue Read Array Command - just in case that the flash is not in Read Array mode 
    110              intel_Reset(pNorFlashInfo, 0);    
   \   0000000C   0xE3A01000         MOV      R1,#+0
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0x........         BL       intel_Reset
    111              busWidth = NorFlash_GetDataBusWidth(pNorFlashInfo);
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       NorFlash_GetDataBusWidth
   \   00000020   0xE1B06000         MOVS     R6,R0
    112              address = NorFlash_GetAddressInChip(pNorFlashInfo, offset);
   \   00000024   0xE1B01005         MOVS     R1,R5
   \   00000028   0xE1B00004         MOVS     R0,R4
   \   0000002C   0x........         BL       NorFlash_GetAddressInChip
   \   00000030   0xE1B07000         MOVS     R7,R0
    113              // Issue the Read Device Identifier command at specified address.
    114              WriteCommand(busWidth, address, INTEL_CMD_IDIN);
   \   00000034   0xE3A02090         MOV      R2,#+144
   \   00000038   0xE1B01007         MOVS     R1,R7
   \   0000003C   0xE1B00006         MOVS     R0,R6
   \   00000040   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000044   0x........         BL       WriteCommand
    115              ReadRawData(busWidth, address, (unsigned char*)&data);
   \   00000048   0xE1B0200D         MOVS     R2,SP
   \   0000004C   0xE1B01007         MOVS     R1,R7
   \   00000050   0xE1B00006         MOVS     R0,R6
   \   00000054   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000058   0x........         BL       ReadRawData
    116              
    117              intel_Reset(pNorFlashInfo, 0);
   \   0000005C   0xE3A01000         MOV      R1,#+0
   \   00000060   0xE1B00004         MOVS     R0,R4
   \   00000064   0x........         BL       intel_Reset
    118              return data;
   \   00000068   0xE59D0000         LDR      R0,[SP, #+0]
   \   0000006C   0xE8BD40F2         POP      {R1,R4-R7,LR}
   \   00000070   0xE12FFF1E         BX       LR               ;; return
    119          }
    120          
    121          
    122          //------------------------------------------------------------------------------
    123          /// Return the status register value.
    124          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    125          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    126          unsigned char intel_ReadStatus(struct NorFlashInfo *pNorFlashInfo, unsigned int address)
    127          {
   \                     intel_ReadStatus:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    128              unsigned int status;
    129              unsigned char busWidth;
    130              unsigned int budAddress;
    131              busWidth = NorFlash_GetDataBusWidth(pNorFlashInfo);
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       NorFlash_GetDataBusWidth
   \   00000014   0xE1B06000         MOVS     R6,R0
    132              
    133              // Issue the Read Status Register command at any address.
    134              budAddress = NorFlash_GetAddressInChip(pNorFlashInfo, address), 
    135              WriteCommand(busWidth, budAddress, INTEL_CMD_READ_STATUS);
   \   00000018   0xE1B01005         MOVS     R1,R5
   \   0000001C   0xE1B00004         MOVS     R0,R4
   \   00000020   0x........         BL       NorFlash_GetAddressInChip
   \   00000024   0xE1B07000         MOVS     R7,R0
   \   00000028   0xE3A02070         MOV      R2,#+112
   \   0000002C   0xE1B01007         MOVS     R1,R7
   \   00000030   0xE1B00006         MOVS     R0,R6
   \   00000034   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000038   0x........         BL       WriteCommand
    136              ReadRawData(busWidth, budAddress, (unsigned char*)&status);
   \   0000003C   0xE1B0200D         MOVS     R2,SP
   \   00000040   0xE1B01007         MOVS     R1,R7
   \   00000044   0xE1B00006         MOVS     R0,R6
   \   00000048   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000004C   0x........         BL       ReadRawData
    137              return status;
   \   00000050   0xE59D0000         LDR      R0,[SP, #+0]
   \   00000054   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000058   0xE8BD40F2         POP      {R1,R4-R7,LR}
   \   0000005C   0xE12FFF1E         BX       LR               ;; return
    138          }
    139          
    140          //------------------------------------------------------------------------------
    141          /// Clear the status register.
    142          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    143          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    144          void intel_ClearStatus(struct NorFlashInfo *pNorFlashInfo)
    145          {
   \                     intel_ClearStatus:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    146              unsigned char busWidth;
    147              unsigned int address;
    148              busWidth = NorFlash_GetDataBusWidth(pNorFlashInfo);
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0x........         BL       NorFlash_GetDataBusWidth
   \   00000010   0xE1B05000         MOVS     R5,R0
    149              
    150              // Issue the Clear Status Register command at any address
    151              address = NorFlash_GetAddressInChip(pNorFlashInfo, 0), 
    152              WriteCommand(busWidth, address, INTEL_CMD_CLEAR_STATUS);
   \   00000014   0xE3A01000         MOV      R1,#+0
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       NorFlash_GetAddressInChip
   \   00000020   0xE1B06000         MOVS     R6,R0
   \   00000024   0xE3A02050         MOV      R2,#+80
   \   00000028   0xE1B01006         MOVS     R1,R6
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000034   0x........         BL       WriteCommand
    153          }
   \   00000038   0xE8BD4070         POP      {R4-R6,LR}
   \   0000003C   0xE12FFF1E         BX       LR               ;; return
    154          
    155          //------------------------------------------------------------------------------
    156          /// Unlocks the specified block of the device. 
    157          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    158          /// \param address Address in sector.
    159          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    160          void intel_UnlockSector(struct NorFlashInfo *pNorFlashInfo, unsigned int address)
    161          {
   \                     intel_UnlockSector:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    162              unsigned int busAddress;
    163              unsigned char busWidth;
    164               // Issue Read Array Command - just in case that the flash is not in Read Array mode 
    165              intel_Reset(pNorFlashInfo, 0);    
   \   0000000C   0xE3A01000         MOV      R1,#+0
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0x........         BL       intel_Reset
    166              // Clear the status register first.
    167             
    168              busWidth = NorFlash_GetDataBusWidth(pNorFlashInfo);
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       NorFlash_GetDataBusWidth
   \   00000020   0xE1B07000         MOVS     R7,R0
    169              busAddress = NorFlash_GetAddressInChip(pNorFlashInfo,address);
   \   00000024   0xE1B01005         MOVS     R1,R5
   \   00000028   0xE1B00004         MOVS     R0,R4
   \   0000002C   0x........         BL       NorFlash_GetAddressInChip
   \   00000030   0xE1B06000         MOVS     R6,R0
    170              
    171              WriteCommand(busWidth, busAddress, INTEL_CMD_BLOCK_LOCKSTART);
   \   00000034   0xE3A02060         MOV      R2,#+96
   \   00000038   0xE1B01006         MOVS     R1,R6
   \   0000003C   0xE1B00007         MOVS     R0,R7
   \   00000040   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000044   0x........         BL       WriteCommand
    172              WriteCommand(busWidth, busAddress, INTEL_CMD_BLOCK_UNLOCK);
   \   00000048   0xE3A020D0         MOV      R2,#+208
   \   0000004C   0xE1B01006         MOVS     R1,R6
   \   00000050   0xE1B00007         MOVS     R0,R7
   \   00000054   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000058   0x........         BL       WriteCommand
    173              intel_Reset(pNorFlashInfo, 0);
   \   0000005C   0xE3A01000         MOV      R1,#+0
   \   00000060   0xE1B00004         MOVS     R0,R4
   \   00000064   0x........         BL       intel_Reset
    174          }
   \   00000068   0xE8BD40F1         POP      {R0,R4-R7,LR}
   \   0000006C   0xE12FFF1E         BX       LR               ;; return
    175          
    176          //------------------------------------------------------------------------------
    177          /// The Read Device Identifier command instructs the device to output block-lock 
    178          /// status.
    179          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    180          /// \param address 0: Address in sector/block.
    181          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    182          unsigned int intel_GetBlockLockStatus(struct NorFlashInfo *pNorFlashInfo, unsigned int address)
    183          {
   \                     intel_GetBlockLockStatus:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    184              return intel_ReadIdentification(pNorFlashInfo, (address + NorFlash_GetByteAddress(pNorFlashInfo ,INTEL_LOCKSTATUS)));
   \   0000000C   0xE3A01002         MOV      R1,#+2
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0x........         BL       NorFlash_GetByteAddress
   \   00000018   0xE0901005         ADDS     R1,R0,R5
   \   0000001C   0xE1B00004         MOVS     R0,R4
   \   00000020   0x........         BL       intel_ReadIdentification
   \   00000024   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   00000028   0xE12FFF1E         BX       LR               ;; return
    185          }
    186          
    187          //------------------------------------------------------------------------------
    188          /// It implement a program word command. Returns 0 if the operation was
    189          /// successful; otherwise returns an error code.
    190          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    191          /// \param address Start address offset to be wrote.
    192          /// \param data word to be written.
    193          //------------------------------------------------------------------------------    

   \                                 In section .text, align 4, keep-with-next
    194          unsigned char intel_Program(
    195              struct NorFlashInfo *pNorFlashInfo,
    196              unsigned int address,
    197              unsigned int data
    198              )
    199          {
   \                     intel_Program:
   \   00000000   0xE92D41F6         PUSH     {R1,R2,R4-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    200              unsigned int status;
    201              unsigned int datain;
                                  ^
Warning[Pe177]: variable "datain" was declared but never referenced
    202              volatile unsigned int busAddress;
    203              unsigned char done = 0;
   \   0000000C   0xE3A07000         MOV      R7,#+0
    204              unsigned char busWidth;
    205              
    206              busWidth = NorFlash_GetDataBusWidth(pNorFlashInfo);
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0x........         BL       NorFlash_GetDataBusWidth
   \   00000018   0xE1B08000         MOVS     R8,R0
    207               // Issue Read Array Command - just in case that the flash is not in Read Array mode 
    208              intel_Reset(pNorFlashInfo, address);    
   \   0000001C   0xE1B01005         MOVS     R1,R5
   \   00000020   0xE1B00004         MOVS     R0,R4
   \   00000024   0x........         BL       intel_Reset
    209              
    210              busAddress = NorFlash_GetAddressInChip(pNorFlashInfo, address);
   \   00000028   0xE1B01005         MOVS     R1,R5
   \   0000002C   0xE1B00004         MOVS     R0,R4
   \   00000030   0x........         BL       NorFlash_GetAddressInChip
   \   00000034   0xE58D0000         STR      R0,[SP, #+0]
    211              /*
    212              // Check if the data already have been erased.
    213              ReadRawData(busWidth, busAddress, (unsigned char*)&datain);
    214              if((datain & data)!= data) {
    215                  return NorCommon_ERROR_CANNOTWRITE;
    216              }
    217              */
    218              // Word programming operations are initiated by writing the Word Program Setup command to the device.
    219              WriteCommand(busWidth, busAddress, INTEL_CMD_PROGRAM_WORD);
   \   00000038   0xE3A02010         MOV      R2,#+16
   \   0000003C   0xE59D1000         LDR      R1,[SP, #+0]
   \   00000040   0xE1B00008         MOVS     R0,R8
   \   00000044   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000048   0x........         BL       WriteCommand
    220              // This is followed by a second write to the device with the address and data to be programmed.
    221              WriteRawData(busWidth, busAddress, (unsigned char*)&data);
   \   0000004C   0xE28D2004         ADD      R2,SP,#+4
   \   00000050   0xE59D1000         LDR      R1,[SP, #+0]
   \   00000054   0xE1B00008         MOVS     R0,R8
   \   00000058   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000005C   0x........         BL       WriteRawData
    222              
    223              // Status register polling 
    224              do {
    225                  status = intel_ReadStatus(pNorFlashInfo,address);
   \                     ??intel_Program_0:
   \   00000060   0xE1B01005         MOVS     R1,R5
   \   00000064   0xE1B00004         MOVS     R0,R4
   \   00000068   0x........         BL       intel_ReadStatus
   \   0000006C   0xE1B06000         MOVS     R6,R0
    226                  // Check if the device is ready.
    227                  if ((status & INTEL_STATUS_DWS) == INTEL_STATUS_DWS ) {
   \   00000070   0xE3160080         TST      R6,#0x80
   \   00000074   0x0A00000D         BEQ      ??intel_Program_1
    228                      // check if VPP within acceptable limits during program or erase operation.
    229                      if ((status & INTEL_STATUS_VPPS) == INTEL_STATUS_VPPS ) {
   \   00000078   0xE3160008         TST      R6,#0x8
   \   0000007C   0x0A000001         BEQ      ??intel_Program_2
    230                          return NorCommon_ERROR_CANNOTWRITE;
   \   00000080   0xE3A00003         MOV      R0,#+3
   \   00000084   0xEA000013         B        ??intel_Program_3
    231                      }
    232                      // Check if the erase block operation is completed. 
    233                      if ((status & INTEL_STATUS_PS) == INTEL_STATUS_PS ) {
   \                     ??intel_Program_2:
   \   00000088   0xE3160010         TST      R6,#0x10
   \   0000008C   0x0A000001         BEQ      ??intel_Program_4
    234                          return NorCommon_ERROR_CANNOTWRITE;
   \   00000090   0xE3A00003         MOV      R0,#+3
   \   00000094   0xEA00000F         B        ??intel_Program_3
    235                      }
    236                      // check if Block locked during program or erase, operation aborted.
    237                          else if ((status & INTEL_STATUS_BLS) == INTEL_STATUS_BLS ) {
   \                     ??intel_Program_4:
   \   00000098   0xE3160002         TST      R6,#0x2
   \   0000009C   0x0A000001         BEQ      ??intel_Program_5
    238                              return NorCommon_ERROR_CANNOTWRITE;
   \   000000A0   0xE3A00003         MOV      R0,#+3
   \   000000A4   0xEA00000B         B        ??intel_Program_3
    239                      }
    240                      else {
    241                          done = 1;
   \                     ??intel_Program_5:
   \   000000A8   0xE3A00001         MOV      R0,#+1
   \   000000AC   0xE1B07000         MOVS     R7,R0
    242                      }
    243                  }
    244              } while (!done);
   \                     ??intel_Program_1:
   \   000000B0   0xE1B00007         MOVS     R0,R7
   \   000000B4   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000B8   0xE3500000         CMP      R0,#+0
   \   000000BC   0x0AFFFFE7         BEQ      ??intel_Program_0
    245              
    246              intel_ClearStatus(pNorFlashInfo);
   \   000000C0   0xE1B00004         MOVS     R0,R4
   \   000000C4   0x........         BL       intel_ClearStatus
    247              intel_Reset(pNorFlashInfo, address);
   \   000000C8   0xE1B01005         MOVS     R1,R5
   \   000000CC   0xE1B00004         MOVS     R0,R4
   \   000000D0   0x........         BL       intel_Reset
    248              return 0;
   \   000000D4   0xE3A00000         MOV      R0,#+0
   \                     ??intel_Program_3:
   \   000000D8   0xE8BD41F6         POP      {R1,R2,R4-R8,LR}
   \   000000DC   0xE12FFF1E         BX       LR               ;; return
    249          }
    250          
    251          //------------------------------------------------------------------------------
    252          //         Exported functions
    253          //------------------------------------------------------------------------------
    254          
    255          //------------------------------------------------------------------------------
    256          /// It implements a RESET command.
    257          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    258          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    259          void INTEL_Reset(struct NorFlashInfo *pNorFlashInfo, unsigned int address)
    260          {
   \                     INTEL_Reset:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    261              intel_Reset(pNorFlashInfo, address);
   \   0000000C   0xE1B01005         MOVS     R1,R5
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0x........         BL       intel_Reset
    262          }
   \   00000018   0xE8BD4031         POP      {R0,R4,R5,LR}
   \   0000001C   0xE12FFF1E         BX       LR               ;; return
    263          
    264          //------------------------------------------------------------------------------
    265          /// The Read Device Identifier command instructs the device to output manufacturer
    266          /// code.
    267          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    268          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    269          unsigned int INTEL_ReadManufactoryId(struct NorFlashInfo *pNorFlashInfo)
    270          {
   \                     INTEL_ReadManufactoryId:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    271              return intel_ReadIdentification(pNorFlashInfo, INTEL_MANU_ID);
   \   00000008   0xE3A01000         MOV      R1,#+0
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       intel_ReadIdentification
   \   00000014   0xE8BD4010         POP      {R4,LR}
   \   00000018   0xE12FFF1E         BX       LR               ;; return
    272          }
    273          
    274          //------------------------------------------------------------------------------
    275          /// The Read Device Identifier command instructs the device to output device id.
    276          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    277          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    278          unsigned int INTEL_ReadDeviceID(struct NorFlashInfo *pNorFlashInfo)
    279          {
   \                     INTEL_ReadDeviceID:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    280              return intel_ReadIdentification(pNorFlashInfo, INTEL_DEVIDE_ID);
   \   00000008   0xE3A01001         MOV      R1,#+1
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       intel_ReadIdentification
   \   00000014   0xE8BD4010         POP      {R4,LR}
   \   00000018   0xE12FFF1E         BX       LR               ;; return
    281          }
    282          
    283          //------------------------------------------------------------------------------
    284          /// Erases the specified block of the device. Returns 0 if the operation was
    285          /// successful; otherwise returns an error code.
    286          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    287          /// \param address Address offset to be erase.
    288          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    289          unsigned char INTEL_EraseSector(
    290              struct NorFlashInfo *pNorFlashInfo, 
    291              unsigned int address)
    292          {
   \                     INTEL_EraseSector:
   \   00000000   0xE92D43F8         PUSH     {R3-R9,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    293              unsigned int status;
    294              unsigned int busAddress;
    295              unsigned char busWidth;
    296              unsigned char done = 0;
   \   0000000C   0xE3A09000         MOV      R9,#+0
    297              
    298              busWidth = NorFlash_GetDataBusWidth(pNorFlashInfo);
   \   00000010   0xE1B00004         MOVS     R0,R4
   \   00000014   0x........         BL       NorFlash_GetDataBusWidth
   \   00000018   0xE1B08000         MOVS     R8,R0
    299               // Issue Read Array Command - just in case that the flash is not in Read Array mode 
    300              intel_Reset(pNorFlashInfo, address);    
   \   0000001C   0xE1B01005         MOVS     R1,R5
   \   00000020   0xE1B00004         MOVS     R0,R4
   \   00000024   0x........         BL       intel_Reset
    301             
    302              // Check the lock status is locked.
    303              status = intel_GetBlockLockStatus(pNorFlashInfo, address);
   \   00000028   0xE1B01005         MOVS     R1,R5
   \   0000002C   0xE1B00004         MOVS     R0,R4
   \   00000030   0x........         BL       intel_GetBlockLockStatus
   \   00000034   0xE1B06000         MOVS     R6,R0
    304              if(( status & INTEL_LOCKSTATUS_LOCKED ) == INTEL_LOCKSTATUS_LOCKED){
   \   00000038   0xE3160001         TST      R6,#0x1
   \   0000003C   0x0A000002         BEQ      ??INTEL_EraseSector_0
    305                  intel_UnlockSector(pNorFlashInfo, address);
   \   00000040   0xE1B01005         MOVS     R1,R5
   \   00000044   0xE1B00004         MOVS     R0,R4
   \   00000048   0x........         BL       intel_UnlockSector
    306              }
    307              // Clear the status register first.
    308              intel_ClearStatus(pNorFlashInfo);
   \                     ??INTEL_EraseSector_0:
   \   0000004C   0xE1B00004         MOVS     R0,R4
   \   00000050   0x........         BL       intel_ClearStatus
    309              busAddress = NorFlash_GetAddressInChip(pNorFlashInfo,address);
   \   00000054   0xE1B01005         MOVS     R1,R5
   \   00000058   0xE1B00004         MOVS     R0,R4
   \   0000005C   0x........         BL       NorFlash_GetAddressInChip
   \   00000060   0xE1B07000         MOVS     R7,R0
    310              // Block erase operations are initiated by writing the Block Erase Setup command to the address of the block to be erased.
    311              WriteCommand(busWidth, busAddress, INTEL_CMD_BLOCK_ERASE_1);
   \   00000064   0xE3A02020         MOV      R2,#+32
   \   00000068   0xE1B01007         MOVS     R1,R7
   \   0000006C   0xE1B00008         MOVS     R0,R8
   \   00000070   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000074   0x........         BL       WriteCommand
    312              // Next, the Block Erase Confirm command is written to the address of the block to be erased.
    313              WriteCommand(busWidth, busAddress, INTEL_CMD_BLOCK_ERASE_2);
   \   00000078   0xE3A020D0         MOV      R2,#+208
   \   0000007C   0xE1B01007         MOVS     R1,R7
   \   00000080   0xE1B00008         MOVS     R0,R8
   \   00000084   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000088   0x........         BL       WriteCommand
    314              // Status register polling 
    315              do {
    316                  status = intel_ReadStatus(pNorFlashInfo,address);
   \                     ??INTEL_EraseSector_1:
   \   0000008C   0xE1B01005         MOVS     R1,R5
   \   00000090   0xE1B00004         MOVS     R0,R4
   \   00000094   0x........         BL       intel_ReadStatus
   \   00000098   0xE1B06000         MOVS     R6,R0
    317                  // Check if the device is ready.
    318                  if ((status & INTEL_STATUS_DWS) == INTEL_STATUS_DWS ) {
   \   0000009C   0xE3160080         TST      R6,#0x80
   \   000000A0   0x0A00001D         BEQ      ??INTEL_EraseSector_2
    319                      // check if VPP within acceptable limits during program or erase operation.
    320                      if ((status & INTEL_STATUS_VPPS) == INTEL_STATUS_VPPS ) {
   \   000000A4   0xE3160008         TST      R6,#0x8
   \   000000A8   0x0A000004         BEQ      ??INTEL_EraseSector_3
    321                          intel_Reset(pNorFlashInfo, 0);
   \   000000AC   0xE3A01000         MOV      R1,#+0
   \   000000B0   0xE1B00004         MOVS     R0,R4
   \   000000B4   0x........         BL       intel_Reset
    322                          return NorCommon_ERROR_CANNOTWRITE;
   \   000000B8   0xE3A00003         MOV      R0,#+3
   \   000000BC   0xEA00001E         B        ??INTEL_EraseSector_4
    323                      }
    324                      // Check if the erase block operation is completed. 
    325                      if ((status & INTEL_STATUS_PS) == INTEL_STATUS_PS ) {
   \                     ??INTEL_EraseSector_3:
   \   000000C0   0xE3160010         TST      R6,#0x10
   \   000000C4   0x0A000004         BEQ      ??INTEL_EraseSector_5
    326                          intel_Reset(pNorFlashInfo, 0);
   \   000000C8   0xE3A01000         MOV      R1,#+0
   \   000000CC   0xE1B00004         MOVS     R0,R4
   \   000000D0   0x........         BL       intel_Reset
    327                          return NorCommon_ERROR_CANNOTWRITE;
   \   000000D4   0xE3A00003         MOV      R0,#+3
   \   000000D8   0xEA000017         B        ??INTEL_EraseSector_4
    328                      }
    329                      // Check if the erase block operation is completed. 
    330                      if ((status & INTEL_STATUS_ES) == INTEL_STATUS_ES ) {
   \                     ??INTEL_EraseSector_5:
   \   000000DC   0xE3160020         TST      R6,#0x20
   \   000000E0   0x0A000004         BEQ      ??INTEL_EraseSector_6
    331                          intel_Reset(pNorFlashInfo, 0);
   \   000000E4   0xE3A01000         MOV      R1,#+0
   \   000000E8   0xE1B00004         MOVS     R0,R4
   \   000000EC   0x........         BL       intel_Reset
    332                          return NorCommon_ERROR_CANNOTWRITE;
   \   000000F0   0xE3A00003         MOV      R0,#+3
   \   000000F4   0xEA000010         B        ??INTEL_EraseSector_4
    333                      }
    334                      
    335                      // check if Block locked during program or erase, operation aborted.
    336                          else if ((status & INTEL_STATUS_BLS) == INTEL_STATUS_BLS ) {
   \                     ??INTEL_EraseSector_6:
   \   000000F8   0xE3160002         TST      R6,#0x2
   \   000000FC   0x0A000004         BEQ      ??INTEL_EraseSector_7
    337                              intel_Reset(pNorFlashInfo, 0);
   \   00000100   0xE3A01000         MOV      R1,#+0
   \   00000104   0xE1B00004         MOVS     R0,R4
   \   00000108   0x........         BL       intel_Reset
    338                              return NorCommon_ERROR_CANNOTWRITE;
   \   0000010C   0xE3A00003         MOV      R0,#+3
   \   00000110   0xEA000009         B        ??INTEL_EraseSector_4
    339                      }
    340                      else {
    341                          done = 1;
   \                     ??INTEL_EraseSector_7:
   \   00000114   0xE3A00001         MOV      R0,#+1
   \   00000118   0xE1B09000         MOVS     R9,R0
    342                      }
    343                  }
    344              } while (!done);
   \                     ??INTEL_EraseSector_2:
   \   0000011C   0xE1B00009         MOVS     R0,R9
   \   00000120   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000124   0xE3500000         CMP      R0,#+0
   \   00000128   0x0AFFFFD7         BEQ      ??INTEL_EraseSector_1
    345              intel_Reset(pNorFlashInfo, address);
   \   0000012C   0xE1B01005         MOVS     R1,R5
   \   00000130   0xE1B00004         MOVS     R0,R4
   \   00000134   0x........         BL       intel_Reset
    346              return 0;
   \   00000138   0xE3A00000         MOV      R0,#+0
   \                     ??INTEL_EraseSector_4:
   \   0000013C   0xE8BD43F2         POP      {R1,R4-R9,LR}
   \   00000140   0xE12FFF1E         BX       LR               ;; return
    347          }
    348          
    349          //------------------------------------------------------------------------------
    350          /// Erases all the block of the device. Returns 0 if the operation was successful;
    351          /// otherwise returns an error code.
    352          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    353          //------------------------------------------------------------------------------
    354          

   \                                 In section .text, align 4, keep-with-next
    355          unsigned char INTEL_EraseChip(struct NorFlashInfo *pNorFlashInfo)
    356          {
   \                     INTEL_EraseChip:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    357              // Interl flash have no independent Chip-erase command.
    358              unsigned int i;
    359              unsigned int sectors;
    360              sectors = NorFlash_GetDeviceNumOfBlocks(pNorFlashInfo);
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0x........         BL       NorFlash_GetDeviceNumOfBlocks
   \   00000010   0xE1B06000         MOVS     R6,R0
    361              for (i = 0; i < sectors; i++) {
   \   00000014   0xE3A00000         MOV      R0,#+0
   \   00000018   0xE1B05000         MOVS     R5,R0
   \                     ??INTEL_EraseChip_0:
   \   0000001C   0xE1550006         CMP      R5,R6
   \   00000020   0x2A00000B         BCS      ??INTEL_EraseChip_1
    362                  if (INTEL_EraseSector(pNorFlashInfo, NorFlash_GetDeviceSectorAddress(pNorFlashInfo, i))) {
   \   00000024   0xE1B01005         MOVS     R1,R5
   \   00000028   0xE1B00004         MOVS     R0,R4
   \   0000002C   0x........         BL       NorFlash_GetDeviceSectorAddress
   \   00000030   0xE1B01000         MOVS     R1,R0
   \   00000034   0xE1B00004         MOVS     R0,R4
   \   00000038   0x........         BL       INTEL_EraseSector
   \   0000003C   0xE3500000         CMP      R0,#+0
   \   00000040   0x0A000001         BEQ      ??INTEL_EraseChip_2
    363                      return NorCommon_ERROR_CANNOTERASE;
   \   00000044   0xE3A00004         MOV      R0,#+4
   \   00000048   0xEA000002         B        ??INTEL_EraseChip_3
    364                  }
    365              }
   \                     ??INTEL_EraseChip_2:
   \   0000004C   0xE2955001         ADDS     R5,R5,#+1
   \   00000050   0xEAFFFFF1         B        ??INTEL_EraseChip_0
    366              return 0;
   \                     ??INTEL_EraseChip_1:
   \   00000054   0xE3A00000         MOV      R0,#+0
   \                     ??INTEL_EraseChip_3:
   \   00000058   0xE8BD4070         POP      {R4-R6,LR}
   \   0000005C   0xE12FFF1E         BX       LR               ;; return
    367          }
    368          
    369          //------------------------------------------------------------------------------
    370          /// Sends data to the struct NorFlashInfo chip from the provided buffer.
    371          /// \param pNorFlashInfo  Pointer to an struct NorFlashInfo instance.
    372          /// \param address Start address offset to be wrote.
    373          /// \param buffer Buffer where the data is stored.
    374          /// \param size Number of bytes that will be written.
    375          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    376          unsigned char INTEL_Write_Data(
    377              struct NorFlashInfo *pNorFlashInfo,
    378              unsigned int address,
    379              unsigned char *buffer,
    380              unsigned int size)
    381          {
   \                     INTEL_Write_Data:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    382              unsigned int i;
    383              unsigned char busWidth;
    384              
    385              busWidth = pNorFlashInfo->deviceChipWidth;
   \   00000014   0xE5D40004         LDRB     R0,[R4, #+4]
   \   00000018   0xE1B09000         MOVS     R9,R0
    386              if (busWidth == FLASH_CHIP_WIDTH_8BITS ){ 
   \   0000001C   0xE1B00009         MOVS     R0,R9
   \   00000020   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000024   0xE3500001         CMP      R0,#+1
   \   00000028   0x1A00000E         BNE      ??INTEL_Write_Data_0
    387                  for(i=0; i < size; i++) {
   \   0000002C   0xE3A00000         MOV      R0,#+0
   \   00000030   0xE1B08000         MOVS     R8,R0
   \                     ??INTEL_Write_Data_1:
   \   00000034   0xE1580007         CMP      R8,R7
   \   00000038   0x2A000038         BCS      ??INTEL_Write_Data_2
    388                      if(intel_Program(pNorFlashInfo, address, buffer[i])) {
   \   0000003C   0xE7D82006         LDRB     R2,[R8, +R6]
   \   00000040   0xE1B01005         MOVS     R1,R5
   \   00000044   0xE1B00004         MOVS     R0,R4
   \   00000048   0x........         BL       intel_Program
   \   0000004C   0xE3500000         CMP      R0,#+0
   \   00000050   0x0A000001         BEQ      ??INTEL_Write_Data_3
    389                          return NorCommon_ERROR_CANNOTWRITE;
   \   00000054   0xE3A00003         MOV      R0,#+3
   \   00000058   0xEA000031         B        ??INTEL_Write_Data_4
    390                      }
    391                      address ++;
   \                     ??INTEL_Write_Data_3:
   \   0000005C   0xE2955001         ADDS     R5,R5,#+1
    392                  }
   \   00000060   0xE2988001         ADDS     R8,R8,#+1
   \   00000064   0xEAFFFFF2         B        ??INTEL_Write_Data_1
    393              }
    394              else if( busWidth == FLASH_CHIP_WIDTH_16BITS ){
   \                     ??INTEL_Write_Data_0:
   \   00000068   0xE1B00009         MOVS     R0,R9
   \   0000006C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000070   0xE3500002         CMP      R0,#+2
   \   00000074   0x1A000012         BNE      ??INTEL_Write_Data_5
    395                  unsigned short *buffer16 = (unsigned short *) buffer;
   \   00000078   0xE1B0A006         MOVS     R10,R6
    396                  size = (size + 1) >> 1;
   \   0000007C   0xE2970001         ADDS     R0,R7,#+1
   \   00000080   0xE1B070A0         LSRS     R7,R0,#+1
    397                  for(i=0; i < size; i++) {
   \   00000084   0xE3A00000         MOV      R0,#+0
   \   00000088   0xE1B08000         MOVS     R8,R0
   \                     ??INTEL_Write_Data_6:
   \   0000008C   0xE1580007         CMP      R8,R7
   \   00000090   0x2A000022         BCS      ??INTEL_Write_Data_2
    398                      
    399                      if(intel_Program(pNorFlashInfo, address, buffer16[i])){
   \   00000094   0xE1B00088         LSLS     R0,R8,#+1
   \   00000098   0xE19020BA         LDRH     R2,[R0, +R10]
   \   0000009C   0xE1B01005         MOVS     R1,R5
   \   000000A0   0xE1B00004         MOVS     R0,R4
   \   000000A4   0x........         BL       intel_Program
   \   000000A8   0xE3500000         CMP      R0,#+0
   \   000000AC   0x0A000001         BEQ      ??INTEL_Write_Data_7
    400                          return NorCommon_ERROR_CANNOTWRITE;
   \   000000B0   0xE3A00003         MOV      R0,#+3
   \   000000B4   0xEA00001A         B        ??INTEL_Write_Data_4
    401                      }
    402                      address+= 2;
   \                     ??INTEL_Write_Data_7:
   \   000000B8   0xE2955002         ADDS     R5,R5,#+2
    403                  }
   \   000000BC   0xE2988001         ADDS     R8,R8,#+1
   \   000000C0   0xEAFFFFF1         B        ??INTEL_Write_Data_6
    404              }
    405              else if(busWidth == FLASH_CHIP_WIDTH_32BITS ){
   \                     ??INTEL_Write_Data_5:
   \   000000C4   0xE1B00009         MOVS     R0,R9
   \   000000C8   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000CC   0xE3500004         CMP      R0,#+4
   \   000000D0   0x1A000012         BNE      ??INTEL_Write_Data_2
    406                  unsigned int *buffer32 = (unsigned int *) buffer;
   \   000000D4   0xE1B0A006         MOVS     R10,R6
    407                  size = (size + 3) >> 2;
   \   000000D8   0xE2970003         ADDS     R0,R7,#+3
   \   000000DC   0xE1B07120         LSRS     R7,R0,#+2
    408                  for(i=0; i < size; i++) {
   \   000000E0   0xE3A00000         MOV      R0,#+0
   \   000000E4   0xE1B08000         MOVS     R8,R0
   \                     ??INTEL_Write_Data_8:
   \   000000E8   0xE1580007         CMP      R8,R7
   \   000000EC   0x2A00000B         BCS      ??INTEL_Write_Data_2
    409                      if(intel_Program(pNorFlashInfo, address, buffer32[i])){
   \   000000F0   0xE1B00108         LSLS     R0,R8,#+2
   \   000000F4   0xE790200A         LDR      R2,[R0, +R10]
   \   000000F8   0xE1B01005         MOVS     R1,R5
   \   000000FC   0xE1B00004         MOVS     R0,R4
   \   00000100   0x........         BL       intel_Program
   \   00000104   0xE3500000         CMP      R0,#+0
   \   00000108   0x0A000001         BEQ      ??INTEL_Write_Data_9
    410                          return NorCommon_ERROR_CANNOTWRITE;
   \   0000010C   0xE3A00003         MOV      R0,#+3
   \   00000110   0xEA000003         B        ??INTEL_Write_Data_4
    411                      }
    412                      address+= 4;
   \                     ??INTEL_Write_Data_9:
   \   00000114   0xE2955004         ADDS     R5,R5,#+4
    413                  }
   \   00000118   0xE2988001         ADDS     R8,R8,#+1
   \   0000011C   0xEAFFFFF1         B        ??INTEL_Write_Data_8
    414              }
    415              return 0;
   \                     ??INTEL_Write_Data_2:
   \   00000120   0xE3A00000         MOV      R0,#+0
   \                     ??INTEL_Write_Data_4:
   \   00000124   0xE8BD47F0         POP      {R4-R10,LR}
   \   00000128   0xE12FFF1E         BX       LR               ;; return
    416          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   INTEL_EraseChip
        16   -> INTEL_EraseSector
        16   -> NorFlash_GetDeviceNumOfBlocks
        16   -> NorFlash_GetDeviceSectorAddress
      32   INTEL_EraseSector
        32   -> NorFlash_GetAddressInChip
        32   -> NorFlash_GetDataBusWidth
        32   -> WriteCommand
        32   -> intel_ClearStatus
        32   -> intel_GetBlockLockStatus
        32   -> intel_ReadStatus
        32   -> intel_Reset
        32   -> intel_UnlockSector
       8   INTEL_ReadDeviceID
         8   -> intel_ReadIdentification
       8   INTEL_ReadManufactoryId
         8   -> intel_ReadIdentification
      16   INTEL_Reset
        16   -> intel_Reset
      32   INTEL_Write_Data
        32   -> intel_Program
      16   intel_ClearStatus
        16   -> NorFlash_GetAddressInChip
        16   -> NorFlash_GetDataBusWidth
        16   -> WriteCommand
      16   intel_GetBlockLockStatus
        16   -> NorFlash_GetByteAddress
        16   -> intel_ReadIdentification
      32   intel_Program
        32   -> NorFlash_GetAddressInChip
        32   -> NorFlash_GetDataBusWidth
        32   -> WriteCommand
        32   -> WriteRawData
        32   -> intel_ClearStatus
        32   -> intel_ReadStatus
        32   -> intel_Reset
      24   intel_ReadIdentification
        24   -> NorFlash_GetAddressInChip
        24   -> NorFlash_GetDataBusWidth
        24   -> ReadRawData
        24   -> WriteCommand
        24   -> intel_Reset
      24   intel_ReadStatus
        24   -> NorFlash_GetAddressInChip
        24   -> NorFlash_GetDataBusWidth
        24   -> ReadRawData
        24   -> WriteCommand
      24   intel_Reset
        24   -> NorFlash_GetAddressInChip
        24   -> NorFlash_GetDataBusWidth
        24   -> WriteCommand
      24   intel_UnlockSector
        24   -> NorFlash_GetAddressInChip
        24   -> NorFlash_GetDataBusWidth
        24   -> WriteCommand
        24   -> intel_Reset


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      96  INTEL_EraseChip
     324  INTEL_EraseSector
      28  INTEL_ReadDeviceID
      28  INTEL_ReadManufactoryId
      32  INTEL_Reset
     300  INTEL_Write_Data
      64  intel_ClearStatus
      44  intel_GetBlockLockStatus
     224  intel_Program
     116  intel_ReadIdentification
      96  intel_ReadStatus
      68  intel_Reset
     112  intel_UnlockSector

 
 1 532 bytes in section .text
 
 1 532 bytes of CODE memory

Errors: none
Warnings: 1
