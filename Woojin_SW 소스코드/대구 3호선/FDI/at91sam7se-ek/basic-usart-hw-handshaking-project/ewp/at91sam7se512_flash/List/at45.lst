###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        02/Jul/2015  09:27:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\spi-flash\at45.c
#    Command line =  
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\spi-flash\at45.c"
#        -D at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\"
#        --remarks --diag_suppress Pe826,Pe1375 -o
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/peripherals\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/memories\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/components\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\at45.lst
#    Object file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\at45.o
#
###############################################################################

F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\spi-flash\at45.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "at45.h"
     35          #include <board.h>
     36          #include <utility/assert.h>
     37          
     38          #include <string.h>
     39          
     40          //------------------------------------------------------------------------------
     41          //         Internal definitions
     42          //------------------------------------------------------------------------------
     43          
     44          /// Number of dataflash which can be recognized.
     45          #define NUMDATAFLASH    (sizeof(at45Devices) / sizeof(At45Desc))
     46          
     47          //------------------------------------------------------------------------------
     48          //         Local variables
     49          //------------------------------------------------------------------------------
     50          
     51          /// indicate if the device is configured as binary page or not.

   \                                 In section .bss, align 1
     52          static unsigned char configuredBinaryPage;
   \                     configuredBinaryPage:
   \   00000000                      DS8 1
     53          
     54          //------------------------------------------------------------------------------
     55          //         Internal variables
     56          //------------------------------------------------------------------------------
     57          

   \                                 In section .rodata, align 4
     58          static const At45Desc at45Devices[] = {
   \                     at45Devices:
   \   00000000   0x00000200         DC32 512, 1, 264, 9
   \              0x00000001   
   \              0x00000108   
   \              0x00000009   
   \   00000010   0x0C 0x00          DC8 12, 0, 0, 0
   \              0x00 0x00    
   \   00000014   0x........         DC32 ?_0, 1024, 1, 264, 9
   \              0x00000400   
   \              0x00000001   
   \              0x00000108   
   \              0x00000009   
   \   00000028   0x14 0x00          DC8 20, 0, 0, 0
   \              0x00 0x00    
   \   0000002C   0x........         DC32 ?_1, 2048, 1, 264, 9
   \              0x00000800   
   \              0x00000001   
   \              0x00000108   
   \              0x00000009   
   \   00000040   0x1C 0x00          DC8 28, 0, 0, 0
   \              0x00 0x00    
   \   00000044   0x........         DC32 ?_2, 4096, 1, 264, 9
   \              0x00001000   
   \              0x00000001   
   \              0x00000108   
   \              0x00000009   
   \   00000058   0x24 0x00          DC8 36, 0, 0, 0
   \              0x00 0x00    
   \   0000005C   0x........         DC32 ?_3, 4096, 1, 528, 10
   \              0x00001000   
   \              0x00000001   
   \              0x00000210   
   \              0x0000000A   
   \   00000070   0x2C 0x00          DC8 44, 0, 0, 0
   \              0x00 0x00    
   \   00000074   0x........         DC32 ?_4, 8192, 1, 528, 10
   \              0x00002000   
   \              0x00000001   
   \              0x00000210   
   \              0x0000000A   
   \   00000088   0x34 0x00          DC8 52, 0, 0, 0
   \              0x00 0x00    
   \   0000008C   0x........         DC32 ?_5, 8192, 1, 1056, 11
   \              0x00002000   
   \              0x00000001   
   \              0x00000420   
   \              0x0000000B   
   \   000000A0   0x3C 0x00          DC8 60, 0, 0, 0
   \              0x00 0x00    
   \   000000A4   0x........         DC32 ?_6, 16384, 1, 1056, 11
   \              0x00004000   
   \              0x00000001   
   \              0x00000420   
   \              0x0000000B   
   \   000000B8   0x10 0x00          DC8 16, 0, 0, 0
   \              0x00 0x00    
   \   000000BC   0x........         DC32 ?_7, 16384, 1, 2112, 12
   \              0x00004000   
   \              0x00000001   
   \              0x00000840   
   \              0x0000000C   
   \   000000D0   0x18 0x00          DC8 24, 0, 0, 0
   \              0x00 0x00    
   \   000000D4   0x........         DC32 ?_8, 32768, 1, 2112, 12
   \              0x00008000   
   \              0x00000001   
   \              0x00000840   
   \              0x0000000C   
   \   000000E8   0x20 0x00          DC8 32, 0, 0, 0
   \              0x00 0x00    
   \   000000EC   0x........         DC32 ?_9
     59              {  512,  1, 264,   9, 0x0C, "AT45DB011D"},
     60              { 1024,  1, 264,   9, 0x14, "AT45DB021D"},
     61              { 2048,  1, 264,   9, 0x1C, "AT45DB041D"},
     62              { 4096,  1, 264,   9, 0x24, "AT45DB081D"},
     63              { 4096,  1, 528,  10, 0x2C, "AT45DB161D"},
     64              { 8192,  1, 528,  10, 0x34, "AT45DB321D"},
     65              { 8192,  1, 1056, 11, 0x3C, "AT45DB642D"},
     66              {16384,  1, 1056, 11, 0x10, "AT45DB1282"},
     67              {16384,  1, 2112, 12, 0x18, "AT45DB2562"},
     68              {32768,  1, 2112, 12, 0x20, "AT45DB5122"}
     69          };
     70          
     71          //------------------------------------------------------------------------------
     72          //         Exported functions
     73          //------------------------------------------------------------------------------
     74          
     75          //------------------------------------------------------------------------------
     76          /// Initializes an AT45 instance and configures SPI chip select register.
     77          /// Always returns 0.
     78          /// \param pAt45  Pointer to the At45 instance to initialize.
     79          /// \param pSpid  Pointer to the underlying SPI driver.
     80          /// \param spiCs  Chip select value to connect to the At45.
     81          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     82          unsigned char AT45_Configure(At45 *pAt45, Spid *pSpid, unsigned char spiCs)
     83          {
   \                     AT45_Configure:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
     84              SpidCmd *pCommand;
     85          
     86              // Sanity checks
     87              ASSERT(pSpid, "AT45_Configure: pSpid is 0.\n\r");
   \   00000010   0xE3550000         CMP      R5,#+0
   \   00000014   0x1A000004         BNE      ??AT45_Configure_0
   \   00000018   0x........         LDR      R0,??DataTable3
   \   0000001C   0x........         BL       printf
   \   00000020   0x........         LDR      R0,??DataTable3_1
   \   00000024   0x........         BL       printf
   \                     ??AT45_Configure_1:
   \   00000028   0xEAFFFFFE         B        ??AT45_Configure_1
     88              ASSERT(pAt45, "AT45_Configure: pAt45 is 0.\n\r");
   \                     ??AT45_Configure_0:
   \   0000002C   0xE3540000         CMP      R4,#+0
   \   00000030   0x1A000004         BNE      ??AT45_Configure_2
   \   00000034   0x........         LDR      R0,??DataTable3
   \   00000038   0x........         BL       printf
   \   0000003C   0x........         LDR      R0,??DataTable3_2
   \   00000040   0x........         BL       printf
   \                     ??AT45_Configure_3:
   \   00000044   0xEAFFFFFE         B        ??AT45_Configure_3
     89          
     90              // Initialize the At45 instance
     91              pAt45->pSpid = pSpid;
   \                     ??AT45_Configure_2:
   \   00000048   0xE5845000         STR      R5,[R4, #+0]
     92              pAt45->pDesc = 0;
   \   0000004C   0xE3A00000         MOV      R0,#+0
   \   00000050   0xE584001C         STR      R0,[R4, #+28]
     93              memset(pAt45->pCmdBuffer, 0, 8);
   \   00000054   0xE3A08008         MOV      R8,#+8
   \   00000058   0xE3A09000         MOV      R9,#+0
   \   0000005C   0xE294A020         ADDS     R10,R4,#+32
   \   00000060   0xE1B02009         MOVS     R2,R9
   \   00000064   0xE1B01008         MOVS     R1,R8
   \   00000068   0xE1B0000A         MOVS     R0,R10
   \   0000006C   0x........         BL       __aeabi_memset
     94          
     95              // Initialize the spidCmd structure
     96              pCommand = &(pAt45->command);
   \   00000070   0xE2940004         ADDS     R0,R4,#+4
   \   00000074   0xE1B07000         MOVS     R7,R0
     97              pCommand->pCmd = pAt45->pCmdBuffer;
   \   00000078   0xE2940020         ADDS     R0,R4,#+32
   \   0000007C   0xE5870000         STR      R0,[R7, #+0]
     98              pCommand->callback = 0;
   \   00000080   0xE3A00000         MOV      R0,#+0
   \   00000084   0xE5870010         STR      R0,[R7, #+16]
     99              pCommand->pArgument = 0;
   \   00000088   0xE3A00000         MOV      R0,#+0
   \   0000008C   0xE5870014         STR      R0,[R7, #+20]
    100              pCommand->spiCs = spiCs;
   \   00000090   0xE5C7600E         STRB     R6,[R7, #+14]
    101          
    102              return 0;
   \   00000094   0xE3A00000         MOV      R0,#+0
   \   00000098   0xE8BD47F0         POP      {R4-R10,LR}
   \   0000009C   0xE12FFF1E         BX       LR               ;; return
    103          }
    104          
    105          //------------------------------------------------------------------------------
    106          /// This function returns 1 if the At45 driver is not executing any command;
    107          /// otherwise it returns 0.
    108          /// \param pAt45  Pointer to an At45 instance.
    109          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    110          unsigned char AT45_IsBusy(At45 *pAt45)
    111          {
   \                     AT45_IsBusy:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    112              return SPID_IsBusy(pAt45->pSpid);
   \   00000008   0xE5940000         LDR      R0,[R4, #+0]
   \   0000000C   0x........         BL       SPID_IsBusy
   \   00000010   0xE8BD4010         POP      {R4,LR}
   \   00000014   0xE12FFF1E         BX       LR               ;; return
    113          }
    114          
    115          //------------------------------------------------------------------------------
    116          /// Sends a command to the dataflash through the SPI. The command is identified
    117          /// by its command code and the number of bytes to transfer (1 + number of
    118          /// address bytes + number of dummy bytes). If data needs to be received, then
    119          /// a data buffer must be provided.
    120          /// This function does not block; its optional callback will be invoked when
    121          /// the transfer completes.
    122          /// \param pAt45  Pointer to an At45 driver instance.
    123          /// \param cmd  Command code.
    124          /// \param cmdSize  Size of command code + address bytes + dummy bytes.
    125          /// \param pData  Data buffer.
    126          /// \param dataSize  Number of data bytes to send/receive.
    127          /// \param address  Address at which the command is performed if meaningful.
    128          /// \param callback  Optional callback to invoke at end of transfer.
    129          /// \param pArgument  Optional parameter to the callback function.
    130          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    131          unsigned char AT45_SendCommand(
    132              At45 *pAt45,
    133              unsigned char cmd,
    134              unsigned char cmdSize,
    135              unsigned char *pData,
    136              unsigned int dataSize,
    137              unsigned int address,
    138              SpidCallback callback,
    139              void *pArgument)
    140          {
   \                     AT45_SendCommand:
   \   00000000   0xE92D4FFA         PUSH     {R1,R3-R11,LR}
   \   00000004   0xE24DD00C         SUB      SP,SP,#+12
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05002         MOVS     R5,R2
   \   00000010   0xE59D603C         LDR      R6,[SP, #+60]
   \   00000014   0xE59D7040         LDR      R7,[SP, #+64]
   \   00000018   0xE59D8044         LDR      R8,[SP, #+68]
    141              SpidCmd *pCommand;
    142              const At45Desc *pDesc = pAt45->pDesc;
   \   0000001C   0xE594A01C         LDR      R10,[R4, #+28]
    143              unsigned int dfAddress = 0;
   \   00000020   0xE3A0B000         MOV      R11,#+0
    144          
    145              // Sanity checks
    146              ASSERT(pAt45, "AT45_Command: pAt45 is 0.\n\r");
   \   00000024   0xE3540000         CMP      R4,#+0
   \   00000028   0x1A000004         BNE      ??AT45_SendCommand_0
   \   0000002C   0x........         LDR      R0,??DataTable3
   \   00000030   0x........         BL       printf
   \   00000034   0x........         LDR      R0,??DataTable3_3
   \   00000038   0x........         BL       printf
   \                     ??AT45_SendCommand_1:
   \   0000003C   0xEAFFFFFE         B        ??AT45_SendCommand_1
    147              ASSERT(pDesc || (cmd == AT45_STATUS_READ),
    148                     "AT45_Command: Device has no descriptor, only STATUS_READ command allowed\n\r");
   \                     ??AT45_SendCommand_0:
   \   00000040   0xE35A0000         CMP      R10,#+0
   \   00000044   0x1A000007         BNE      ??AT45_SendCommand_2
   \   00000048   0xE5DD000C         LDRB     R0,[SP, #+12]
   \   0000004C   0xE35000D7         CMP      R0,#+215
   \   00000050   0x0A000004         BEQ      ??AT45_SendCommand_2
   \   00000054   0x........         LDR      R0,??DataTable3
   \   00000058   0x........         BL       printf
   \   0000005C   0x........         LDR      R0,??DataTable3_4
   \   00000060   0x........         BL       printf
   \                     ??AT45_SendCommand_3:
   \   00000064   0xEAFFFFFE         B        ??AT45_SendCommand_3
    149          
    150              // Check if the SPI driver is available
    151              if (AT45_IsBusy(pAt45)) {
   \                     ??AT45_SendCommand_2:
   \   00000068   0xE1B00004         MOVS     R0,R4
   \   0000006C   0x........         BL       AT45_IsBusy
   \   00000070   0xE3500000         CMP      R0,#+0
   \   00000074   0x0A000001         BEQ      ??AT45_SendCommand_4
    152          
    153                  return AT45_ERROR_LOCK;
   \   00000078   0xE3A00001         MOV      R0,#+1
   \   0000007C   0xEA000048         B        ??AT45_SendCommand_5
    154              }
    155          
    156              // Compute command pattern
    157              pAt45->pCmdBuffer[0] = cmd;
   \                     ??AT45_SendCommand_4:
   \   00000080   0xE5DD000C         LDRB     R0,[SP, #+12]
   \   00000084   0xE5C40020         STRB     R0,[R4, #+32]
    158          
    159              // Add address bytes if necessary
    160              if (cmdSize > 1) {
   \   00000088   0xE1B00005         MOVS     R0,R5
   \   0000008C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000090   0xE3500002         CMP      R0,#+2
   \   00000094   0xBA000031         BLT      ??AT45_SendCommand_6
    161          
    162                  ASSERT(pDesc, "AT45_Command: No descriptor for dataflash.\n\r");
   \   00000098   0xE35A0000         CMP      R10,#+0
   \   0000009C   0x1A000004         BNE      ??AT45_SendCommand_7
   \   000000A0   0x........         LDR      R0,??DataTable3
   \   000000A4   0x........         BL       printf
   \   000000A8   0x........         LDR      R0,??DataTable3_5
   \   000000AC   0x........         BL       printf
   \                     ??AT45_SendCommand_8:
   \   000000B0   0xEAFFFFFE         B        ??AT45_SendCommand_8
    163                  if (!configuredBinaryPage) {
   \                     ??AT45_SendCommand_7:
   \   000000B4   0x........         LDR      R0,??DataTable3_6
   \   000000B8   0xE5D00000         LDRB     R0,[R0, #+0]
   \   000000BC   0xE3500000         CMP      R0,#+0
   \   000000C0   0x1A00000D         BNE      ??AT45_SendCommand_9
    164                      dfAddress =
    165                          ((address / (pDesc->pageSize)) << pDesc->pageOffset)
    166                           + (address % (pDesc->pageSize));
   \   000000C4   0xE1B00006         MOVS     R0,R6
   \   000000C8   0xE59A1008         LDR      R1,[R10, #+8]
   \   000000CC   0x........         BL       __aeabi_uidiv
   \   000000D0   0xE59A100C         LDR      R1,[R10, #+12]
   \   000000D4   0xE58D1000         STR      R1,[SP, #+0]
   \   000000D8   0xE58D0004         STR      R0,[SP, #+4]
   \   000000DC   0xE1B00006         MOVS     R0,R6
   \   000000E0   0xE59A1008         LDR      R1,[R10, #+8]
   \   000000E4   0x........         BL       __aeabi_uidivmod
   \   000000E8   0xE59D0004         LDR      R0,[SP, #+4]
   \   000000EC   0xE59D2000         LDR      R2,[SP, #+0]
   \   000000F0   0xE0910210         ADDS     R0,R1,R0, LSL R2
   \   000000F4   0xE1B0B000         MOVS     R11,R0
   \   000000F8   0xEA000000         B        ??AT45_SendCommand_10
    167                  }
    168                  else {
    169                      dfAddress = address;
   \                     ??AT45_SendCommand_9:
   \   000000FC   0xE1B0B006         MOVS     R11,R6
    170                  }
    171                  // Write address bytes
    172                  if (pDesc->pageNumber >= 16384) {
   \                     ??AT45_SendCommand_10:
   \   00000100   0xE59A0000         LDR      R0,[R10, #+0]
   \   00000104   0xE3500C40         CMP      R0,#+16384
   \   00000108   0x3A00000F         BCC      ??AT45_SendCommand_11
    173          
    174                      pAt45->pCmdBuffer[1] = ((dfAddress & 0x0F000000) >> 24);
   \   0000010C   0xE1B00C2B         LSRS     R0,R11,#+24
   \   00000110   0xE210000F         ANDS     R0,R0,#0xF
   \   00000114   0xE5C40021         STRB     R0,[R4, #+33]
    175                      pAt45->pCmdBuffer[2] = ((dfAddress & 0x00FF0000) >> 16);
   \   00000118   0xE1B0082B         LSRS     R0,R11,#+16
   \   0000011C   0xE5C40022         STRB     R0,[R4, #+34]
    176                      pAt45->pCmdBuffer[3] = ((dfAddress & 0x0000FF00) >> 8);
   \   00000120   0xE1B0042B         LSRS     R0,R11,#+8
   \   00000124   0xE5C40023         STRB     R0,[R4, #+35]
    177                      pAt45->pCmdBuffer[4] = ((dfAddress & 0x000000FF) >> 0);
   \   00000128   0xE5C4B024         STRB     R11,[R4, #+36]
    178              
    179                      if ((cmd != AT45_CONTINUOUS_READ) && (cmd != AT45_PAGE_READ)) {
   \   0000012C   0xE5DD000C         LDRB     R0,[SP, #+12]
   \   00000130   0xE350000B         CMP      R0,#+11
   \   00000134   0x0A000009         BEQ      ??AT45_SendCommand_6
   \   00000138   0xE5DD000C         LDRB     R0,[SP, #+12]
   \   0000013C   0xE35000D2         CMP      R0,#+210
   \   00000140   0x0A000006         BEQ      ??AT45_SendCommand_6
    180              
    181                          cmdSize++;
   \   00000144   0xE2955001         ADDS     R5,R5,#+1
   \   00000148   0xEA000004         B        ??AT45_SendCommand_6
    182                      }
    183                  }
    184                  else {
    185          
    186                      pAt45->pCmdBuffer[1] = ((dfAddress & 0x00FF0000) >> 16);
   \                     ??AT45_SendCommand_11:
   \   0000014C   0xE1B0082B         LSRS     R0,R11,#+16
   \   00000150   0xE5C40021         STRB     R0,[R4, #+33]
    187                      pAt45->pCmdBuffer[2] = ((dfAddress & 0x0000FF00) >> 8);
   \   00000154   0xE1B0042B         LSRS     R0,R11,#+8
   \   00000158   0xE5C40022         STRB     R0,[R4, #+34]
    188                      pAt45->pCmdBuffer[3] = ((dfAddress & 0x000000FF) >> 0);
   \   0000015C   0xE5C4B023         STRB     R11,[R4, #+35]
    189                  }
    190              }
    191          
    192              // Update the SPI Transfer descriptors
    193              pCommand = &(pAt45->command);
   \                     ??AT45_SendCommand_6:
   \   00000160   0xE2940004         ADDS     R0,R4,#+4
   \   00000164   0xE1B09000         MOVS     R9,R0
    194              pCommand->cmdSize = cmdSize;
   \   00000168   0xE5C95004         STRB     R5,[R9, #+4]
    195              pCommand->pData = pData;
   \   0000016C   0xE59D0010         LDR      R0,[SP, #+16]
   \   00000170   0xE5890008         STR      R0,[R9, #+8]
    196              pCommand->dataSize = dataSize;
   \   00000174   0xE59D0038         LDR      R0,[SP, #+56]
   \   00000178   0xE1C900BC         STRH     R0,[R9, #+12]
    197              pCommand->callback = callback;
   \   0000017C   0xE5897010         STR      R7,[R9, #+16]
    198              pCommand->pArgument = pArgument;
   \   00000180   0xE5898014         STR      R8,[R9, #+20]
    199          
    200              // Send Command and data through the SPI
    201              if (SPID_SendCommand(pAt45->pSpid, pCommand)) {
   \   00000184   0xE1B01009         MOVS     R1,R9
   \   00000188   0xE5940000         LDR      R0,[R4, #+0]
   \   0000018C   0x........         BL       SPID_SendCommand
   \   00000190   0xE3500000         CMP      R0,#+0
   \   00000194   0x0A000001         BEQ      ??AT45_SendCommand_12
    202          
    203                  return AT45_ERROR_SPI;
   \   00000198   0xE3A00002         MOV      R0,#+2
   \   0000019C   0xEA000000         B        ??AT45_SendCommand_5
    204              }
    205          
    206              return 0;
   \                     ??AT45_SendCommand_12:
   \   000001A0   0xE3A00000         MOV      R0,#+0
   \                     ??AT45_SendCommand_5:
   \   000001A4   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000001A8   0xE8BD4FF0         POP      {R4-R11,LR}
   \   000001AC   0xE12FFF1E         BX       LR               ;; return
    207          }
    208          
    209          //------------------------------------------------------------------------------
    210          /// This function returns the At45Desc structure corresponding to the device
    211          /// connected
    212          /// It automatically initializes pAt45->pDesc field structure.
    213          /// This function shall be called by the application before AT45_SendCommand.
    214          /// Returns 0 if successful; Otherwise, returns AT45_ERROR_LOCK if the At45
    215          /// driver is in use or AT45_ERROR_SPI if there was an error with the SPI driver.
    216          /// \param pAt45  Pointer to an AT45 driver instance.
    217          /// \param status  Device status register value.
    218          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    219          const At45Desc * AT45_FindDevice(At45 *pAt45, unsigned char status)
    220          {
   \                     AT45_FindDevice:
   \   00000000   0xE92D4000         PUSH     {LR}
   \   00000004   0xE1B02000         MOVS     R2,R0
    221              unsigned int i;
    222              unsigned char id = AT45_STATUS_ID(status);
   \   00000008   0xE211C03C         ANDS     R12,R1,#0x3C
    223          
    224              // Check if status is all one; in which case, it is assumed that no device
    225              // is connected
    226              if (status == 0xFF) {
   \   0000000C   0xE1B00001         MOVS     R0,R1
   \   00000010   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000014   0xE35000FF         CMP      R0,#+255
   \   00000018   0x1A000001         BNE      ??AT45_FindDevice_0
    227          
    228                  return 0;
   \   0000001C   0xE3A00000         MOV      R0,#+0
   \   00000020   0xEA000019         B        ??AT45_FindDevice_1
    229              }
    230          
    231              // Look in device array
    232              i = 0;
   \                     ??AT45_FindDevice_0:
   \   00000024   0xE3A00000         MOV      R0,#+0
   \   00000028   0xE1B03000         MOVS     R3,R0
    233              pAt45->pDesc = 0;
   \   0000002C   0xE3A00000         MOV      R0,#+0
   \   00000030   0xE582001C         STR      R0,[R2, #+28]
    234              while ((i < NUMDATAFLASH) && !(pAt45->pDesc)) {
   \                     ??AT45_FindDevice_2:
   \   00000034   0xE353000A         CMP      R3,#+10
   \   00000038   0x2A00000F         BCS      ??AT45_FindDevice_3
   \   0000003C   0xE592001C         LDR      R0,[R2, #+28]
   \   00000040   0xE3500000         CMP      R0,#+0
   \   00000044   0x1A00000C         BNE      ??AT45_FindDevice_3
    235          
    236                  if (at45Devices[i].id == id) {
   \   00000048   0x........         LDR      R0,??DataTable3_7
   \   0000004C   0xE083E083         ADD      LR,R3,R3, LSL #+1
   \   00000050   0xE090018E         ADDS     R0,R0,LR, LSL #+3
   \   00000054   0xE5D00010         LDRB     R0,[R0, #+16]
   \   00000058   0xE21CC0FF         ANDS     R12,R12,#0xFF    ;; Zero extend
   \   0000005C   0xE150000C         CMP      R0,R12
   \   00000060   0x1A000003         BNE      ??AT45_FindDevice_4
    237          
    238                      pAt45->pDesc = &(at45Devices[i]);
   \   00000064   0x........         LDR      R0,??DataTable3_7
   \   00000068   0xE083E083         ADD      LR,R3,R3, LSL #+1
   \   0000006C   0xE090018E         ADDS     R0,R0,LR, LSL #+3
   \   00000070   0xE582001C         STR      R0,[R2, #+28]
    239                  }
    240                  i++;
   \                     ??AT45_FindDevice_4:
   \   00000074   0xE2933001         ADDS     R3,R3,#+1
   \   00000078   0xEAFFFFED         B        ??AT45_FindDevice_2
    241              }
    242              configuredBinaryPage = AT45_STATUS_BINARY(status);
   \                     ??AT45_FindDevice_3:
   \   0000007C   0xE2110001         ANDS     R0,R1,#0x1
   \   00000080   0x........         LDR      LR,??DataTable3_6
   \   00000084   0xE5CE0000         STRB     R0,[LR, #+0]
    243              return pAt45->pDesc;
   \   00000088   0xE592001C         LDR      R0,[R2, #+28]
   \                     ??AT45_FindDevice_1:
   \   0000008C   0xE8BD4000         POP      {LR}
   \   00000090   0xE12FFF1E         BX       LR               ;; return
    244          }
    245          
    246          //------------------------------------------------------------------------------
    247          /// This function returns the pagesize corresponding to the device connected
    248          /// \param pAt45  Pointer to an AT45 driver instance.
    249          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    250          unsigned int  AT45_PageSize(At45 *pAt45)
    251          {
   \                     AT45_PageSize:
   \   00000000   0xE1B01000         MOVS     R1,R0
    252              unsigned int pagesize = pAt45->pDesc->pageSize;
   \   00000004   0xE591001C         LDR      R0,[R1, #+28]
   \   00000008   0xE5900008         LDR      R0,[R0, #+8]
    253              if(((pAt45->pDesc->hasBinaryPage) == 0) || !configuredBinaryPage){
   \   0000000C   0xE591201C         LDR      R2,[R1, #+28]
   \   00000010   0xE5922004         LDR      R2,[R2, #+4]
   \   00000014   0xE3520000         CMP      R2,#+0
   \   00000018   0x0A000003         BEQ      ??AT45_PageSize_0
   \   0000001C   0x........         LDR      R2,??DataTable3_6
   \   00000020   0xE5D22000         LDRB     R2,[R2, #+0]
   \   00000024   0xE3520000         CMP      R2,#+0
   \   00000028   0x1A000000         BNE      ??AT45_PageSize_1
    254                  return pagesize;
   \                     ??AT45_PageSize_0:
   \   0000002C   0xEA000000         B        ??AT45_PageSize_2
    255              }
    256              return ((pagesize >> 8) << 8);
   \                     ??AT45_PageSize_1:
   \   00000030   0xE3D000FF         BICS     R0,R0,#0xFF
   \                     ??AT45_PageSize_2:
   \   00000034   0xE12FFF1E         BX       LR               ;; return
    257          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_1:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_2:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_3:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_4:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_5:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_6:
   \   00000000   0x........         DC32     configuredBinaryPage

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable3_7:
   \   00000000   0x........         DC32     at45Devices

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x41 0x54          DC8 "AT45DB011D"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x30 0x31    
   \              0x31 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x54          DC8 "AT45DB021D"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x30 0x32    
   \              0x31 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x41 0x54          DC8 "AT45DB041D"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x30 0x34    
   \              0x31 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x41 0x54          DC8 "AT45DB081D"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x30 0x38    
   \              0x31 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x41 0x54          DC8 "AT45DB161D"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x31 0x36    
   \              0x31 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x41 0x54          DC8 "AT45DB321D"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x33 0x32    
   \              0x31 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x41 0x54          DC8 "AT45DB642D"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x36 0x34    
   \              0x32 0x44    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x41 0x54          DC8 "AT45DB1282"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x31 0x32    
   \              0x38 0x32    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x41 0x54          DC8 "AT45DB2562"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x32 0x35    
   \              0x36 0x32    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x41 0x54          DC8 "AT45DB5122"
   \              0x34 0x35    
   \              0x44 0x42    
   \              0x35 0x31    
   \              0x32 0x32    
   \              0x00         
   \   0000000B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x41 0x54          DC8 "AT45_Configure: pSpid is 0.\012\015"
   \              0x34 0x35    
   \              0x5F 0x43    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \              0x72 0x65    
   \              0x3A 0x20    
   \              0x70 0x53    
   \              0x70 0x69    
   \              0x64 0x20    
   \              0x69 0x73    
   \              0x20 0x30    
   \              0x2E 0x0A    
   \              0x0D 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x41 0x54          DC8 "AT45_Configure: pAt45 is 0.\012\015"
   \              0x34 0x35    
   \              0x5F 0x43    
   \              0x6F 0x6E    
   \              0x66 0x69    
   \              0x67 0x75    
   \              0x72 0x65    
   \              0x3A 0x20    
   \              0x70 0x41    
   \              0x74 0x34    
   \              0x35 0x20    
   \              0x69 0x73    
   \              0x20 0x30    
   \              0x2E 0x0A    
   \              0x0D 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x41 0x54          DC8 "AT45_Command: pAt45 is 0.\012\015"
   \              0x34 0x35    
   \              0x5F 0x43    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x70 0x41    
   \              0x74 0x34    
   \              0x35 0x20    
   \              0x69 0x73    
   \              0x20 0x30    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x41 0x54          DC8 41H, 54H, 34H, 35H, 5FH, 43H, 6FH, 6DH
   \              0x34 0x35    
   \              0x5F 0x43    
   \              0x6F 0x6D    
   \   00000008   0x6D 0x61          DC8 6DH, 61H, 6EH, 64H, 3AH, 20H, 44H, 65H
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x44 0x65    
   \   00000010   0x76 0x69          DC8 76H, 69H, 63H, 65H, 20H, 68H, 61H, 73H
   \              0x63 0x65    
   \              0x20 0x68    
   \              0x61 0x73    
   \   00000018   0x20 0x6E          DC8 20H, 6EH, 6FH, 20H, 64H, 65H, 73H, 63H
   \              0x6F 0x20    
   \              0x64 0x65    
   \              0x73 0x63    
   \   00000020   0x72 0x69          DC8 72H, 69H, 70H, 74H, 6FH, 72H, 2CH, 20H
   \              0x70 0x74    
   \              0x6F 0x72    
   \              0x2C 0x20    
   \   00000028   0x6F 0x6E          DC8 6FH, 6EH, 6CH, 79H, 20H, 53H, 54H, 41H
   \              0x6C 0x79    
   \              0x20 0x53    
   \              0x54 0x41    
   \   00000030   0x54 0x55          DC8 54H, 55H, 53H, 5FH, 52H, 45H, 41H, 44H
   \              0x53 0x5F    
   \              0x52 0x45    
   \              0x41 0x44    
   \   00000038   0x20 0x63          DC8 20H, 63H, 6FH, 6DH, 6DH, 61H, 6EH, 64H
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \   00000040   0x20 0x61          DC8 20H, 61H, 6CH, 6CH, 6FH, 77H, 65H, 64H
   \              0x6C 0x6C    
   \              0x6F 0x77    
   \              0x65 0x64    
   \   00000048   0x0A 0x0D          DC8 0AH, 0DH, 0
   \              0x00         
   \   0000004B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x41 0x54          DC8 "AT45_Command: No descriptor for dataflash.\012\015"
   \              0x34 0x35    
   \              0x5F 0x43    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x3A 0x20    
   \              0x4E 0x6F    
   \              0x20 0x64    
   \              0x65 0x73    
   \              0x63 0x72    
   \              0x69 0x70    
   \              0x74 0x6F    
   \              0x72 0x20    
   \              0x66 0x6F    
   \              0x72 0x20    
   \              0x64 0x61    
   \              0x74 0x61    
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   AT45_Configure
        32   -> __aeabi_memset
        32   -> printf
       4   AT45_FindDevice
       8   AT45_IsBusy
         8   -> SPID_IsBusy
       0   AT45_PageSize
      56   AT45_SendCommand
        56   -> AT45_IsBusy
        56   -> SPID_SendCommand
        56   -> printf
        56 __aeabi_uidiv
        56 __aeabi_uidivmod


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
      12  ?_0
      12  ?_1
      16  ?_10
      32  ?_11
      32  ?_12
      28  ?_13
      76  ?_14
      48  ?_15
      12  ?_2
      12  ?_3
      12  ?_4
      12  ?_5
      12  ?_6
      12  ?_7
      12  ?_8
      12  ?_9
     160  AT45_Configure
     148  AT45_FindDevice
      24  AT45_IsBusy
      56  AT45_PageSize
     432  AT45_SendCommand
     240  at45Devices
       1  configuredBinaryPage

 
   1 byte  in section .bss
 592 bytes in section .rodata
 852 bytes in section .text
 
 852 bytes of CODE  memory
 592 bytes of CONST memory
   1 byte  of DATA  memory

Errors: none
Warnings: none
