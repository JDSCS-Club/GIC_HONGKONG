###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        02/Jul/2015  09:27:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\spi-flash\at45d.c
#    Command line =  
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\spi-flash\at45d.c"
#        -D at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\"
#        --remarks --diag_suppress Pe826,Pe1375 -o
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/peripherals\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/memories\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/components\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\at45d.lst
#    Object file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\at45d.o
#
###############################################################################

F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\spi-flash\at45d.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "at45.h"
     35          #include "at45d.h"
     36          #include <board.h>
     37          #include <utility/assert.h>
     38          
     39          //------------------------------------------------------------------------------
     40          //         Local functions
     41          //------------------------------------------------------------------------------
     42          
     43          //------------------------------------------------------------------------------
     44          /// Wait for transfer to finish calling the SPI driver ISR (interrupts are
     45          /// disabled).
     46          /// \param pAt45  Pointer to an AT45 driver instance.
     47          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     48          static void AT45D_Wait(At45 *pAt45)
     49          {
   \                     AT45D_Wait:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     50              SANITY_CHECK(pAt45);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000006         BNE      ??AT45D_Wait_0
   \   00000010   0x........         LDR      R0,??DataTable6
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A02032         MOV      R2,#+50
   \   0000001C   0x........         LDR      R1,??DataTable6_1
   \   00000020   0x........         LDR      R0,??DataTable6_2
   \   00000024   0x........         BL       printf
   \                     ??AT45D_Wait_1:
   \   00000028   0xEAFFFFFE         B        ??AT45D_Wait_1
     51          
     52              // Wait for transfer to finish
     53              while (AT45_IsBusy(pAt45)) {
   \                     ??AT45D_Wait_0:
   \   0000002C   0xE1B00004         MOVS     R0,R4
   \   00000030   0x........         BL       AT45_IsBusy
   \   00000034   0xE3500000         CMP      R0,#+0
   \   00000038   0x0A000002         BEQ      ??AT45D_Wait_2
     54              
     55                  SPID_Handler(pAt45->pSpid);
   \   0000003C   0xE5940000         LDR      R0,[R4, #+0]
   \   00000040   0x........         BL       SPID_Handler
   \   00000044   0xEAFFFFF8         B        ??AT45D_Wait_0
     56              }
     57          }
   \                     ??AT45D_Wait_2:
   \   00000048   0xE8BD4010         POP      {R4,LR}
   \   0000004C   0xE12FFF1E         BX       LR               ;; return
     58          
     59          
     60          //------------------------------------------------------------------------------
     61          //         Global functions
     62          //------------------------------------------------------------------------------
     63          
     64          //------------------------------------------------------------------------------
     65          /// Waits for the At45 to be ready to accept new commands.
     66          /// \param pAt45  Pointer to a At45 driver instance.
     67          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     68          void AT45D_WaitReady(At45 *pAt45) 
     69          {
   \                     AT45D_WaitReady:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     70              unsigned char ready = 0;
   \   00000008   0xE3A05000         MOV      R5,#+0
     71          
     72              SANITY_CHECK(pAt45);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT45D_WaitReady_0
   \   00000014   0x........         LDR      R0,??DataTable6
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A02048         MOV      R2,#+72
   \   00000020   0x........         LDR      R1,??DataTable6_1
   \   00000024   0x........         LDR      R0,??DataTable6_2
   \   00000028   0x........         BL       printf
   \                     ??AT45D_WaitReady_1:
   \   0000002C   0xEAFFFFFE         B        ??AT45D_WaitReady_1
     73          
     74              // Poll device until it is ready
     75              while (!ready) {
   \                     ??AT45D_WaitReady_0:
   \   00000030   0xE1B00005         MOVS     R0,R5
   \   00000034   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000038   0xE3500000         CMP      R0,#+0
   \   0000003C   0x1A000004         BNE      ??AT45D_WaitReady_2
     76          
     77                  ready = AT45_STATUS_READY(AT45D_GetStatus(pAt45));
   \   00000040   0xE1B00004         MOVS     R0,R4
   \   00000044   0x........         BL       AT45D_GetStatus
   \   00000048   0xE2100080         ANDS     R0,R0,#0x80
   \   0000004C   0xE1B05000         MOVS     R5,R0
   \   00000050   0xEAFFFFF6         B        ??AT45D_WaitReady_0
     78              }
     79          }
   \                     ??AT45D_WaitReady_2:
   \   00000054   0xE8BD4031         POP      {R0,R4,R5,LR}
   \   00000058   0xE12FFF1E         BX       LR               ;; return
     80          
     81          //------------------------------------------------------------------------------
     82          /// Retrieves and returns the At45 current status, or 0 if an error
     83          /// happened.
     84          /// \param pAt45  Pointer to a At45 driver instance.
     85          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     86          unsigned char AT45D_GetStatus(At45 *pAt45)
     87          {
   \                     AT45D_GetStatus:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
     88              unsigned char error;
     89              unsigned char status;
     90          
     91              SANITY_CHECK(pAt45);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT45D_GetStatus_0
   \   00000014   0x........         LDR      R0,??DataTable6
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A0205B         MOV      R2,#+91
   \   00000020   0x........         LDR      R1,??DataTable6_1
   \   00000024   0x........         LDR      R0,??DataTable6_2
   \   00000028   0x........         BL       printf
   \                     ??AT45D_GetStatus_1:
   \   0000002C   0xEAFFFFFE         B        ??AT45D_GetStatus_1
     92          
     93              // Issue a status register read command
     94              error = AT45_SendCommand(pAt45, AT45_STATUS_READ, 1, &status, 1, 0, 0, 0);
   \                     ??AT45D_GetStatus_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xE58D000C         STR      R0,[SP, #+12]
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0004         STR      R0,[SP, #+4]
   \   00000048   0xE3A00001         MOV      R0,#+1
   \   0000004C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000050   0xE28D3010         ADD      R3,SP,#+16
   \   00000054   0xE3A02001         MOV      R2,#+1
   \   00000058   0xE3A010D7         MOV      R1,#+215
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       AT45_SendCommand
   \   00000064   0xE1B05000         MOVS     R5,R0
     95              ASSERT(!error, "-F- AT45_GetStatus: Failed to issue command.\n\r");
   \   00000068   0xE1B00005         MOVS     R0,R5
   \   0000006C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000070   0xE3500000         CMP      R0,#+0
   \   00000074   0x0A000004         BEQ      ??AT45D_GetStatus_2
   \   00000078   0x........         LDR      R0,??DataTable6
   \   0000007C   0x........         BL       printf
   \   00000080   0x........         LDR      R0,??DataTable6_3
   \   00000084   0x........         BL       printf
   \                     ??AT45D_GetStatus_3:
   \   00000088   0xEAFFFFFE         B        ??AT45D_GetStatus_3
     96          
     97              // Wait for command to terminate
     98              while (AT45_IsBusy(pAt45)) {
   \                     ??AT45D_GetStatus_2:
   \   0000008C   0xE1B00004         MOVS     R0,R4
   \   00000090   0x........         BL       AT45_IsBusy
   \   00000094   0xE3500000         CMP      R0,#+0
   \   00000098   0x0A000002         BEQ      ??AT45D_GetStatus_4
     99              
    100                  AT45D_Wait(pAt45);
   \   0000009C   0xE1B00004         MOVS     R0,R4
   \   000000A0   0x........         BL       AT45D_Wait
   \   000000A4   0xEAFFFFF8         B        ??AT45D_GetStatus_2
    101              }
    102          
    103              return status;
   \                     ??AT45D_GetStatus_4:
   \   000000A8   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   000000AC   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000B0   0xE8BD4030         POP      {R4,R5,LR}
   \   000000B4   0xE12FFF1E         BX       LR               ;; return
    104          }
    105          
    106          //------------------------------------------------------------------------------
    107          /// Reads data from the At45 inside the provided buffer. Since a continuous
    108          /// read command is used, there is no restriction on the buffer size and read
    109          /// address.
    110          /// \param pAt45  Pointer to a At45 driver instance.
    111          /// \param pBuffer  Data buffer.
    112          /// \param size  Number of bytes to read.
    113          /// \param address  Address at which data shall be read.
    114          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    115          void AT45D_Read(
    116              At45 *pAt45,
    117              unsigned char *pBuffer,
    118              unsigned int size,
    119              unsigned int address) 
    120          {
   \                     AT45D_Read:
   \   00000000   0xE92D41FF         PUSH     {R0-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    121              unsigned char error;
    122          
    123              SANITY_CHECK(pAt45);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000006         BNE      ??AT45D_Read_0
   \   0000001C   0x........         LDR      R0,??DataTable6
   \   00000020   0x........         BL       printf
   \   00000024   0xE3A0207B         MOV      R2,#+123
   \   00000028   0x........         LDR      R1,??DataTable6_1
   \   0000002C   0x........         LDR      R0,??DataTable6_2
   \   00000030   0x........         BL       printf
   \                     ??AT45D_Read_1:
   \   00000034   0xEAFFFFFE         B        ??AT45D_Read_1
    124              SANITY_CHECK(pBuffer);
   \                     ??AT45D_Read_0:
   \   00000038   0xE3550000         CMP      R5,#+0
   \   0000003C   0x1A000006         BNE      ??AT45D_Read_2
   \   00000040   0x........         LDR      R0,??DataTable6
   \   00000044   0x........         BL       printf
   \   00000048   0xE3A0207C         MOV      R2,#+124
   \   0000004C   0x........         LDR      R1,??DataTable6_1
   \   00000050   0x........         LDR      R0,??DataTable6_2
   \   00000054   0x........         BL       printf
   \                     ??AT45D_Read_3:
   \   00000058   0xEAFFFFFE         B        ??AT45D_Read_3
    125          
    126              // Issue a continuous read array command
    127              error = AT45_SendCommand(pAt45, AT45_CONTINUOUS_READ_LEG, 8, pBuffer, size, address, 0, 0);
   \                     ??AT45D_Read_2:
   \   0000005C   0xE3A00000         MOV      R0,#+0
   \   00000060   0xE58D000C         STR      R0,[SP, #+12]
   \   00000064   0xE3A00000         MOV      R0,#+0
   \   00000068   0xE58D0008         STR      R0,[SP, #+8]
   \   0000006C   0xE58D7004         STR      R7,[SP, #+4]
   \   00000070   0xE58D6000         STR      R6,[SP, #+0]
   \   00000074   0xE1B03005         MOVS     R3,R5
   \   00000078   0xE3A02008         MOV      R2,#+8
   \   0000007C   0xE3A010E8         MOV      R1,#+232
   \   00000080   0xE1B00004         MOVS     R0,R4
   \   00000084   0x........         BL       AT45_SendCommand
   \   00000088   0xE1B08000         MOVS     R8,R0
    128              ASSERT(!error, "-F- AT45_Read: Failed to issue command\n\r");
   \   0000008C   0xE1B00008         MOVS     R0,R8
   \   00000090   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000094   0xE3500000         CMP      R0,#+0
   \   00000098   0x0A000004         BEQ      ??AT45D_Read_4
   \   0000009C   0x........         LDR      R0,??DataTable6
   \   000000A0   0x........         BL       printf
   \   000000A4   0x........         LDR      R0,??DataTable6_4
   \   000000A8   0x........         BL       printf
   \                     ??AT45D_Read_5:
   \   000000AC   0xEAFFFFFE         B        ??AT45D_Read_5
    129          
    130              // Wait for the read command to execute
    131              while (AT45_IsBusy(pAt45)) {
   \                     ??AT45D_Read_4:
   \   000000B0   0xE1B00004         MOVS     R0,R4
   \   000000B4   0x........         BL       AT45_IsBusy
   \   000000B8   0xE3500000         CMP      R0,#+0
   \   000000BC   0x0A000002         BEQ      ??AT45D_Read_6
    132              
    133                  AT45D_Wait(pAt45);
   \   000000C0   0xE1B00004         MOVS     R0,R4
   \   000000C4   0x........         BL       AT45D_Wait
   \   000000C8   0xEAFFFFF8         B        ??AT45D_Read_4
    134              }
    135          }
   \                     ??AT45D_Read_6:
   \   000000CC   0xE8BD41FF         POP      {R0-R8,LR}
   \   000000D0   0xE12FFF1E         BX       LR               ;; return
    136          
    137          //------------------------------------------------------------------------------
    138          /// Writes data on the At45 at the specified address. Only one page of
    139          /// data is written that way; if the address is not at the beginning of the
    140          /// page, the data is written starting from this address and wraps around to
    141          /// the beginning of the page.
    142          /// \param pAt45  Pointer to a At45 driver instance.
    143          /// \param pBuffer  Buffer containing the data to write.
    144          /// \param size  Number of bytes to write.
    145          /// \param address  Destination address on the At45.
    146          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    147          void AT45D_Write(
    148              At45 *pAt45,
    149              unsigned char *pBuffer,
    150              unsigned int size,
    151              unsigned int address) 
    152          {
   \                     AT45D_Write:
   \   00000000   0xE92D41FF         PUSH     {R0-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    153              unsigned char error;
    154          
    155              SANITY_CHECK(pAt45);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000006         BNE      ??AT45D_Write_0
   \   0000001C   0x........         LDR      R0,??DataTable6
   \   00000020   0x........         BL       printf
   \   00000024   0xE3A0209B         MOV      R2,#+155
   \   00000028   0x........         LDR      R1,??DataTable6_1
   \   0000002C   0x........         LDR      R0,??DataTable6_2
   \   00000030   0x........         BL       printf
   \                     ??AT45D_Write_1:
   \   00000034   0xEAFFFFFE         B        ??AT45D_Write_1
    156              SANITY_CHECK(pBuffer);
   \                     ??AT45D_Write_0:
   \   00000038   0xE3550000         CMP      R5,#+0
   \   0000003C   0x1A000006         BNE      ??AT45D_Write_2
   \   00000040   0x........         LDR      R0,??DataTable6
   \   00000044   0x........         BL       printf
   \   00000048   0xE3A0209C         MOV      R2,#+156
   \   0000004C   0x........         LDR      R1,??DataTable6_1
   \   00000050   0x........         LDR      R0,??DataTable6_2
   \   00000054   0x........         BL       printf
   \                     ??AT45D_Write_3:
   \   00000058   0xEAFFFFFE         B        ??AT45D_Write_3
    157              SANITY_CHECK(size <= pAt45->pDesc->pageSize);
   \                     ??AT45D_Write_2:
   \   0000005C   0xE594001C         LDR      R0,[R4, #+28]
   \   00000060   0xE5900008         LDR      R0,[R0, #+8]
   \   00000064   0xE1500006         CMP      R0,R6
   \   00000068   0x2A000006         BCS      ??AT45D_Write_4
   \   0000006C   0x........         LDR      R0,??DataTable6
   \   00000070   0x........         BL       printf
   \   00000074   0xE3A0209D         MOV      R2,#+157
   \   00000078   0x........         LDR      R1,??DataTable6_1
   \   0000007C   0x........         LDR      R0,??DataTable6_2
   \   00000080   0x........         BL       printf
   \                     ??AT45D_Write_5:
   \   00000084   0xEAFFFFFE         B        ??AT45D_Write_5
    158          
    159              // Issue a page write through buffer 1 command
    160              error = AT45_SendCommand(pAt45, AT45_PAGE_WRITE_BUF1, 4, pBuffer, size, address, 0, 0);
   \                     ??AT45D_Write_4:
   \   00000088   0xE3A00000         MOV      R0,#+0
   \   0000008C   0xE58D000C         STR      R0,[SP, #+12]
   \   00000090   0xE3A00000         MOV      R0,#+0
   \   00000094   0xE58D0008         STR      R0,[SP, #+8]
   \   00000098   0xE58D7004         STR      R7,[SP, #+4]
   \   0000009C   0xE58D6000         STR      R6,[SP, #+0]
   \   000000A0   0xE1B03005         MOVS     R3,R5
   \   000000A4   0xE3A02004         MOV      R2,#+4
   \   000000A8   0xE3A01082         MOV      R1,#+130
   \   000000AC   0xE1B00004         MOVS     R0,R4
   \   000000B0   0x........         BL       AT45_SendCommand
   \   000000B4   0xE1B08000         MOVS     R8,R0
    161              ASSERT(!error, "-F- AT45_Write: Could not issue command.\n\r");
   \   000000B8   0xE1B00008         MOVS     R0,R8
   \   000000BC   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000C0   0xE3500000         CMP      R0,#+0
   \   000000C4   0x0A000004         BEQ      ??AT45D_Write_6
   \   000000C8   0x........         LDR      R0,??DataTable6
   \   000000CC   0x........         BL       printf
   \   000000D0   0x........         LDR      R0,??DataTable6_5
   \   000000D4   0x........         BL       printf
   \                     ??AT45D_Write_7:
   \   000000D8   0xEAFFFFFE         B        ??AT45D_Write_7
    162          
    163              // Wait until the command is sent
    164              while (AT45_IsBusy(pAt45)) {
   \                     ??AT45D_Write_6:
   \   000000DC   0xE1B00004         MOVS     R0,R4
   \   000000E0   0x........         BL       AT45_IsBusy
   \   000000E4   0xE3500000         CMP      R0,#+0
   \   000000E8   0x0A000002         BEQ      ??AT45D_Write_8
    165              
    166                  AT45D_Wait(pAt45);
   \   000000EC   0xE1B00004         MOVS     R0,R4
   \   000000F0   0x........         BL       AT45D_Wait
   \   000000F4   0xEAFFFFF8         B        ??AT45D_Write_6
    167              }
    168          
    169              // Wait until the At45 becomes ready again
    170              AT45D_WaitReady(pAt45);
   \                     ??AT45D_Write_8:
   \   000000F8   0xE1B00004         MOVS     R0,R4
   \   000000FC   0x........         BL       AT45D_WaitReady
    171          }
   \   00000100   0xE8BD41FF         POP      {R0-R8,LR}
   \   00000104   0xE12FFF1E         BX       LR               ;; return
    172          
    173          //------------------------------------------------------------------------------
    174          /// Erases a page of data at the given address in the At45.
    175          /// \param pAt45  Pointer to a At45 driver instance.
    176          /// \param address  Address of page to erase.
    177          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    178          void AT45D_Erase(At45 *pAt45, unsigned int address) 
    179          {
   \                     AT45D_Erase:
   \   00000000   0xE92D407F         PUSH     {R0-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    180              unsigned char error;
    181          
    182              SANITY_CHECK(pAt45);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT45D_Erase_0
   \   00000014   0x........         LDR      R0,??DataTable6
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A020B6         MOV      R2,#+182
   \   00000020   0x........         LDR      R1,??DataTable6_1
   \   00000024   0x........         LDR      R0,??DataTable6_2
   \   00000028   0x........         BL       printf
   \                     ??AT45D_Erase_1:
   \   0000002C   0xEAFFFFFE         B        ??AT45D_Erase_1
    183          
    184              // Issue a page erase command.
    185              error = AT45_SendCommand(pAt45, AT45_PAGE_ERASE, 4, 0, 0, address, 0, 0);
   \                     ??AT45D_Erase_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xE58D000C         STR      R0,[SP, #+12]
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000040   0xE58D5004         STR      R5,[SP, #+4]
   \   00000044   0xE3A00000         MOV      R0,#+0
   \   00000048   0xE58D0000         STR      R0,[SP, #+0]
   \   0000004C   0xE3A03000         MOV      R3,#+0
   \   00000050   0xE3A02004         MOV      R2,#+4
   \   00000054   0xE3A01081         MOV      R1,#+129
   \   00000058   0xE1B00004         MOVS     R0,R4
   \   0000005C   0x........         BL       AT45_SendCommand
   \   00000060   0xE1B06000         MOVS     R6,R0
    186              ASSERT(!error, "-F- AT45_Erase: Could not issue command.\n\r");
   \   00000064   0xE1B00006         MOVS     R0,R6
   \   00000068   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000006C   0xE3500000         CMP      R0,#+0
   \   00000070   0x0A000004         BEQ      ??AT45D_Erase_2
   \   00000074   0x........         LDR      R0,??DataTable6
   \   00000078   0x........         BL       printf
   \   0000007C   0x........         LDR      R0,??DataTable6_6
   \   00000080   0x........         BL       printf
   \                     ??AT45D_Erase_3:
   \   00000084   0xEAFFFFFE         B        ??AT45D_Erase_3
    187          
    188              // Wait for end of transfer
    189              while (AT45_IsBusy(pAt45)) {
   \                     ??AT45D_Erase_2:
   \   00000088   0xE1B00004         MOVS     R0,R4
   \   0000008C   0x........         BL       AT45_IsBusy
   \   00000090   0xE3500000         CMP      R0,#+0
   \   00000094   0x0A000002         BEQ      ??AT45D_Erase_4
    190              
    191                  AT45D_Wait(pAt45);
   \   00000098   0xE1B00004         MOVS     R0,R4
   \   0000009C   0x........         BL       AT45D_Wait
   \   000000A0   0xEAFFFFF8         B        ??AT45D_Erase_2
    192              }
    193          
    194              // Poll until the At45 has completed the erase operation
    195              AT45D_WaitReady(pAt45);
   \                     ??AT45D_Erase_4:
   \   000000A4   0xE1B00004         MOVS     R0,R4
   \   000000A8   0x........         BL       AT45D_WaitReady
    196          }
   \   000000AC   0xE8BD407F         POP      {R0-R6,LR}
   \   000000B0   0xE12FFF1E         BX       LR               ;; return
    197          
    198          //------------------------------------------------------------------------------
    199          /// Configure power-of-2 binary page size in the At45.
    200          /// \param pAt45  Pointer to a At45 driver instance.
    201          //------------------------------------------------------------------------------
    202          

   \                                 In section .text, align 4, keep-with-next
    203          void AT45D_BinaryPage(At45 *pAt45) 
    204          {
   \                     AT45D_BinaryPage:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
    205              unsigned char error;
    206              unsigned char opcode[3]= {AT45_BINARY_PAGE};
   \   0000000C   0xE28D0010         ADD      R0,SP,#+16
   \   00000010   0x........         LDR      R1,??DataTable6_7
   \   00000014   0xE5912000         LDR      R2,[R1, #0]
   \   00000018   0xE5802000         STR      R2,[R0, #+0]
    207              SANITY_CHECK(pAt45);
   \   0000001C   0xE3540000         CMP      R4,#+0
   \   00000020   0x1A000006         BNE      ??AT45D_BinaryPage_0
   \   00000024   0x........         LDR      R0,??DataTable6
   \   00000028   0x........         BL       printf
   \   0000002C   0xE3A020CF         MOV      R2,#+207
   \   00000030   0x........         LDR      R1,??DataTable6_1
   \   00000034   0x........         LDR      R0,??DataTable6_2
   \   00000038   0x........         BL       printf
   \                     ??AT45D_BinaryPage_1:
   \   0000003C   0xEAFFFFFE         B        ??AT45D_BinaryPage_1
    208          
    209              // Issue a binary page command.
    210          
    211              error = AT45_SendCommand(pAt45, AT45_BINARY_PAGE_FIRST_OPCODE, 1, opcode, 3, 0, 0, 0);
   \                     ??AT45D_BinaryPage_0:
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D000C         STR      R0,[SP, #+12]
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000050   0xE3A00000         MOV      R0,#+0
   \   00000054   0xE58D0004         STR      R0,[SP, #+4]
   \   00000058   0xE3A00003         MOV      R0,#+3
   \   0000005C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000060   0xE28D3010         ADD      R3,SP,#+16
   \   00000064   0xE3A02001         MOV      R2,#+1
   \   00000068   0xE3A0103D         MOV      R1,#+61
   \   0000006C   0xE1B00004         MOVS     R0,R4
   \   00000070   0x........         BL       AT45_SendCommand
   \   00000074   0xE1B05000         MOVS     R5,R0
    212             
    213              ASSERT(!error, "-F- AT45_Erase: Could not issue command.\n\r");
   \   00000078   0xE1B00005         MOVS     R0,R5
   \   0000007C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000080   0xE3500000         CMP      R0,#+0
   \   00000084   0x0A000004         BEQ      ??AT45D_BinaryPage_2
   \   00000088   0x........         LDR      R0,??DataTable6
   \   0000008C   0x........         BL       printf
   \   00000090   0x........         LDR      R0,??DataTable6_6
   \   00000094   0x........         BL       printf
   \                     ??AT45D_BinaryPage_3:
   \   00000098   0xEAFFFFFE         B        ??AT45D_BinaryPage_3
    214          
    215              // Wait for end of transfer
    216              while (AT45_IsBusy(pAt45)) {
   \                     ??AT45D_BinaryPage_2:
   \   0000009C   0xE1B00004         MOVS     R0,R4
   \   000000A0   0x........         BL       AT45_IsBusy
   \   000000A4   0xE3500000         CMP      R0,#+0
   \   000000A8   0x0A000002         BEQ      ??AT45D_BinaryPage_4
    217              
    218                  AT45D_Wait(pAt45);
   \   000000AC   0xE1B00004         MOVS     R0,R4
   \   000000B0   0x........         BL       AT45D_Wait
   \   000000B4   0xEAFFFFF8         B        ??AT45D_BinaryPage_2
    219              }
    220          
    221              // Wait until the At45 becomes ready again
    222              AT45D_WaitReady(pAt45);
   \                     ??AT45D_BinaryPage_4:
   \   000000B8   0xE1B00004         MOVS     R0,R4
   \   000000BC   0x........         BL       AT45D_WaitReady
    223          }
   \   000000C0   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000C4   0xE8BD4030         POP      {R4,R5,LR}
   \   000000C8   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x53 0x61          DC8 "Sanity check failed at %s:%d\012\015"
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x20 0x63    
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x73 0x3A    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 44H, 72H, 6FH, 70H, 62H
   \              0x5C 0x44    
   \              0x72 0x6F    
   \              0x70 0x62    
   \   00000008   0x6F 0x78          DC8 6FH, 78H, 5CH, 0C8H, 0B8H, 0BBH, 0E7H, 5CH
   \              0x5C 0xC8    
   \              0xB8 0xBB    
   \              0xE7 0x5C    
   \   00000010   0x4A 0x44          DC8 4AH, 44H, 53H, 5FH, 50H, 52H, 4FH, 5CH
   \              0x53 0x5F    
   \              0x50 0x52    
   \              0x4F 0x5C    
   \   00000018   0xB1 0xB9          DC8 0B1H, 0B9H, 0B3H, 0BBH, 20H, 0C7H, 0C1H, 0B7H
   \              0xB3 0xBB    
   \              0x20 0xC7    
   \              0xC1 0xB7    
   \   00000020   0xCE 0xC1          DC8 0CEH, 0C1H, 0A7H, 0C6H, 0AEH, 5CH, 0B4H, 0EBH
   \              0xA7 0xC6    
   \              0xAE 0x5C    
   \              0xB4 0xEB    
   \   00000028   0xB1 0xB8          DC8 0B1H, 0B8H, 20H, 0B8H, 0F0H, 0B3H, 0EBH, 0B7H
   \              0x20 0xB8    
   \              0xF0 0xB3    
   \              0xEB 0xB7    
   \   00000030   0xB9 0xC0          DC8 0B9H, 0C0H, 0CFH, 5CH, 0C7H, 0C1H, 0B7H, 0CEH
   \              0xCF 0x5C    
   \              0xC7 0xC1    
   \              0xB7 0xCE    
   \   00000038   0xB1 0xD7          DC8 0B1H, 0D7H, 0B7H, 0A5H, 5CH, 41H, 52H, 4DH
   \              0xB7 0xA5    
   \              0x5C 0x41    
   \              0x52 0x4D    
   \   00000040   0x5F 0x41          DC8 5FH, 41H, 54H, 39H, 31H, 73H, 61H, 6DH
   \              0x54 0x39    
   \              0x31 0x73    
   \              0x61 0x6D    
   \   00000048   0x37 0x73          DC8 37H, 73H, 65H, 35H, 31H, 32H, 5FH, 44H
   \              0x65 0x35    
   \              0x31 0x32    
   \              0x5F 0x44    
   \   00000050   0x61 0x67          DC8 61H, 67H, 75H, 5FH, 4CH, 45H, 44H, 28H
   \              0x75 0x5F    
   \              0x4C 0x45    
   \              0x44 0x28    
   \   00000058   0x46 0x44          DC8 46H, 44H, 49H, 29H, 5CH, 61H, 74H, 39H
   \              0x49 0x29    
   \              0x5C 0x61    
   \              0x74 0x39    
   \   00000060   0x31 0x6C          DC8 31H, 6CH, 69H, 62H, 5CH, 6DH, 65H, 6DH
   \              0x69 0x62    
   \              0x5C 0x6D    
   \              0x65 0x6D    
   \   00000068   0x6F 0x72          DC8 6FH, 72H, 69H, 65H, 73H, 5CH, 73H, 70H
   \              0x69 0x65    
   \              0x73 0x5C    
   \              0x73 0x70    
   \   00000070   0x69 0x2D          DC8 69H, 2DH, 66H, 6CH, 61H, 73H, 68H, 5CH
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x5C    
   \   00000078   0x61 0x74          DC8 61H, 74H, 34H, 35H, 64H, 2EH, 63H, 0
   \              0x34 0x35    
   \              0x64 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x2D 0x46          DC8 "-F- AT45_GetStatus: Failed to issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x34 0x35    
   \              0x5F 0x47    
   \              0x65 0x74    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x2D 0x46          DC8 "-F- AT45_Read: Failed to issue command\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x34 0x35    
   \              0x5F 0x52    
   \              0x65 0x61    
   \              0x64 0x3A    
   \              0x20 0x46    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x74 0x6F    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000029   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x2D 0x46          DC8 "-F- AT45_Write: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x34 0x35    
   \              0x5F 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x3A 0x20    
   \              0x43 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x2D 0x46          DC8 "-F- AT45_Erase: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x34 0x35    
   \              0x5F 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x3A 0x20    
   \              0x43 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002B   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x2A 0x80          DC8 42, 128, 166, 0
   \              0xA6 0x00    

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   AT45D_BinaryPage
        32   -> AT45D_Wait
        32   -> AT45D_WaitReady
        32   -> AT45_IsBusy
        32   -> AT45_SendCommand
        32   -> printf
      32   AT45D_Erase
        32   -> AT45D_Wait
        32   -> AT45D_WaitReady
        32   -> AT45_IsBusy
        32   -> AT45_SendCommand
        32   -> printf
      32   AT45D_GetStatus
        32   -> AT45D_Wait
        32   -> AT45_IsBusy
        32   -> AT45_SendCommand
        32   -> printf
      40   AT45D_Read
        40   -> AT45D_Wait
        40   -> AT45_IsBusy
        40   -> AT45_SendCommand
        40   -> printf
       8   AT45D_Wait
         8   -> AT45_IsBusy
         8   -> SPID_Handler
         8   -> printf
      16   AT45D_WaitReady
        16   -> AT45D_GetStatus
        16   -> printf
      40   AT45D_Write
        40   -> AT45D_Wait
        40   -> AT45D_WaitReady
        40   -> AT45_IsBusy
        40   -> AT45_SendCommand
        40   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
      16  ?_0
      32  ?_1
     128  ?_2
      48  ?_3
      44  ?_4
      44  ?_5
      44  ?_6
       4  ?_7
     204  AT45D_BinaryPage
     180  AT45D_Erase
     184  AT45D_GetStatus
     212  AT45D_Read
      80  AT45D_Wait
      92  AT45D_WaitReady
     264  AT45D_Write

 
   360 bytes in section .rodata
 1 248 bytes in section .text
 
 1 248 bytes of CODE  memory
   360 bytes of CONST memory

Errors: none
Warnings: none
