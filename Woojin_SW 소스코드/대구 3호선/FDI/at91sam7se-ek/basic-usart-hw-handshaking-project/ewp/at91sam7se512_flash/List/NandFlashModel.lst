###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        02/Jul/2015  09:27:29
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\nandflash\NandFlashModel.c
#    Command line =  
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\nandflash\NandFlashModel.c"
#        -D at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\"
#        --remarks --diag_suppress Pe826,Pe1375 -o
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/peripherals\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/memories\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/components\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\NandFlashModel.lst
#    Object file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\NandFlashModel.o
#
###############################################################################

F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\nandflash\NandFlashModel.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "NandFlashModel.h"
     35          #include "NandCommon.h"
     36          #if defined(CHIP_NAND_CTRL)
     37          #include <hsmc4/hsmc4.h>
     38          #endif
     39          #include <utility/trace.h>
     40          
     41          #include <string.h>
     42          
     43          //------------------------------------------------------------------------------
     44          //         Internal definitions
     45          //------------------------------------------------------------------------------
     46          //------------------------------------------------------------------------------
     47          /// Get the power of input, given a certain result, i.e. input^(power) = result.
     48          /// returns the value of "power" if succesfully find the power.
     49          /// \param result  a certain output we want to calculate.
     50          /// \param input  the input of the power.
     51          //------------------------------------------------------------------------------
     52          #if defined(OP_BOOTSTRAP_on)
     53          unsigned int CALPOW(unsigned int result, unsigned int input)
     54          {
     55          	unsigned int i=0;
     56          
     57          	while(i<32)
     58          	{
     59          		if(result == (input << i))
     60          			return i;
     61          		i++;
     62          	}
     63          
     64          	return 0;
     65          }
     66          #endif
     67          
     68          //------------------------------------------------------------------------------
     69          /// Get the interger part of input, given a certain result, i.e.  return = result / input.
     70          /// returns the value of interger part of the result/input.
     71          /// \param result  a certain output we want to calculate.
     72          /// \param input  the input of the division.
     73          //------------------------------------------------------------------------------
     74          #if defined(OP_BOOTSTRAP_on)
     75          unsigned int CALINT(unsigned int result, unsigned int input)
     76          {
     77          	unsigned int i=0;
     78          	unsigned int tmpInput=0;
     79                  
     80              while(1)
     81              {
     82              	tmpInput +=input;
     83            		i++;
     84          	    if(tmpInput == result)
     85          	      return i;
     86          	    else if (tmpInput > result)
     87          	      return (i-1);
     88              }
     89          
     90          }
     91          #endif
     92          
     93          
     94          //------------------------------------------------------------------------------
     95          //         Exported functions
     96          //------------------------------------------------------------------------------
     97          
     98          //------------------------------------------------------------------------------
     99          /// Looks for a NandFlashModel corresponding to the given ID inside a list of
    100          /// model. If found, the model variable is filled with the correct values.
    101          /// This function returns 0 if a matching model has been found; otherwise it
    102          /// returns NandCommon_ERROR_UNKNOWNMODEL.
    103          /// \param modelList  List of NandFlashModel instances.
    104          /// \param size  Number of models in list.
    105          /// \param chipId  Identifier returned by the Nand(id1|(id2<<8)|(id3<<16)|(id4<<24)).
    106          /// \param model  NandFlashModel instance to update with the model parameters.
    107          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    108          unsigned char NandFlashModel_Find(
    109              const struct NandFlashModel *modelList,
    110              unsigned int size,
    111              unsigned int chipId,
    112              struct NandFlashModel *model)
    113          {
   \                     NandFlashModel_Find:
   \   00000000   0xE92D4FF2         PUSH     {R1,R4-R11,LR}
   \   00000004   0xE24DD008         SUB      SP,SP,#+8
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05002         MOVS     R5,R2
   \   00000010   0xE1B06003         MOVS     R6,R3
    114              unsigned char found = 0, id2, id4;
   \   00000014   0xE3A08000         MOV      R8,#+0
    115              unsigned int i;
    116              #if defined(CHIP_NAND_CTRL)
    117              unsigned char pageSize = 0;
    118              #endif
    119              id2 = (unsigned char)(chipId>>8);
   \   00000018   0xE1B01425         LSRS     R1,R5,#+8
   \   0000001C   0xE5CD1000         STRB     R1,[SP, #+0]
    120              id4 = (unsigned char)(chipId>>24);
   \   00000020   0xE1B00C25         LSRS     R0,R5,#+24
   \   00000024   0xE1B07000         MOVS     R7,R0
    121          
    122              TRACE_INFO("Nandflash ID is 0x%08X\n\r", chipId);
   \   00000028   0xE1B01005         MOVS     R1,R5
   \   0000002C   0x........         LDR      R0,??DataTable0
   \   00000030   0x........         BL       printf
    123          
    124              for(i=0; i<size; i++) {
   \   00000034   0xE3A00000         MOV      R0,#+0
   \   00000038   0xE1B09000         MOVS     R9,R0
   \                     ??NandFlashModel_Find_1:
   \   0000003C   0xE59D0008         LDR      R0,[SP, #+8]
   \   00000040   0xE1590000         CMP      R9,R0
   \   00000044   0x2A000044         BCS      ??NandFlashModel_Find_2
    125                  if(modelList[i].deviceId == id2) {
   \   00000048   0xE0890089         ADD      R0,R9,R9, LSL #+1
   \   0000004C   0xE7D40100         LDRB     R0,[R4, +R0, LSL #+2]
   \   00000050   0xE5DD1000         LDRB     R1,[SP, #+0]
   \   00000054   0xE1500001         CMP      R0,R1
   \   00000058   0x1A00003D         BNE      ??NandFlashModel_Find_3
    126                      found = 1;
   \   0000005C   0xE3A00001         MOV      R0,#+1
   \   00000060   0xE1B08000         MOVS     R8,R0
    127          
    128                      if(model) {
   \   00000064   0xE3560000         CMP      R6,#+0
   \   00000068   0x0A000038         BEQ      ??NandFlashModel_Find_4
    129          
    130                          memcpy(model, &modelList[i], sizeof(struct NandFlashModel));
   \   0000006C   0xE3A0A00C         MOV      R10,#+12
   \   00000070   0xE0890089         ADD      R0,R9,R9, LSL #+1
   \   00000074   0xE094B100         ADDS     R11,R4,R0, LSL #+2
   \   00000078   0xE1B0200A         MOVS     R2,R10
   \   0000007C   0xE1B0100B         MOVS     R1,R11
   \   00000080   0xE1B00006         MOVS     R0,R6
   \   00000084   0x........         BL       __aeabi_memcpy
    131          
    132                          if(model->blockSizeInKBytes == 0 || model->pageSizeInBytes == 0) {
   \   00000088   0xE1D600B6         LDRH     R0,[R6, #+6]
   \   0000008C   0xE3500000         CMP      R0,#+0
   \   00000090   0x0A000002         BEQ      ??NandFlashModel_Find_5
   \   00000094   0xE1D600B2         LDRH     R0,[R6, #+2]
   \   00000098   0xE3500000         CMP      R0,#+0
   \   0000009C   0x1A00002B         BNE      ??NandFlashModel_Find_4
    133                              TRACE_DEBUG("Fetch from ID4(0x%.2x):\r\n", id4);
    134                              /// Fetch from the extended ID4
    135                              /// ID4 D5  D4 BlockSize || D1  D0  PageSize
    136                              ///     0   0   64K      || 0   0   1K
    137                              ///     0   1   128K     || 0   1   2K
    138                              ///     1   0   256K     || 1   0   4K
    139                              ///     1   1   512K     || 1   1   8k
    140                              #if !defined(OP_BOOTSTRAP_on)
    141                              switch(id4 & 0x03) {
   \                     ??NandFlashModel_Find_5:
   \   000000A0   0xE1B00007         MOVS     R0,R7
   \   000000A4   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000A8   0xE2100003         ANDS     R0,R0,#0x3
   \   000000AC   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000B0   0xE3500003         CMP      R0,#+3
   \   000000B4   0x8A00000D         BHI      ??NandFlashModel_Find_6
   \   000000B8   0xE7DF1000         LDRB     R1,[PC, R0]
   \   000000BC   0xE08FF101         ADD      PC,PC,R1, LSL #+2
   \                     ??NandFlashModel_Find_0:
   \   000000C0   0x00 0x03          DC8      0x0,0x3,0x6,0x9
   \              0x06 0x09    
    142                                  case 0x00: model->pageSizeInBytes = 1024; break;
   \                     ??NandFlashModel_Find_7:
   \   000000C4   0xE3A00E40         MOV      R0,#+1024
   \   000000C8   0xE1C600B2         STRH     R0,[R6, #+2]
   \   000000CC   0xEA000007         B        ??NandFlashModel_Find_6
    143                                  case 0x01: model->pageSizeInBytes = 2048; break;
   \                     ??NandFlashModel_Find_8:
   \   000000D0   0xE3A00E80         MOV      R0,#+2048
   \   000000D4   0xE1C600B2         STRH     R0,[R6, #+2]
   \   000000D8   0xEA000004         B        ??NandFlashModel_Find_6
    144                                  case 0x02: model->pageSizeInBytes = 4096; break;
   \                     ??NandFlashModel_Find_9:
   \   000000DC   0xE3A00D40         MOV      R0,#+4096
   \   000000E0   0xE1C600B2         STRH     R0,[R6, #+2]
   \   000000E4   0xEA000001         B        ??NandFlashModel_Find_6
    145                                  case 0x03: model->pageSizeInBytes = 8192; break;
   \                     ??NandFlashModel_Find_10:
   \   000000E8   0xE3A00D80         MOV      R0,#+8192
   \   000000EC   0xE1C600B2         STRH     R0,[R6, #+2]
    146                              }
    147                              switch(id4 & 0x30) {
   \                     ??NandFlashModel_Find_6:
   \   000000F0   0xE1B00007         MOVS     R0,R7
   \   000000F4   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000F8   0xE2100030         ANDS     R0,R0,#0x30
   \   000000FC   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000100   0xE3500000         CMP      R0,#+0
   \   00000104   0x0A000006         BEQ      ??NandFlashModel_Find_11
   \   00000108   0xE3500010         CMP      R0,#+16
   \   0000010C   0x0A000007         BEQ      ??NandFlashModel_Find_12
   \   00000110   0xE3500020         CMP      R0,#+32
   \   00000114   0x0A000008         BEQ      ??NandFlashModel_Find_13
   \   00000118   0xE3500030         CMP      R0,#+48
   \   0000011C   0x0A000009         BEQ      ??NandFlashModel_Find_14
   \   00000120   0xEA00000A         B        ??NandFlashModel_Find_4
    148                                  case 0x00: model->blockSizeInKBytes = 64;  break;
   \                     ??NandFlashModel_Find_11:
   \   00000124   0xE3A00040         MOV      R0,#+64
   \   00000128   0xE1C600B6         STRH     R0,[R6, #+6]
   \   0000012C   0xEA000007         B        ??NandFlashModel_Find_4
    149                                  case 0x10: model->blockSizeInKBytes = 128; break;
   \                     ??NandFlashModel_Find_12:
   \   00000130   0xE3A00080         MOV      R0,#+128
   \   00000134   0xE1C600B6         STRH     R0,[R6, #+6]
   \   00000138   0xEA000004         B        ??NandFlashModel_Find_4
    150                                  case 0x20: model->blockSizeInKBytes = 256; break;
   \                     ??NandFlashModel_Find_13:
   \   0000013C   0xE3A00F40         MOV      R0,#+256
   \   00000140   0xE1C600B6         STRH     R0,[R6, #+6]
   \   00000144   0xEA000001         B        ??NandFlashModel_Find_4
    151                                  case 0x30: model->blockSizeInKBytes = 512; break;
   \                     ??NandFlashModel_Find_14:
   \   00000148   0xE3A00F80         MOV      R0,#+512
   \   0000014C   0xE1C600B6         STRH     R0,[R6, #+6]
    152                              }
    153          					#else
    154          					model->pageSizeInBytes = 1024 << (id4 & 0x03);
    155                              model->blockSizeInKBytes = (64) << ((id4 & 0x30) >>4);
    156          					#endif
    157                          }
    158                          #if defined(CHIP_NAND_CTRL)
    159                              switch(model->pageSizeInBytes) {
    160                                  case 1024: pageSize = AT91C_HSMC4_PAGESIZE_1056_Bytes; break;
    161                                  case 2048: pageSize = AT91C_HSMC4_PAGESIZE_2112_Bytes; break;
    162                                  case 4096: pageSize = AT91C_HSMC4_PAGESIZE_4224_Bytes; break;
    163                                  default: TRACE_ERROR("Unsupportted page size for NAND Flash Controller\n\r");
    164                              }
    165                              HSMC4_SetMode(pageSize | AT91C_HSMC4_DTOMUL_1048576 | AT91C_HSMC4_EDGECTRL |AT91C_HSMC4_DTOCYC | AT91C_HSMC4_RSPARE);
    166                          #endif
    167                      }
    168                      TRACE_DEBUG("NAND Model found:\r\n");
    169                      TRACE_DEBUG(" * deviceId = 0x%02X\r\n", model->deviceId);
    170                      TRACE_DEBUG(" * deviceSizeInMegaBytes = %d\r\n", model->deviceSizeInMegaBytes);
    171                      TRACE_DEBUG(" * blockSizeInkBytes = %d\r\n", model->blockSizeInKBytes);
    172                      TRACE_DEBUG(" * pageSizeInBytes = %d\r\n", model->pageSizeInBytes);
    173                      TRACE_DEBUG(" * options = 0x%02X\r\n", model->options);
    174                      break;
   \                     ??NandFlashModel_Find_4:
   \   00000150   0xEA000001         B        ??NandFlashModel_Find_2
    175                  }
    176              }
   \                     ??NandFlashModel_Find_3:
   \   00000154   0xE2999001         ADDS     R9,R9,#+1
   \   00000158   0xEAFFFFB7         B        ??NandFlashModel_Find_1
    177          
    178              // Check if chip has been detected
    179              if (found) {
   \                     ??NandFlashModel_Find_2:
   \   0000015C   0xE1B00008         MOVS     R0,R8
   \   00000160   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000164   0xE3500000         CMP      R0,#+0
   \   00000168   0x0A000001         BEQ      ??NandFlashModel_Find_15
    180          
    181                  return 0;
   \   0000016C   0xE3A00000         MOV      R0,#+0
   \   00000170   0xEA000000         B        ??NandFlashModel_Find_16
    182              }
    183              else {
    184          
    185                  return NandCommon_ERROR_UNKNOWNMODEL;
   \                     ??NandFlashModel_Find_15:
   \   00000174   0xE3A00008         MOV      R0,#+8
   \                     ??NandFlashModel_Find_16:
   \   00000178   0xE8BD4FFE         POP      {R1-R11,LR}
   \   0000017C   0xE12FFF1E         BX       LR               ;; return
    186              }
    187          }
    188          
    189          //------------------------------------------------------------------------------
    190          /// Translates address/size access of a NandFlashModel to block, page and
    191          /// offset values. The values are stored in the provided variables if their
    192          /// pointer is not 0.
    193          /// Returns 0 if the access is correct; otherwise returns
    194          /// NandCommon_ERROR_OUTOFBOUNDS.
    195          /// \param model  Pointer to a NandFlashModel instance.
    196          /// \param address  Access address.
    197          /// \param size  Access size in bytes.
    198          /// \param block  Stores the first accessed block number.
    199          /// \param page  Stores the first accessed page number inside the first block.
    200          /// \param offset  Stores the byte offset inside the first accessed page.
    201          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    202          unsigned char NandFlashModel_TranslateAccess(
    203              const struct NandFlashModel *model,
    204              unsigned int address,
    205              unsigned int size,
    206              unsigned short *block,
    207              unsigned short *page,
    208              unsigned short *offset)
    209          {
   \                     NandFlashModel_TranslateAccess:
   \   00000000   0xE92D4FF4         PUSH     {R2,R4-R11,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B08003         MOVS     R8,R3
   \   00000010   0xE59D6028         LDR      R6,[SP, #+40]
   \   00000014   0xE59D702C         LDR      R7,[SP, #+44]
    210               // Check that access is not too big
    211              #if !defined(OP_BOOTSTRAP_on)
    212              if ((address + size) > NandFlashModel_GetDeviceSizeInBytes(model)) {
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       NandFlashModel_GetDeviceSizeInBytes
   \   00000020   0xE59D2000         LDR      R2,[SP, #+0]
   \   00000024   0xE0922005         ADDS     R2,R2,R5
   \   00000028   0xE3B03000         MOVS     R3,#+0
   \   0000002C   0xE1510003         CMP      R1,R3
   \   00000030   0x8A000004         BHI      ??NandFlashModel_TranslateAccess_0
   \   00000034   0x3A000001         BCC      ??NandFlashModel_TranslateAccess_1
   \   00000038   0xE1500002         CMP      R0,R2
   \   0000003C   0x2A000001         BCS      ??NandFlashModel_TranslateAccess_0
    213          
    214                  TRACE_DEBUG("NandFlashModel_TranslateAccess: out-of-bounds access.\n\r");
    215                  return NandCommon_ERROR_OUTOFBOUNDS;
   \                     ??NandFlashModel_TranslateAccess_1:
   \   00000040   0xE3A00003         MOV      R0,#+3
   \   00000044   0xEA000022         B        ??NandFlashModel_TranslateAccess_2
    216              }
    217          	#endif
    218          
    219              // Get Nand info
    220              unsigned int blockSize = NandFlashModel_GetBlockSizeInBytes(model);
   \                     ??NandFlashModel_TranslateAccess_0:
   \   00000048   0xE1B00004         MOVS     R0,R4
   \   0000004C   0x........         BL       NandFlashModel_GetBlockSizeInBytes
   \   00000050   0xE1B09000         MOVS     R9,R0
    221              unsigned int pageSize = NandFlashModel_GetPageDataSize(model);
   \   00000054   0xE1B00004         MOVS     R0,R4
   \   00000058   0x........         BL       NandFlashModel_GetPageDataSize
   \   0000005C   0xE1B0A000         MOVS     R10,R0
    222          
    223              // Translate address
    224              #if !defined(OP_BOOTSTRAP_on)
    225              unsigned short tmpBlock = address / blockSize;
   \   00000060   0xE1B00005         MOVS     R0,R5
   \   00000064   0xE1B01009         MOVS     R1,R9
   \   00000068   0x........         BL       __aeabi_uidiv
   \   0000006C   0xE1B0B000         MOVS     R11,R0
    226              address -= tmpBlock * blockSize;
   \   00000070   0xE1B0000B         MOVS     R0,R11
   \   00000074   0xE1A00800         LSL      R0,R0,#+16
   \   00000078   0xE1B00820         LSRS     R0,R0,#+16
   \   0000007C   0xE0100099         MULS     R0,R9,R0
   \   00000080   0xE0555000         SUBS     R5,R5,R0
    227              unsigned short tmpPage = address / pageSize;
   \   00000084   0xE1B00005         MOVS     R0,R5
   \   00000088   0xE1B0100A         MOVS     R1,R10
   \   0000008C   0x........         BL       __aeabi_uidiv
   \   00000090   0xE1B01000         MOVS     R1,R0
    228              address -= tmpPage * pageSize;
   \   00000094   0xE1B00001         MOVS     R0,R1
   \   00000098   0xE1A00800         LSL      R0,R0,#+16
   \   0000009C   0xE1B00820         LSRS     R0,R0,#+16
   \   000000A0   0xE010009A         MULS     R0,R10,R0
   \   000000A4   0xE0555000         SUBS     R5,R5,R0
    229              unsigned short tmpOffset = address;
   \   000000A8   0xE1B02005         MOVS     R2,R5
    230          	#else
    231          	unsigned short tmpBlock = CALINT(address, blockSize);
    232          	address -= tmpBlock * blockSize;
    233          	unsigned short tmpPage = CALINT(address, pageSize);
    234          	address -= tmpPage * pageSize;
    235          	unsigned short tmpOffset= address;
    236          	#endif
    237          
    238              // Save results
    239              if (block) {
   \   000000AC   0xE3580000         CMP      R8,#+0
   \   000000B0   0x0A000000         BEQ      ??NandFlashModel_TranslateAccess_3
    240          
    241                  *block = tmpBlock;
   \   000000B4   0xE1C8B0B0         STRH     R11,[R8, #+0]
    242              }
    243              if (page) {
   \                     ??NandFlashModel_TranslateAccess_3:
   \   000000B8   0xE3560000         CMP      R6,#+0
   \   000000BC   0x0A000000         BEQ      ??NandFlashModel_TranslateAccess_4
    244          
    245                  *page = tmpPage;
   \   000000C0   0xE1C610B0         STRH     R1,[R6, #+0]
    246              }
    247              if (offset) {
   \                     ??NandFlashModel_TranslateAccess_4:
   \   000000C4   0xE3570000         CMP      R7,#+0
   \   000000C8   0x0A000000         BEQ      ??NandFlashModel_TranslateAccess_5
    248          
    249                  *offset = tmpOffset;
   \   000000CC   0xE1C720B0         STRH     R2,[R7, #+0]
    250              }
    251          
    252              return 0;
   \                     ??NandFlashModel_TranslateAccess_5:
   \   000000D0   0xE3A00000         MOV      R0,#+0
   \                     ??NandFlashModel_TranslateAccess_2:
   \   000000D4   0xE8BD4FF2         POP      {R1,R4-R11,LR}
   \   000000D8   0xE12FFF1E         BX       LR               ;; return
    253          }
    254          
    255          //------------------------------------------------------------------------------
    256          /// Returns the spare area placement scheme used by a particular nandflash
    257          /// model.
    258          /// \param model  Pointer to a NandFlashModel instance.
    259          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    260          const struct NandSpareScheme * NandFlashModel_GetScheme(
    261              const struct NandFlashModel *model)
    262          {
    263              return model->scheme;
   \                     NandFlashModel_GetScheme:
   \   00000000   0xE5900008         LDR      R0,[R0, #+8]
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    264          }
    265          
    266          //------------------------------------------------------------------------------
    267          /// Returns the device ID of a particular NandFlash model.
    268          /// \param model  Pointer to a NandFlashModel instance.
    269          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    270          unsigned char NandFlashModel_GetDeviceId(
    271             const struct NandFlashModel *model)
    272          {
    273              return model->deviceId;
   \                     NandFlashModel_GetDeviceId:
   \   00000000   0xE5D00000         LDRB     R0,[R0, #+0]
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    274          }
    275          
    276          //------------------------------------------------------------------------------
    277          /// Returns the number of blocks in the entire device.
    278          /// \param model  Pointer to a NandFlashModel instance.
    279          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    280          unsigned short NandFlashModel_GetDeviceSizeInBlocks(
    281             const struct NandFlashModel *model)
    282          {
   \                     NandFlashModel_GetDeviceSizeInBlocks:
   \   00000000   0xE92D4010         PUSH     {R4,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    283          	#if !defined(OP_BOOTSTRAP_on)
    284              return ((1024) / model->blockSizeInKBytes) * model->deviceSizeInMegaBytes;
   \   00000008   0xE3A00E40         MOV      R0,#+1024
   \   0000000C   0xE1D410B6         LDRH     R1,[R4, #+6]
   \   00000010   0x........         BL       __aeabi_idiv
   \   00000014   0xE1D410B4         LDRH     R1,[R4, #+4]
   \   00000018   0xE0100091         MULS     R0,R1,R0
   \   0000001C   0xE1A00800         LSL      R0,R0,#+16
   \   00000020   0xE1B00820         LSRS     R0,R0,#+16
   \   00000024   0xE8BD4010         POP      {R4,LR}
   \   00000028   0xE12FFF1E         BX       LR               ;; return
    285          	#else
    286          	unsigned int pow;
    287          	pow = CALPOW((1024 * model->deviceSizeInMegaBytes), model->blockSizeInKBytes);
    288          	return (0x1 << pow);
    289          	#endif
    290          }
    291          
    292          //------------------------------------------------------------------------------
    293          /// Returns the number of pages in the entire device.
    294          /// \param model  Pointer to a NandFlashModel instance.
    295          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    296          unsigned int NandFlashModel_GetDeviceSizeInPages(
    297             const struct NandFlashModel *model)
    298          {
   \                     NandFlashModel_GetDeviceSizeInPages:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    299              return (unsigned int) NandFlashModel_GetDeviceSizeInBlocks(model) //* 8 // HACK
    300                     * NandFlashModel_GetBlockSizeInPages(model);
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0x........         BL       NandFlashModel_GetDeviceSizeInBlocks
   \   00000010   0xE1B05000         MOVS     R5,R0
   \   00000014   0xE1A05805         LSL      R5,R5,#+16
   \   00000018   0xE1B05825         LSRS     R5,R5,#+16
   \   0000001C   0xE1B00004         MOVS     R0,R4
   \   00000020   0x........         BL       NandFlashModel_GetBlockSizeInPages
   \   00000024   0xE0110590         MULS     R1,R0,R5
   \   00000028   0xE1B00001         MOVS     R0,R1
   \   0000002C   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   00000030   0xE12FFF1E         BX       LR               ;; return
    301          }
    302          
    303          //------------------------------------------------------------------------------
    304          /// Returns the size of the whole device in bytes (this does not include the
    305          /// size of the spare zones).
    306          /// \param model  Pointer to a NandFlashModel instance.
    307          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    308          unsigned long long NandFlashModel_GetDeviceSizeInBytes(
    309             const struct NandFlashModel *model)
    310          {
    311              return ((unsigned long long) model->deviceSizeInMegaBytes) << 20;
   \                     NandFlashModel_GetDeviceSizeInBytes:
   \   00000000   0xE1D000B4         LDRH     R0,[R0, #+4]
   \   00000004   0xE3B01000         MOVS     R1,#+0
   \   00000008   0xE1B01A01         LSLS     R1,R1,#+20
   \   0000000C   0xE1811620         ORR      R1,R1,R0, LSR #+12
   \   00000010   0xE1B00A00         LSLS     R0,R0,#+20
   \   00000014   0xE12FFF1E         BX       LR               ;; return
    312          }
    313          
    314          //------------------------------------------------------------------------------
    315          /// Returns the size of the whole device in Mega bytes (this does not include the
    316          /// size of the spare zones).
    317          /// \param model  Pointer to a NandFlashModel instance.
    318          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    319          unsigned int NandFlashModel_GetDeviceSizeInMBytes(
    320             const struct NandFlashModel *model)
    321          {
    322              return ((unsigned int) model->deviceSizeInMegaBytes);
   \                     NandFlashModel_GetDeviceSizeInMBytes:
   \   00000000   0xE1D000B4         LDRH     R0,[R0, #+4]
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    323          }
    324          
    325          
    326          //------------------------------------------------------------------------------
    327          /// Returns the number of pages in one single block of a device.
    328          /// \param model  Pointer to a NandFlashModel instance.
    329          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    330          unsigned short NandFlashModel_GetBlockSizeInPages(
    331             const struct NandFlashModel *model)
    332          {
   \                     NandFlashModel_GetBlockSizeInPages:
   \   00000000   0xE92D4000         PUSH     {LR}
   \   00000004   0xE1B01000         MOVS     R1,R0
    333              #if !defined(OP_BOOTSTRAP_on)
    334              return model->blockSizeInKBytes * 1024 / model->pageSizeInBytes;
   \   00000008   0xE1D100B6         LDRH     R0,[R1, #+6]
   \   0000000C   0xE1B00500         LSLS     R0,R0,#+10
   \   00000010   0xE1D110B2         LDRH     R1,[R1, #+2]
   \   00000014   0x........         BL       __aeabi_idiv
   \   00000018   0xE1A00800         LSL      R0,R0,#+16
   \   0000001C   0xE1B00820         LSRS     R0,R0,#+16
   \   00000020   0xE8BD4000         POP      {LR}
   \   00000024   0xE12FFF1E         BX       LR               ;; return
    335          	#else
    336          	unsigned int pow;
    337          	pow = CALPOW((model->blockSizeInKBytes * 1024), model->pageSizeInBytes);
    338          	return (0x1 << pow);
    339          	#endif
    340          }
    341          
    342          //------------------------------------------------------------------------------
    343          /// Returns the size in bytes of one single block of a device. This does not
    344          /// take into account the spare zones size.
    345          /// \param model  Pointer to a NandFlashModel instance.
    346          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    347          unsigned int NandFlashModel_GetBlockSizeInBytes(
    348             const struct NandFlashModel *model)
    349          {
    350              return (model->blockSizeInKBytes *1024);
   \                     NandFlashModel_GetBlockSizeInBytes:
   \   00000000   0xE1D000B6         LDRH     R0,[R0, #+6]
   \   00000004   0xE1B00500         LSLS     R0,R0,#+10
   \   00000008   0xE12FFF1E         BX       LR               ;; return
    351          }
    352          
    353          //------------------------------------------------------------------------------
    354          /// Returns the size of the data area of a page in bytes.
    355          /// \param model  Pointer to a NandFlashModel instance.
    356          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    357          unsigned short NandFlashModel_GetPageDataSize(
    358             const struct NandFlashModel *model)
    359          {
    360              return model->pageSizeInBytes;
   \                     NandFlashModel_GetPageDataSize:
   \   00000000   0xE1D000B2         LDRH     R0,[R0, #+2]
   \   00000004   0xE12FFF1E         BX       LR               ;; return
    361          }
    362          
    363          //------------------------------------------------------------------------------
    364          /// Returns the size of the spare area of a page in bytes.
    365          /// \param model  Pointer to a NandFlashModel instance.
    366          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    367          unsigned char NandFlashModel_GetPageSpareSize(
    368             const struct NandFlashModel *model)
    369          {
    370              return (model->pageSizeInBytes>>5); /// Spare size is 16/512 of data size
   \                     NandFlashModel_GetPageSpareSize:
   \   00000000   0xE1D000B2         LDRH     R0,[R0, #+2]
   \   00000004   0xE1B002A0         LSRS     R0,R0,#+5
   \   00000008   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000000C   0xE12FFF1E         BX       LR               ;; return
    371          }
    372          
    373          //------------------------------------------------------------------------------
    374          /// Returns the number of bits used by the data bus of a NandFlash device.
    375          /// \param model  Pointer to a NandFlashModel instance.
    376          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    377          unsigned char NandFlashModel_GetDataBusWidth(
    378             const struct NandFlashModel *model)
    379          {
    380              return (model->options&NandFlashModel_DATABUS16)? 16: 8;
   \                     NandFlashModel_GetDataBusWidth:
   \   00000000   0xE5D00001         LDRB     R0,[R0, #+1]
   \   00000004   0xE3100001         TST      R0,#0x1
   \   00000008   0x0A000001         BEQ      ??NandFlashModel_GetDataBusWidth_0
   \   0000000C   0xE3A00010         MOV      R0,#+16
   \   00000010   0xEA000000         B        ??NandFlashModel_GetDataBusWidth_1
   \                     ??NandFlashModel_GetDataBusWidth_0:
   \   00000014   0xE3A00008         MOV      R0,#+8
   \                     ??NandFlashModel_GetDataBusWidth_1:
   \   00000018   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000001C   0xE12FFF1E         BX       LR               ;; return
    381          }
    382          
    383          //------------------------------------------------------------------------------
    384          /// Returns 1 if the given NandFlash model uses the "small blocks/pages"
    385          /// command set; otherwise returns 0.
    386          /// \param model  Pointer to a NandFlashModel instance.
    387          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    388          unsigned char NandFlashModel_HasSmallBlocks(
    389             const struct NandFlashModel *model)
    390          {
    391              return (model->pageSizeInBytes <= 512 )? 1: 0;
   \                     NandFlashModel_HasSmallBlocks:
   \   00000000   0xE1D000B2         LDRH     R0,[R0, #+2]
   \   00000004   0xE3A01001         MOV      R1,#+1
   \   00000008   0xE3811F80         ORR      R1,R1,#0x200
   \   0000000C   0xE1500001         CMP      R0,R1
   \   00000010   0xAA000001         BGE      ??NandFlashModel_HasSmallBlocks_0
   \   00000014   0xE3A00001         MOV      R0,#+1
   \   00000018   0xEA000000         B        ??NandFlashModel_HasSmallBlocks_1
   \                     ??NandFlashModel_HasSmallBlocks_0:
   \   0000001C   0xE3A00000         MOV      R0,#+0
   \                     ??NandFlashModel_HasSmallBlocks_1:
   \   00000020   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000024   0xE12FFF1E         BX       LR               ;; return
    392          }
    393          
    394          //------------------------------------------------------------------------------
    395          /// Returns 1 if the device supports the copy-back operation. Otherwise returns
    396          /// 0.
    397          /// \param model  Pointer to a NandFlashModel instance.
    398          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    399          unsigned char NandFlashModel_SupportsCopyBack(
    400              const struct NandFlashModel *model)
    401          {
    402              return ((model->options & NandFlashModel_COPYBACK) != 0);
   \                     NandFlashModel_SupportsCopyBack:
   \   00000000   0xE5D00001         LDRB     R0,[R0, #+1]
   \   00000004   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000008   0xE3A01001         MOV      R1,#+1
   \   0000000C   0xE01100A0         ANDS     R0,R1,R0, LSR #+1
   \   00000010   0xE12FFF1E         BX       LR               ;; return
    403          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable0:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2D 0x49          DC8 "-I- Nandflash ID is 0x%08X\012\015"
   \              0x2D 0x20    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x66 0x6C    
   \              0x61 0x73    
   \              0x68 0x20    
   \              0x49 0x44    
   \              0x20 0x69    
   \              0x73 0x20    
   \              0x30 0x78    
   \              0x25 0x30    
   \              0x38 0x58    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   NandFlashModel_Find
        48   -> __aeabi_memcpy
        48   -> printf
       0   NandFlashModel_GetBlockSizeInBytes
       4   NandFlashModel_GetBlockSizeInPages
         4 __aeabi_idiv
       0   NandFlashModel_GetDataBusWidth
       0   NandFlashModel_GetDeviceId
       8   NandFlashModel_GetDeviceSizeInBlocks
         8 __aeabi_idiv
       0   NandFlashModel_GetDeviceSizeInBytes
       0   NandFlashModel_GetDeviceSizeInMBytes
      16   NandFlashModel_GetDeviceSizeInPages
        16   -> NandFlashModel_GetBlockSizeInPages
        16   -> NandFlashModel_GetDeviceSizeInBlocks
       0   NandFlashModel_GetPageDataSize
       0   NandFlashModel_GetPageSpareSize
       0   NandFlashModel_GetScheme
       0   NandFlashModel_HasSmallBlocks
       0   NandFlashModel_SupportsCopyBack
      40   NandFlashModel_TranslateAccess
        40   -> NandFlashModel_GetBlockSizeInBytes
        40   -> NandFlashModel_GetDeviceSizeInBytes
        40   -> NandFlashModel_GetPageDataSize
        40 __aeabi_uidiv


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      32  ?_0
     384  NandFlashModel_Find
      12  NandFlashModel_GetBlockSizeInBytes
      40  NandFlashModel_GetBlockSizeInPages
      32  NandFlashModel_GetDataBusWidth
       8  NandFlashModel_GetDeviceId
      44  NandFlashModel_GetDeviceSizeInBlocks
      24  NandFlashModel_GetDeviceSizeInBytes
       8  NandFlashModel_GetDeviceSizeInMBytes
      52  NandFlashModel_GetDeviceSizeInPages
       8  NandFlashModel_GetPageDataSize
      16  NandFlashModel_GetPageSpareSize
       8  NandFlashModel_GetScheme
      40  NandFlashModel_HasSmallBlocks
      20  NandFlashModel_SupportsCopyBack
     220  NandFlashModel_TranslateAccess

 
  32 bytes in section .rodata
 920 bytes in section .text
 
 920 bytes of CODE  memory
  32 bytes of CONST memory

Errors: none
Warnings: none
