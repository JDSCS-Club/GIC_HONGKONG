###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        02/Jul/2015  09:27:34
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\SPI_FUN.c
#    Command line =  
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\SPI_FUN.c"
#        -D at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\"
#        --remarks --diag_suppress Pe826,Pe1375 -o
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/peripherals\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/memories\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/components\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\SPI_FUN.lst
#    Object file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\SPI_FUN.o
#
###############################################################################

F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\SPI_FUN.c
      1          
      2          //------------------------------------------------------------------------------
      3          //         Headers
      4          //------------------------------------------------------------------------------
      5          
      6          #include <board.h>
      7          #include <dbgu/dbgu.h>
      8          #include <pio/pio.h>
      9          #include <aic/aic.h>
     10          #include <utility/assert.h>
     11          #include <utility/trace.h>
     12          #include <utility/math.h>
     13          #include <memories/spi-flash/at26.h>
     14          
     15          #include <string.h>
     16          
     17          #include "SPI_FUN.h"

  #endif
        ^
"F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\SPI_FUN.h",18  Remark[Pe001]: 
          last line of file ends without a newline
     18          
     19          
     20          /// Maximum device page size in bytes.
     21          #define MAXPAGESIZE     256
     22          
     23          #if defined(BOARD_AT45_A_SPI_BASE)
     24          
     25          /// Address of the SPI peripheral connected to the AT26.
     26          #define SPI_BASE        BOARD_AT45_A_SPI_BASE
     27          /// Peripheral identifier of the SPI connected to the AT26.
     28          #define SPI_ID          BOARD_AT45_A_SPI_ID
     29          /// Chip select value used to select the AT26 chip.
     30          #define SPI_CS          BOARD_AT45_A_NPCS
     31          /// SPI peripheral pins to configure to access the serial flash.
     32          #define SPI_PINS        BOARD_AT45_A_SPI_PINS, BOARD_AT45_A_NPCS_PIN
     33          
     34          #elif defined(AT91C_BASE_SPI0)
     35          
     36          /// Address of the SPI peripheral connected to the AT26.
     37          #define SPI_BASE        AT91C_BASE_SPI0
     38          /// Peripheral identifier of the SPI connected to the AT26.
     39          #define SPI_ID          AT91C_ID_SPI0
     40          /// Chip select value used to select the AT26 chip.
     41          #define SPI_CS          0
     42          /// SPI peripheral pins to configure to access the serial flash.
     43          #define SPI_PINS        PINS_SPI0, PIN_SPI0_NPCS0
     44          
     45          #else
     46          
     47          /// Address of the SPI peripheral connected to the AT26.
     48          #define SPI_BASE        AT91C_BASE_SPI
     49          /// Peripheral identifier of the SPI connected to the AT26.
     50          #define SPI_ID          AT91C_ID_SPI
     51          /// Chip select value used to select the AT26 chip.
     52          #define SPI_CS          0
     53          /// SPI peripheral pins to configure to access the serial flash.
     54          #define SPI_PINS        PINS_SPI, PIN_SPI_NPCS0
     55          
     56          #endif //#if defined(AT91C_BASE_SPI0)
     57          
     58          //------------------------------------------------------------------------------
     59          //         Internal functions
     60          //------------------------------------------------------------------------------
     61          
     62          
     63          //------------------------------------------------------------------------------
     64          //         Internal variables
     65          //------------------------------------------------------------------------------
     66          /// SPI driver instance.

   \                                 In section .bss, align 4
     67          Spid spid;
   \                     spid:
   \   00000000                      DS8 16
     68          
     69          /// Serial flash driver instance.

   \                                 In section .bss, align 4
     70          At26 at26;
   \                     at26:
   \   00000000                      DS8 40
     71          

   \                                 In section .data, align 4
     72          Pin Spi_pins[] = {SPI_PINS};
   \                     Spi_pins:
   \   00000000   0x00001000         DC32 4096, 0FFFFF400H
   \              0xFFFFF400   
   \   00000008   0x02 0x00          DC8 2, 0, 1, 0
   \              0x01 0x00    
   \   0000000C   0x00002000         DC32 8192, 0FFFFF400H
   \              0xFFFFF400   
   \   00000014   0x02 0x00          DC8 2, 0, 1, 0
   \              0x01 0x00    
   \   00000018   0x00004000         DC32 16384, 0FFFFF400H
   \              0xFFFFF400   
   \   00000020   0x02 0x00          DC8 2, 0, 1, 0
   \              0x01 0x00    
   \   00000024   0x00000800         DC32 2048, 0FFFFF400H
   \              0xFFFFF400   
   \   0000002C   0x02 0x00          DC8 2, 0, 1, 0
   \              0x01 0x00    
     73          
     74          //------------------------------------------------------------------------------
     75          /// Interrupt service routine for the SPI peripheral. Forwards the interrupt
     76          /// to the SPI driver.
     77          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     78           void ISR_Spi(void)
     79          {
   \                     ISR_Spi:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
     80              SPID_Handler(&spid);
   \   00000004   0x........         LDR      R0,??DataTable11
   \   00000008   0x........         BL       SPID_Handler
     81          }
   \   0000000C   0xE8BD4001         POP      {R0,LR}
   \   00000010   0xE12FFF1E         BX       LR               ;; return
     82          
     83          //------------------------------------------------------------------------------
     84          /// Reads and returns the status register of the serial flash.
     85          /// \param pAt26  Pointer to an AT26 driver instance.
     86          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     87          unsigned char AT26_ReadStatus(At26 *pAt26)
     88          {
   \                     AT26_ReadStatus:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
     89              unsigned char error, status;
                                   ^
Warning[Pe550]: variable "error" was set but never used
     90          
     91              SANITY_CHECK(pAt26);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT26_ReadStatus_0
   \   00000014   0x........         LDR      R0,??DataTable11_1
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A0205B         MOV      R2,#+91
   \   00000020   0x........         LDR      R1,??DataTable11_2
   \   00000024   0x........         LDR      R0,??DataTable11_3
   \   00000028   0x........         BL       printf
   \                     ??AT26_ReadStatus_1:
   \   0000002C   0xEAFFFFFE         B        ??AT26_ReadStatus_1
     92          
     93              // Issue a status read command
     94              error = AT26_SendCommand(pAt26, AT26_READ_STATUS, 1, &status, 1, 0, 0, 0);
   \                     ??AT26_ReadStatus_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xE58D000C         STR      R0,[SP, #+12]
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0004         STR      R0,[SP, #+4]
   \   00000048   0xE3A00001         MOV      R0,#+1
   \   0000004C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000050   0xE28D3010         ADD      R3,SP,#+16
   \   00000054   0xE3A02001         MOV      R2,#+1
   \   00000058   0xE3A01005         MOV      R1,#+5
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       AT26_SendCommand
   \   00000064   0xE1B05000         MOVS     R5,R0
     95              //ASSERT(!error, "-F- AT26_GetStatus: Failed to issue command.\n\r");
     96          
     97              // Wait for transfer to finish
     98              while (AT26_IsBusy(pAt26));
   \                     ??AT26_ReadStatus_2:
   \   00000068   0xE1B00004         MOVS     R0,R4
   \   0000006C   0x........         BL       AT26_IsBusy
   \   00000070   0xE3500000         CMP      R0,#+0
   \   00000074   0x1AFFFFFB         BNE      ??AT26_ReadStatus_2
     99          
    100              return status;
   \   00000078   0xE5DD0010         LDRB     R0,[SP, #+16]
   \   0000007C   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   00000080   0xE8BD4030         POP      {R4,R5,LR}
   \   00000084   0xE12FFF1E         BX       LR               ;; return
    101          }
    102          
    103          //------------------------------------------------------------------------------
    104          /// Writes the given value in the status register of the serial flash device.
    105          /// \param pAt26  Pointer to an AT26 driver instance.
    106          /// \param status  Status to write.
    107          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    108          void AT26_WriteStatus(At26 *pAt26, unsigned char status)
    109          {
   \                     AT26_WriteStatus:
   \   00000000   0xE92D4032         PUSH     {R1,R4,R5,LR}
   \   00000004   0xE24DD010         SUB      SP,SP,#+16
   \   00000008   0xE1B04000         MOVS     R4,R0
    110              unsigned char error;
    111          
    112              SANITY_CHECK(pAt26);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT26_WriteStatus_0
   \   00000014   0x........         LDR      R0,??DataTable11_1
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A02070         MOV      R2,#+112
   \   00000020   0x........         LDR      R1,??DataTable11_2
   \   00000024   0x........         LDR      R0,??DataTable11_3
   \   00000028   0x........         BL       printf
   \                     ??AT26_WriteStatus_1:
   \   0000002C   0xEAFFFFFE         B        ??AT26_WriteStatus_1
    113          
    114              // Issue a write status command
    115              error = AT26_SendCommand(pAt26, AT26_WRITE_STATUS, 1, &status, 1, 0, 0, 0);
   \                     ??AT26_WriteStatus_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xE58D000C         STR      R0,[SP, #+12]
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0004         STR      R0,[SP, #+4]
   \   00000048   0xE3A00001         MOV      R0,#+1
   \   0000004C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000050   0xE28D3010         ADD      R3,SP,#+16
   \   00000054   0xE3A02001         MOV      R2,#+1
   \   00000058   0xE3A01001         MOV      R1,#+1
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       AT26_SendCommand
   \   00000064   0xE1B05000         MOVS     R5,R0
    116              ASSERT(!error, "-F- AT26_WriteStatus: Failed to issue command.\n\r");
   \   00000068   0xE1B00005         MOVS     R0,R5
   \   0000006C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000070   0xE3500000         CMP      R0,#+0
   \   00000074   0x0A000004         BEQ      ??AT26_WriteStatus_2
   \   00000078   0x........         LDR      R0,??DataTable11_1
   \   0000007C   0x........         BL       printf
   \   00000080   0x........         LDR      R0,??DataTable11_4
   \   00000084   0x........         BL       printf
   \                     ??AT26_WriteStatus_3:
   \   00000088   0xEAFFFFFE         B        ??AT26_WriteStatus_3
    117              while (AT26_IsBusy(pAt26));
   \                     ??AT26_WriteStatus_2:
   \   0000008C   0xE1B00004         MOVS     R0,R4
   \   00000090   0x........         BL       AT26_IsBusy
   \   00000094   0xE3500000         CMP      R0,#+0
   \   00000098   0x1AFFFFFB         BNE      ??AT26_WriteStatus_2
    118          }
   \   0000009C   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000A0   0xE8BD4030         POP      {R4,R5,LR}
   \   000000A4   0xE12FFF1E         BX       LR               ;; return
    119          
    120          //------------------------------------------------------------------------------
    121          /// Waits for the serial flash device to become ready to accept new commands.
    122          /// \param pAt26  Pointer to an AT26 driver instance.
    123          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    124          void AT26_WaitReady(At26 *pAt26)
    125          {
   \                     AT26_WaitReady:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    126              unsigned char ready = 0;
   \   00000008   0xE3A05000         MOV      R5,#+0
    127          
    128              SANITY_CHECK(pAt26);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT26_WaitReady_0
   \   00000014   0x........         LDR      R0,??DataTable11_1
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A02080         MOV      R2,#+128
   \   00000020   0x........         LDR      R1,??DataTable11_2
   \   00000024   0x........         LDR      R0,??DataTable11_3
   \   00000028   0x........         BL       printf
   \                     ??AT26_WaitReady_1:
   \   0000002C   0xEAFFFFFE         B        ??AT26_WaitReady_1
    129          
    130              // Read status register and check busy bit
    131              while (!ready) {
   \                     ??AT26_WaitReady_0:
   \   00000030   0xE1B00005         MOVS     R0,R5
   \   00000034   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000038   0xE3500000         CMP      R0,#+0
   \   0000003C   0x1A000005         BNE      ??AT26_WaitReady_2
    132          
    133                  ready = ((AT26_ReadStatus(pAt26) & AT26_STATUS_RDYBSY) == AT26_STATUS_RDYBSY_READY);
   \   00000040   0xE1B00004         MOVS     R0,R4
   \   00000044   0x........         BL       AT26_ReadStatus
   \   00000048   0xE2100001         ANDS     R0,R0,#0x1
   \   0000004C   0xE2300001         EORS     R0,R0,#0x1
   \   00000050   0xE1B05000         MOVS     R5,R0
   \   00000054   0xEAFFFFF5         B        ??AT26_WaitReady_0
    134              }
    135          }
   \                     ??AT26_WaitReady_2:
   \   00000058   0xE8BD4031         POP      {R0,R4,R5,LR}
   \   0000005C   0xE12FFF1E         BX       LR               ;; return
    136          
    137          //------------------------------------------------------------------------------
    138          /// Reads and returns the serial flash device ID.
    139          /// \param pAt26  Pointer to an AT26 driver instance.
    140          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    141          unsigned int AT26_ReadJedecId(At26 *pAt26)
    142          {
   \                     AT26_ReadJedecId:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
    143              unsigned char error;
    144              unsigned int id = 0;
   \   0000000C   0xE3A00000         MOV      R0,#+0
   \   00000010   0xE58D0010         STR      R0,[SP, #+16]
    145          
    146              SANITY_CHECK(pAt26);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000006         BNE      ??AT26_ReadJedecId_0
   \   0000001C   0x........         LDR      R0,??DataTable11_1
   \   00000020   0x........         BL       printf
   \   00000024   0xE3A02092         MOV      R2,#+146
   \   00000028   0x........         LDR      R1,??DataTable11_2
   \   0000002C   0x........         LDR      R0,??DataTable11_3
   \   00000030   0x........         BL       printf
   \                     ??AT26_ReadJedecId_1:
   \   00000034   0xEAFFFFFE         B        ??AT26_ReadJedecId_1
    147           
    148              // Issue a read ID command
    149              error = AT26_SendCommand(pAt26, AT26_READ_JEDEC_ID, 1,
    150                                       (unsigned char *) &id, 3, 0, 0, 0);
   \                     ??AT26_ReadJedecId_0:
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D000C         STR      R0,[SP, #+12]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0008         STR      R0,[SP, #+8]
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xE58D0004         STR      R0,[SP, #+4]
   \   00000050   0xE3A00003         MOV      R0,#+3
   \   00000054   0xE58D0000         STR      R0,[SP, #+0]
   \   00000058   0xE28D3010         ADD      R3,SP,#+16
   \   0000005C   0xE3A02001         MOV      R2,#+1
   \   00000060   0xE3A0109F         MOV      R1,#+159
   \   00000064   0xE1B00004         MOVS     R0,R4
   \   00000068   0x........         BL       AT26_SendCommand
   \   0000006C   0xE1B05000         MOVS     R5,R0
    151              ASSERT(!error, "-F- AT26_GetJedecId: Could not issue command.\n\r");
   \   00000070   0xE1B00005         MOVS     R0,R5
   \   00000074   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000078   0xE3500000         CMP      R0,#+0
   \   0000007C   0x0A000004         BEQ      ??AT26_ReadJedecId_2
   \   00000080   0x........         LDR      R0,??DataTable11_1
   \   00000084   0x........         BL       printf
   \   00000088   0x........         LDR      R0,??DataTable11_5
   \   0000008C   0x........         BL       printf
   \                     ??AT26_ReadJedecId_3:
   \   00000090   0xEAFFFFFE         B        ??AT26_ReadJedecId_3
    152          
    153               // Wait for transfer to finish
    154              while (AT26_IsBusy(pAt26));
   \                     ??AT26_ReadJedecId_2:
   \   00000094   0xE1B00004         MOVS     R0,R4
   \   00000098   0x........         BL       AT26_IsBusy
   \   0000009C   0xE3500000         CMP      R0,#+0
   \   000000A0   0x1AFFFFFB         BNE      ??AT26_ReadJedecId_2
    155          
    156              return id;
   \   000000A4   0xE59D0010         LDR      R0,[SP, #+16]
   \   000000A8   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000AC   0xE8BD4030         POP      {R4,R5,LR}
   \   000000B0   0xE12FFF1E         BX       LR               ;; return
    157          }
    158          
    159          //------------------------------------------------------------------------------
    160          /// Enables critical writes operation on a serial flash device, such as sector
    161          /// protection, status register, etc.
    162          /// \para pAt26  Pointer to an AT26 driver instance.
    163          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    164          void AT26_EnableWrite(At26 *pAt26)
    165          {
   \                     AT26_EnableWrite:
   \   00000000   0xE92D4030         PUSH     {R4,R5,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
    166              unsigned char error;
                                   ^
Warning[Pe550]: variable "error" was set but never used
    167          
    168              SANITY_CHECK(pAt26);
   \   0000000C   0xE3540000         CMP      R4,#+0
   \   00000010   0x1A000006         BNE      ??AT26_EnableWrite_0
   \   00000014   0x........         LDR      R0,??DataTable11_1
   \   00000018   0x........         BL       printf
   \   0000001C   0xE3A020A8         MOV      R2,#+168
   \   00000020   0x........         LDR      R1,??DataTable11_2
   \   00000024   0x........         LDR      R0,??DataTable11_3
   \   00000028   0x........         BL       printf
   \                     ??AT26_EnableWrite_1:
   \   0000002C   0xEAFFFFFE         B        ??AT26_EnableWrite_1
    169          
    170              // Issue a write enable command
    171              error = AT26_SendCommand(pAt26, AT26_WRITE_ENABLE, 1, 0, 0, 0, 0, 0);
   \                     ??AT26_EnableWrite_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xE58D000C         STR      R0,[SP, #+12]
   \   00000038   0xE3A00000         MOV      R0,#+0
   \   0000003C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xE58D0004         STR      R0,[SP, #+4]
   \   00000048   0xE3A00000         MOV      R0,#+0
   \   0000004C   0xE58D0000         STR      R0,[SP, #+0]
   \   00000050   0xE3A03000         MOV      R3,#+0
   \   00000054   0xE3A02001         MOV      R2,#+1
   \   00000058   0xE3A01006         MOV      R1,#+6
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       AT26_SendCommand
   \   00000064   0xE1B05000         MOVS     R5,R0
    172              //ASSERT(!error, "-F- AT26_EnableWrite: Could not issue command.\n\r");
    173          
    174              // Wait for end of transfer
    175              while (AT26_IsBusy(pAt26));
   \                     ??AT26_EnableWrite_2:
   \   00000068   0xE1B00004         MOVS     R0,R4
   \   0000006C   0x........         BL       AT26_IsBusy
   \   00000070   0xE3500000         CMP      R0,#+0
   \   00000074   0x1AFFFFFB         BNE      ??AT26_EnableWrite_2
    176          }
   \   00000078   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   0000007C   0xE8BD4030         POP      {R4,R5,LR}
   \   00000080   0xE12FFF1E         BX       LR               ;; return
    177          
    178          //------------------------------------------------------------------------------
    179          /// Unprotects the contents of the serial flash device.
    180          /// Returns 0 if the device has been unprotected; otherwise returns
    181          /// SF_PROTECTED.
    182          /// \param pAt26  Pointer to an AT26 driver instance.
    183          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    184          unsigned char AT26_Unprotect(At26 *pAt26)
    185          {
   \                     AT26_Unprotect:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    186              unsigned char status;
    187          
    188              SANITY_CHECK(pAt26);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000006         BNE      ??AT26_Unprotect_0
   \   00000010   0x........         LDR      R0,??DataTable11_1
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A020BC         MOV      R2,#+188
   \   0000001C   0x........         LDR      R1,??DataTable11_2
   \   00000020   0x........         LDR      R0,??DataTable11_3
   \   00000024   0x........         BL       printf
   \                     ??AT26_Unprotect_1:
   \   00000028   0xEAFFFFFE         B        ??AT26_Unprotect_1
    189          
    190              // Get the status register value to check the current protection
    191              status = AT26_ReadStatus(pAt26);
   \                     ??AT26_Unprotect_0:
   \   0000002C   0xE1B00004         MOVS     R0,R4
   \   00000030   0x........         BL       AT26_ReadStatus
   \   00000034   0xE1B05000         MOVS     R5,R0
    192              if ((status & AT26_STATUS_SWP) == AT26_STATUS_SWP_PROTNONE) {
   \   00000038   0xE315000C         TST      R5,#0xC
   \   0000003C   0x1A000001         BNE      ??AT26_Unprotect_2
    193          
    194                  // Protection already disabled
    195                  return 0;
   \   00000040   0xE3A00000         MOV      R0,#+0
   \   00000044   0xEA000012         B        ??AT26_Unprotect_3
    196              }
    197              
    198              // Check if sector protection registers are locked
    199              if ((status & AT26_STATUS_SPRL) == AT26_STATUS_SPRL_LOCKED) {
   \                     ??AT26_Unprotect_2:
   \   00000048   0xE1B00005         MOVS     R0,R5
   \   0000004C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000050   0xE3100080         TST      R0,#0x80
   \   00000054   0x0A000004         BEQ      ??AT26_Unprotect_4
    200          
    201                  // Unprotect sector protection registers by writing the status reg.
    202                  AT26_EnableWrite(pAt26);
   \   00000058   0xE1B00004         MOVS     R0,R4
   \   0000005C   0x........         BL       AT26_EnableWrite
    203                  AT26_WriteStatus(pAt26, 0);
   \   00000060   0xE3A01000         MOV      R1,#+0
   \   00000064   0xE1B00004         MOVS     R0,R4
   \   00000068   0x........         BL       AT26_WriteStatus
    204              }
    205              
    206              // Perform a global unprotect command
    207                AT26_EnableWrite(pAt26);
   \                     ??AT26_Unprotect_4:
   \   0000006C   0xE1B00004         MOVS     R0,R4
   \   00000070   0x........         BL       AT26_EnableWrite
    208              AT26_WriteStatus(pAt26, 0);
   \   00000074   0xE3A01000         MOV      R1,#+0
   \   00000078   0xE1B00004         MOVS     R0,R4
   \   0000007C   0x........         BL       AT26_WriteStatus
    209              
    210              // Check the new status
    211              if ((status & (AT26_STATUS_SPRL | AT26_STATUS_SWP)) != 0) {
   \   00000080   0xE315008C         TST      R5,#0x8C
   \   00000084   0x0A000001         BEQ      ??AT26_Unprotect_5
    212          
    213                  return AT26_ERROR_PROTECTED;
   \   00000088   0xE3A00001         MOV      R0,#+1
   \   0000008C   0xEA000000         B        ??AT26_Unprotect_3
    214              }
    215              else {
    216          
    217                  return 0;
   \                     ??AT26_Unprotect_5:
   \   00000090   0xE3A00000         MOV      R0,#+0
   \                     ??AT26_Unprotect_3:
   \   00000094   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   00000098   0xE12FFF1E         BX       LR               ;; return
    218              }
    219          }
    220          
    221          //------------------------------------------------------------------------------
    222          /// Erases all the content of the memory chip.
    223          /// \param pAt26  Pointer to an AT26 driver instance.
    224          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    225          unsigned char AT26_EraseChip(At26 *pAt26)
    226          {
   \                     AT26_EraseChip:
   \   00000000   0xE92D407F         PUSH     {R0-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    227              unsigned char status;
    228              unsigned char error;
    229          
    230              SANITY_CHECK(pAt26);
   \   00000008   0xE3540000         CMP      R4,#+0
   \   0000000C   0x1A000006         BNE      ??AT26_EraseChip_0
   \   00000010   0x........         LDR      R0,??DataTable11_1
   \   00000014   0x........         BL       printf
   \   00000018   0xE3A020E6         MOV      R2,#+230
   \   0000001C   0x........         LDR      R1,??DataTable11_2
   \   00000020   0x........         LDR      R0,??DataTable11_3
   \   00000024   0x........         BL       printf
   \                     ??AT26_EraseChip_1:
   \   00000028   0xEAFFFFFE         B        ??AT26_EraseChip_1
    231          
    232              // Check that the flash is ready an unprotected
    233              status = AT26_ReadStatus(pAt26);
   \                     ??AT26_EraseChip_0:
   \   0000002C   0xE1B00004         MOVS     R0,R4
   \   00000030   0x........         BL       AT26_ReadStatus
   \   00000034   0xE1B05000         MOVS     R5,R0
    234              if ((status & AT26_STATUS_SWP) != AT26_STATUS_SWP_PROTNONE) {
   \   00000038   0xE315000C         TST      R5,#0xC
   \   0000003C   0x0A000003         BEQ      ??AT26_EraseChip_2
    235          
    236                  TRACE_WARNING("AT26_EraseBlock: Device is protected.\n\r");
   \   00000040   0x........         LDR      R0,??DataTable11_6
   \   00000044   0x........         BL       printf
    237                  return AT26_ERROR_PROTECTED;
   \   00000048   0xE3A00001         MOV      R0,#+1
   \   0000004C   0xEA00001F         B        ??AT26_EraseChip_3
    238              }
    239              
    240              // Enable critical write operation
    241                AT26_EnableWrite(pAt26);
   \                     ??AT26_EraseChip_2:
   \   00000050   0xE1B00004         MOVS     R0,R4
   \   00000054   0x........         BL       AT26_EnableWrite
    242              
    243              // Erase the chip
    244              error = AT26_SendCommand(pAt26, AT26_CHIP_ERASE_2, 1, 0, 0, 0, 0, 0);
   \   00000058   0xE3A00000         MOV      R0,#+0
   \   0000005C   0xE58D000C         STR      R0,[SP, #+12]
   \   00000060   0xE3A00000         MOV      R0,#+0
   \   00000064   0xE58D0008         STR      R0,[SP, #+8]
   \   00000068   0xE3A00000         MOV      R0,#+0
   \   0000006C   0xE58D0004         STR      R0,[SP, #+4]
   \   00000070   0xE3A00000         MOV      R0,#+0
   \   00000074   0xE58D0000         STR      R0,[SP, #+0]
   \   00000078   0xE3A03000         MOV      R3,#+0
   \   0000007C   0xE3A02001         MOV      R2,#+1
   \   00000080   0xE3A010C7         MOV      R1,#+199
   \   00000084   0xE1B00004         MOVS     R0,R4
   \   00000088   0x........         BL       AT26_SendCommand
   \   0000008C   0xE1B06000         MOVS     R6,R0
    245              ASSERT(!error, "-F- AT26_ChipErase: Could not issue command.\n\r");
   \   00000090   0xE1B00006         MOVS     R0,R6
   \   00000094   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000098   0xE3500000         CMP      R0,#+0
   \   0000009C   0x0A000004         BEQ      ??AT26_EraseChip_4
   \   000000A0   0x........         LDR      R0,??DataTable11_1
   \   000000A4   0x........         BL       printf
   \   000000A8   0x........         LDR      R0,??DataTable11_7
   \   000000AC   0x........         BL       printf
   \                     ??AT26_EraseChip_5:
   \   000000B0   0xEAFFFFFE         B        ??AT26_EraseChip_5
    246               while (AT26_IsBusy(pAt26));    
   \                     ??AT26_EraseChip_4:
   \   000000B4   0xE1B00004         MOVS     R0,R4
   \   000000B8   0x........         BL       AT26_IsBusy
   \   000000BC   0xE3500000         CMP      R0,#+0
   \   000000C0   0x1AFFFFFB         BNE      ??AT26_EraseChip_4
    247              AT26_WaitReady(pAt26);
   \   000000C4   0xE1B00004         MOVS     R0,R4
   \   000000C8   0x........         BL       AT26_WaitReady
    248          
    249              return 0;
   \   000000CC   0xE3A00000         MOV      R0,#+0
   \                     ??AT26_EraseChip_3:
   \   000000D0   0xE28DD010         ADD      SP,SP,#+16       ;; stack cleaning
   \   000000D4   0xE8BD4070         POP      {R4-R6,LR}
   \   000000D8   0xE12FFF1E         BX       LR               ;; return
    250          }
    251          
    252          //------------------------------------------------------------------------------
    253          /// Erases the specified 4KB block of the serial firmware dataflash.
    254          /// Returns 0 if successful; otherwise returns AT26_ERROR_PROTECTED if the
    255          /// device is protected or AT26_ERROR_BUSY if it is busy executing a command.
    256          /// \param pAt26  Pointer to an AT26 driver instance.
    257          /// \param address  Address of the block to erase.
    258          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    259          unsigned char AT26_EraseBlock(At26 *pAt26, unsigned int address)
    260          {
   \                     AT26_EraseBlock:
   \   00000000   0xE92D40F0         PUSH     {R4-R7,LR}
   \   00000004   0xE24DD014         SUB      SP,SP,#+20
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05001         MOVS     R5,R1
    261              unsigned char status;
    262              unsigned char error;
    263          
    264              SANITY_CHECK(pAt26);
   \   00000010   0xE3540000         CMP      R4,#+0
   \   00000014   0x1A000006         BNE      ??AT26_EraseBlock_0
   \   00000018   0x........         LDR      R0,??DataTable11_1
   \   0000001C   0x........         BL       printf
   \   00000020   0xE3A02F42         MOV      R2,#+264
   \   00000024   0x........         LDR      R1,??DataTable11_2
   \   00000028   0x........         LDR      R0,??DataTable11_3
   \   0000002C   0x........         BL       printf
   \                     ??AT26_EraseBlock_1:
   \   00000030   0xEAFFFFFE         B        ??AT26_EraseBlock_1
    265           
    266              // Check that the flash is ready an unprotected
    267              status = AT26_ReadStatus(pAt26);
   \                     ??AT26_EraseBlock_0:
   \   00000034   0xE1B00004         MOVS     R0,R4
   \   00000038   0x........         BL       AT26_ReadStatus
   \   0000003C   0xE1B06000         MOVS     R6,R0
    268              if ((status & AT26_STATUS_RDYBSY) != AT26_STATUS_RDYBSY_BUSY) {
   \   00000040   0xE1B00006         MOVS     R0,R6
   \   00000044   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000048   0xE3100001         TST      R0,#0x1
   \   0000004C   0x1A000003         BNE      ??AT26_EraseBlock_2
    269          
    270                  TRACE_WARNING("AT26_EraseBlock: Device is not ready.\n\r");
   \   00000050   0x........         LDR      R0,??DataTable11_8
   \   00000054   0x........         BL       printf
    271                  return AT26_ERROR_BUSY;
   \   00000058   0xE3A00002         MOV      R0,#+2
   \   0000005C   0xEA000024         B        ??AT26_EraseBlock_3
    272              }
    273              else if ((status & AT26_STATUS_SWP) != AT26_STATUS_SWP_PROTNONE) {
   \                     ??AT26_EraseBlock_2:
   \   00000060   0xE316000C         TST      R6,#0xC
   \   00000064   0x0A000003         BEQ      ??AT26_EraseBlock_4
    274          
    275                  TRACE_WARNING("AT26_EraseBlock: Device is protected.\n\r");
   \   00000068   0x........         LDR      R0,??DataTable11_6
   \   0000006C   0x........         BL       printf
    276                  return AT26_ERROR_PROTECTED;
   \   00000070   0xE3A00001         MOV      R0,#+1
   \   00000074   0xEA00001E         B        ??AT26_EraseBlock_3
    277              }
    278          
    279              // Enable critical write operation
    280                AT26_EnableWrite(pAt26);
   \                     ??AT26_EraseBlock_4:
   \   00000078   0xE1B00004         MOVS     R0,R4
   \   0000007C   0x........         BL       AT26_EnableWrite
    281          
    282              // Start the block erase command
    283              error = AT26_SendCommand(pAt26, AT26_BLOCK_ERASE_4K, 4, 0, 0, address, 0, 0);
   \   00000080   0xE3A00000         MOV      R0,#+0
   \   00000084   0xE58D000C         STR      R0,[SP, #+12]
   \   00000088   0xE3A00000         MOV      R0,#+0
   \   0000008C   0xE58D0008         STR      R0,[SP, #+8]
   \   00000090   0xE58D5004         STR      R5,[SP, #+4]
   \   00000094   0xE3A00000         MOV      R0,#+0
   \   00000098   0xE58D0000         STR      R0,[SP, #+0]
   \   0000009C   0xE3A03000         MOV      R3,#+0
   \   000000A0   0xE3A02004         MOV      R2,#+4
   \   000000A4   0xE3A01020         MOV      R1,#+32
   \   000000A8   0xE1B00004         MOVS     R0,R4
   \   000000AC   0x........         BL       AT26_SendCommand
   \   000000B0   0xE1B07000         MOVS     R7,R0
    284              ASSERT(!error, "-F- AT26_EraseBlock: Could not issue command.\n\r");
   \   000000B4   0xE1B00007         MOVS     R0,R7
   \   000000B8   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000BC   0xE3500000         CMP      R0,#+0
   \   000000C0   0x0A000004         BEQ      ??AT26_EraseBlock_5
   \   000000C4   0x........         LDR      R0,??DataTable11_1
   \   000000C8   0x........         BL       printf
   \   000000CC   0x........         LDR      R0,??DataTable11_9
   \   000000D0   0x........         BL       printf
   \                     ??AT26_EraseBlock_6:
   \   000000D4   0xEAFFFFFE         B        ??AT26_EraseBlock_6
    285              while (AT26_IsBusy(pAt26));
   \                     ??AT26_EraseBlock_5:
   \   000000D8   0xE1B00004         MOVS     R0,R4
   \   000000DC   0x........         BL       AT26_IsBusy
   \   000000E0   0xE3500000         CMP      R0,#+0
   \   000000E4   0x1AFFFFFB         BNE      ??AT26_EraseBlock_5
    286              AT26_WaitReady(pAt26);
   \   000000E8   0xE1B00004         MOVS     R0,R4
   \   000000EC   0x........         BL       AT26_WaitReady
    287          
    288              return 0;
   \   000000F0   0xE3A00000         MOV      R0,#+0
   \                     ??AT26_EraseBlock_3:
   \   000000F4   0xE28DD014         ADD      SP,SP,#+20       ;; stack cleaning
   \   000000F8   0xE8BD40F0         POP      {R4-R7,LR}
   \   000000FC   0xE12FFF1E         BX       LR               ;; return
    289          }
    290          
    291          //------------------------------------------------------------------------------
    292          /// Writes data at the specified address on the serial firmware dataflash. The
    293          /// page(s) to program must have been erased prior to writing. This function
    294          /// handles page boundary crossing automatically.
    295          /// Returns 0 if successful; otherwise, returns AT26_ERROR_PROGRAM is there has
    296          /// been an error during the data programming.
    297          /// \param pAt26  Pointer to an AT26 driver instance.
    298          /// \param pData  Data buffer.
    299          /// \param size  Number of bytes in buffer.
    300          /// \param address  Write address.
    301          //------------------------------------------------------------------------------
    302          

   \                                 In section .text, align 4, keep-with-next
    303          unsigned char AT26_Write(
    304              At26 *pAt26,
    305              unsigned char *pData,
    306              unsigned int size,
    307              unsigned int address)
    308          {
   \                     AT26_Write:
   \   00000000   0xE92D47FF         PUSH     {R0-R10,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    309              unsigned int pageSize;
    310              unsigned int writeSize;
    311              unsigned char error;
                                   ^
Warning[Pe550]: variable "error" was set but never used
    312              unsigned char status;
                                   ^
Warning[Pe177]: variable "status" was declared but never referenced
    313          
    314              SANITY_CHECK(pAt26);
   \   00000014   0xE3540000         CMP      R4,#+0
   \   00000018   0x1A000007         BNE      ??AT26_Write_0
   \   0000001C   0x........         LDR      R0,??DataTable11_1
   \   00000020   0x........         BL       printf
   \   00000024   0xE3A0203A         MOV      R2,#+58
   \   00000028   0xE3822F40         ORR      R2,R2,#0x100
   \   0000002C   0x........         LDR      R1,??DataTable11_2
   \   00000030   0x........         LDR      R0,??DataTable11_3
   \   00000034   0x........         BL       printf
   \                     ??AT26_Write_1:
   \   00000038   0xEAFFFFFE         B        ??AT26_Write_1
    315              SANITY_CHECK(pData);
   \                     ??AT26_Write_0:
   \   0000003C   0xE3550000         CMP      R5,#+0
   \   00000040   0x1A000007         BNE      ??AT26_Write_2
   \   00000044   0x........         LDR      R0,??DataTable11_1
   \   00000048   0x........         BL       printf
   \   0000004C   0xE3A0203B         MOV      R2,#+59
   \   00000050   0xE3822F40         ORR      R2,R2,#0x100
   \   00000054   0x........         LDR      R1,??DataTable11_2
   \   00000058   0x........         LDR      R0,??DataTable11_3
   \   0000005C   0x........         BL       printf
   \                     ??AT26_Write_3:
   \   00000060   0xEAFFFFFE         B        ??AT26_Write_3
    316          
    317              // Retrieve device page size
    318              pageSize = AT26_PageSize(&at26);
   \                     ??AT26_Write_2:
   \   00000064   0x........         LDR      R0,??DataTable11_10
   \   00000068   0xE590001C         LDR      R0,[R0, #+28]
   \   0000006C   0xE590000C         LDR      R0,[R0, #+12]
   \   00000070   0xE1B08000         MOVS     R8,R0
    319          
    320              // Program one page after the other
    321              while (size > 0) {
   \                     ??AT26_Write_4:
   \   00000074   0xE3560000         CMP      R6,#+0
   \   00000078   0x0A000015         BEQ      ??AT26_Write_5
    322          
    323                  // Compute number of bytes to program in page
    324                  writeSize = min(size, pageSize - (address % pageSize));
   \   0000007C   0xE1B00007         MOVS     R0,R7
   \   00000080   0xE1B01008         MOVS     R1,R8
   \   00000084   0x........         BL       __aeabi_uidivmod
   \   00000088   0xE0581001         SUBS     R1,R8,R1
   \   0000008C   0xE1B00006         MOVS     R0,R6
   \   00000090   0x........         BL       min
   \   00000094   0xE1B09000         MOVS     R9,R0
    325                          
    326                  // Enable critical write operation
    327                  //AT26_EnableWrite(pAt26);
    328               
    329                  
    330                   // Program page
    331                  //error = AT26_SendCommand(pAt26, AT26_BYTE_PAGE_PROGRAM, 1,pData, writeSize, address, 0, 0);
    332                  
    333                   error = AT26_SendCommand(pAt26, AT26_BYTE_PAGE_PROGRAM, 1,pData, writeSize, address, 0, 0);
   \   00000098   0xE3A00000         MOV      R0,#+0
   \   0000009C   0xE58D000C         STR      R0,[SP, #+12]
   \   000000A0   0xE3A00000         MOV      R0,#+0
   \   000000A4   0xE58D0008         STR      R0,[SP, #+8]
   \   000000A8   0xE58D7004         STR      R7,[SP, #+4]
   \   000000AC   0xE58D9000         STR      R9,[SP, #+0]
   \   000000B0   0xE1B03005         MOVS     R3,R5
   \   000000B4   0xE3A02001         MOV      R2,#+1
   \   000000B8   0xE3A01002         MOV      R1,#+2
   \   000000BC   0xE1B00004         MOVS     R0,R4
   \   000000C0   0x........         BL       AT26_SendCommand
   \   000000C4   0xE1B0A000         MOVS     R10,R0
    334                  
    335                  //ASSERT(!error, "-F- AT26_WritePage: Failed to issue command.\n\r");
    336                    
    337                 //while (AT26_IsBusy(pAt26));
    338                 //AT26_WaitReady(pAt26);
    339                   
    340                  // Make sure that write was without error
    341                  
    342                  /*
    343                  status = AT26_ReadStatus(pAt26);
    344                  
    345                  if ((status & AT26_STATUS_EPE) == AT26_STATUS_EPE_ERROR) {
    346          
    347                      return AT26_ERROR_PROGRAM;
    348                  }
    349                  */
    350                   
    351                  size -= writeSize;
   \   000000C8   0xE0566009         SUBS     R6,R6,R9
    352                  address += writeSize;
   \   000000CC   0xE0997007         ADDS     R7,R9,R7
   \   000000D0   0xEAFFFFE7         B        ??AT26_Write_4
    353              }
    354          
    355              return 0;
   \                     ??AT26_Write_5:
   \   000000D4   0xE3A00000         MOV      R0,#+0
   \   000000D8   0xE28DD010         ADD      SP,SP,#+16       ;; stack cleaning
   \   000000DC   0xE8BD47F0         POP      {R4-R10,LR}
   \   000000E0   0xE12FFF1E         BX       LR               ;; return
    356          }
    357          
    358          //------------------------------------------------------------------------------
    359          /// Reads data from the specified address on the serial flash.
    360          /// \param pAt26  Pointer to an AT26 driver instance.
    361          /// \param pData  Data buffer.
    362          /// \param size  Number of bytes to read.
    363          /// \param address  Read address.
    364          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    365          void AT26_Read(
    366              At26 *pAt26,
    367              unsigned char *pData,
    368              unsigned int size,
    369              unsigned int address)
    370          {
   \                     AT26_Read:
   \   00000000   0xE92D41FF         PUSH     {R0-R8,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
    371              unsigned char error;
    372              
    373               // Start a read operation
    374                error = AT26_SendCommand(pAt26, AT26_READ_ARRAY_LF, 4, pData, size, address, 0, 0);
   \   00000014   0xE3A00000         MOV      R0,#+0
   \   00000018   0xE58D000C         STR      R0,[SP, #+12]
   \   0000001C   0xE3A00000         MOV      R0,#+0
   \   00000020   0xE58D0008         STR      R0,[SP, #+8]
   \   00000024   0xE58D7004         STR      R7,[SP, #+4]
   \   00000028   0xE58D6000         STR      R6,[SP, #+0]
   \   0000002C   0xE1B03005         MOVS     R3,R5
   \   00000030   0xE3A02004         MOV      R2,#+4
   \   00000034   0xE3A01003         MOV      R1,#+3
   \   00000038   0xE1B00004         MOVS     R0,R4
   \   0000003C   0x........         BL       AT26_SendCommand
   \   00000040   0xE1B08000         MOVS     R8,R0
    375              ASSERT(!error, "-F- AT26_Read: Could not issue command.\n\r");
   \   00000044   0xE1B00008         MOVS     R0,R8
   \   00000048   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000004C   0xE3500000         CMP      R0,#+0
   \   00000050   0x0A000004         BEQ      ??AT26_Read_0
   \   00000054   0x........         LDR      R0,??DataTable11_1
   \   00000058   0x........         BL       printf
   \   0000005C   0x........         LDR      R0,??DataTable11_11
   \   00000060   0x........         BL       printf
   \                     ??AT26_Read_1:
   \   00000064   0xEAFFFFFE         B        ??AT26_Read_1
    376              while (AT26_IsBusy(pAt26));
   \                     ??AT26_Read_0:
   \   00000068   0xE1B00004         MOVS     R0,R4
   \   0000006C   0x........         BL       AT26_IsBusy
   \   00000070   0xE3500000         CMP      R0,#+0
   \   00000074   0x1AFFFFFB         BNE      ??AT26_Read_0
    377          }
   \   00000078   0xE8BD41FF         POP      {R0-R8,LR}
   \   0000007C   0xE12FFF1E         BX       LR               ;; return
    378          
    379          
    380          //------------------------------------------------------------------------------
    381          //
    382          //
    383          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    384          void SPI_Init(void)
    385          {
   \                     SPI_Init:
   \   00000000   0xE92D5000         PUSH     {R12,LR}
    386                 // Initialize the SPI and serial flash
    387            
    388              PIO_Configure(Spi_pins, PIO_LISTSIZE(Spi_pins));
   \   00000004   0xE3A01004         MOV      R1,#+4
   \   00000008   0x........         LDR      R0,??DataTable11_12
   \   0000000C   0x........         BL       PIO_Configure
    389              
    390              AIC_DisableIT(SPI_ID);
   \   00000010   0xE3A00005         MOV      R0,#+5
   \   00000014   0x........         BL       AIC_DisableIT
    391              
    392              AIC_ConfigureIT(SPI_ID, AT91C_AIC_PRIOR_LOWEST, ISR_Spi); 
   \   00000018   0x........         LDR      R2,??DataTable11_13
   \   0000001C   0xE3A01000         MOV      R1,#+0
   \   00000020   0xE3A00005         MOV      R0,#+5
   \   00000024   0x........         BL       AIC_ConfigureIT
    393              
    394              SPID_Configure(&spid, SPI_BASE, SPI_ID);
   \   00000028   0xE3A02005         MOV      R2,#+5
   \   0000002C   0xE3A014FF         MOV      R1,#-16777216
   \   00000030   0xE38118FE         ORR      R1,R1,#0xFE0000
   \   00000034   0x........         LDR      R0,??DataTable11
   \   00000038   0x........         BL       SPID_Configure
    395              
    396              AT26_Configure(&at26, &spid, SPI_CS);
   \   0000003C   0xE3A02000         MOV      R2,#+0
   \   00000040   0x........         LDR      R1,??DataTable11
   \   00000044   0x........         LDR      R0,??DataTable11_10
   \   00000048   0x........         BL       AT26_Configure
    397              
    398              AIC_EnableIT(SPI_ID);            
   \   0000004C   0xE3A00005         MOV      R0,#+5
   \   00000050   0x........         BL       AIC_EnableIT
    399             
    400              printf("SPI and AT26 drivers initialized\n\r");
   \   00000054   0x........         LDR      R0,??DataTable11_14
   \   00000058   0x........         BL       printf
    401          }
   \   0000005C   0xE8BD4001         POP      {R0,LR}
   \   00000060   0xE12FFF1E         BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11:
   \   00000000   0x........         DC32     spid

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_1:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_3:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_4:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_5:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_6:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_7:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_8:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_9:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_10:
   \   00000000   0x........         DC32     at26

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_11:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_12:
   \   00000000   0x........         DC32     Spi_pins

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_13:
   \   00000000   0x........         DC32     ISR_Spi

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable11_14:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x53 0x61          DC8 "Sanity check failed at %s:%d\012\015"
   \              0x6E 0x69    
   \              0x74 0x79    
   \              0x20 0x63    
   \              0x68 0x65    
   \              0x63 0x6B    
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x61 0x74    
   \              0x20 0x25    
   \              0x73 0x3A    
   \              0x25 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x46 0x3A          DC8 46H, 3AH, 5CH, 44H, 72H, 6FH, 70H, 62H
   \              0x5C 0x44    
   \              0x72 0x6F    
   \              0x70 0x62    
   \   00000008   0x6F 0x78          DC8 6FH, 78H, 5CH, 0C8H, 0B8H, 0BBH, 0E7H, 5CH
   \              0x5C 0xC8    
   \              0xB8 0xBB    
   \              0xE7 0x5C    
   \   00000010   0x4A 0x44          DC8 4AH, 44H, 53H, 5FH, 50H, 52H, 4FH, 5CH
   \              0x53 0x5F    
   \              0x50 0x52    
   \              0x4F 0x5C    
   \   00000018   0xB1 0xB9          DC8 0B1H, 0B9H, 0B3H, 0BBH, 20H, 0C7H, 0C1H, 0B7H
   \              0xB3 0xBB    
   \              0x20 0xC7    
   \              0xC1 0xB7    
   \   00000020   0xCE 0xC1          DC8 0CEH, 0C1H, 0A7H, 0C6H, 0AEH, 5CH, 0B4H, 0EBH
   \              0xA7 0xC6    
   \              0xAE 0x5C    
   \              0xB4 0xEB    
   \   00000028   0xB1 0xB8          DC8 0B1H, 0B8H, 20H, 0B8H, 0F0H, 0B3H, 0EBH, 0B7H
   \              0x20 0xB8    
   \              0xF0 0xB3    
   \              0xEB 0xB7    
   \   00000030   0xB9 0xC0          DC8 0B9H, 0C0H, 0CFH, 5CH, 0C7H, 0C1H, 0B7H, 0CEH
   \              0xCF 0x5C    
   \              0xC7 0xC1    
   \              0xB7 0xCE    
   \   00000038   0xB1 0xD7          DC8 0B1H, 0D7H, 0B7H, 0A5H, 5CH, 41H, 52H, 4DH
   \              0xB7 0xA5    
   \              0x5C 0x41    
   \              0x52 0x4D    
   \   00000040   0x5F 0x41          DC8 5FH, 41H, 54H, 39H, 31H, 73H, 61H, 6DH
   \              0x54 0x39    
   \              0x31 0x73    
   \              0x61 0x6D    
   \   00000048   0x37 0x73          DC8 37H, 73H, 65H, 35H, 31H, 32H, 5FH, 44H
   \              0x65 0x35    
   \              0x31 0x32    
   \              0x5F 0x44    
   \   00000050   0x61 0x67          DC8 61H, 67H, 75H, 5FH, 4CH, 45H, 44H, 28H
   \              0x75 0x5F    
   \              0x4C 0x45    
   \              0x44 0x28    
   \   00000058   0x46 0x44          DC8 46H, 44H, 49H, 29H, 5CH, 61H, 74H, 39H
   \              0x49 0x29    
   \              0x5C 0x61    
   \              0x74 0x39    
   \   00000060   0x31 0x73          DC8 31H, 73H, 61H, 6DH, 37H, 73H, 65H, 2DH
   \              0x61 0x6D    
   \              0x37 0x73    
   \              0x65 0x2D    
   \   00000068   0x65 0x6B          DC8 65H, 6BH, 5CH, 62H, 61H, 73H, 69H, 63H
   \              0x5C 0x62    
   \              0x61 0x73    
   \              0x69 0x63    
   \   00000070   0x2D 0x75          DC8 2DH, 75H, 73H, 61H, 72H, 74H, 2DH, 68H
   \              0x73 0x61    
   \              0x72 0x74    
   \              0x2D 0x68    
   \   00000078   0x77 0x2D          DC8 77H, 2DH, 68H, 61H, 6EH, 64H, 73H, 68H
   \              0x68 0x61    
   \              0x6E 0x64    
   \              0x73 0x68    
   \   00000080   0x61 0x6B          DC8 61H, 6BH, 69H, 6EH, 67H, 2DH, 70H, 72H
   \              0x69 0x6E    
   \              0x67 0x2D    
   \              0x70 0x72    
   \   00000088   0x6F 0x6A          DC8 6FH, 6AH, 65H, 63H, 74H, 5CH, 53H, 50H
   \              0x65 0x63    
   \              0x74 0x5C    
   \              0x53 0x50    
   \   00000090   0x49 0x5F          DC8 49H, 5FH, 46H, 55H, 4EH, 2EH, 63H, 0
   \              0x46 0x55    
   \              0x4E 0x2E    
   \              0x63 0x00    

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_WriteStatus: Failed to issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x53 0x74    
   \              0x61 0x74    
   \              0x75 0x73    
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_GetJedecId: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x47    
   \              0x65 0x74    
   \              0x4A 0x65    
   \              0x64 0x65    
   \              0x63 0x49    
   \              0x64 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x2D 0x57          DC8 "-W- AT26_EraseBlock: Device is protected.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x44    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x69 0x73    
   \              0x20 0x70    
   \              0x72 0x6F    
   \              0x74 0x65    
   \              0x63 0x74    
   \              0x65 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_ChipErase: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x43    
   \              0x68 0x69    
   \              0x70 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x3A 0x20    
   \              0x43 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x69 0x73    
   \              0x73 0x75    
   \              0x65 0x20    
   \              0x63 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x2E    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x2D 0x57          DC8 "-W- AT26_EraseBlock: Device is not ready.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x44    
   \              0x65 0x76    
   \              0x69 0x63    
   \              0x65 0x20    
   \              0x69 0x73    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_EraseBlock: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x45    
   \              0x72 0x61    
   \              0x73 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x2D 0x46          DC8 "-F- AT26_Read: Could not issue command.\012\015"
   \              0x2D 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x5F 0x52    
   \              0x65 0x61    
   \              0x64 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x69    
   \              0x73 0x73    
   \              0x75 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x2E 0x0A    
   \              0x0D 0x00    
   \   0000002A   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x53 0x50          DC8 "SPI and AT26 drivers initialized\012\015"
   \              0x49 0x20    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x41 0x54    
   \              0x32 0x36    
   \              0x20 0x64    
   \              0x72 0x69    
   \              0x76 0x65    
   \              0x72 0x73    
   \              0x20 0x69    
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000023   0x00               DC8 0
    402          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   AT26_EnableWrite
        32   -> AT26_IsBusy
        32   -> AT26_SendCommand
        32   -> printf
      40   AT26_EraseBlock
        40   -> AT26_EnableWrite
        40   -> AT26_IsBusy
        40   -> AT26_ReadStatus
        40   -> AT26_SendCommand
        40   -> AT26_WaitReady
        40   -> printf
      32   AT26_EraseChip
        32   -> AT26_EnableWrite
        32   -> AT26_IsBusy
        32   -> AT26_ReadStatus
        32   -> AT26_SendCommand
        32   -> AT26_WaitReady
        32   -> printf
      40   AT26_Read
        40   -> AT26_IsBusy
        40   -> AT26_SendCommand
        40   -> printf
      32   AT26_ReadJedecId
        32   -> AT26_IsBusy
        32   -> AT26_SendCommand
        32   -> printf
      32   AT26_ReadStatus
        32   -> AT26_IsBusy
        32   -> AT26_SendCommand
        32   -> printf
      16   AT26_Unprotect
        16   -> AT26_EnableWrite
        16   -> AT26_ReadStatus
        16   -> AT26_WriteStatus
        16   -> printf
      16   AT26_WaitReady
        16   -> AT26_ReadStatus
        16   -> printf
      48   AT26_Write
        48   -> AT26_SendCommand
        48   -> min
        48   -> printf
        48 __aeabi_uidivmod
      32   AT26_WriteStatus
        32   -> AT26_IsBusy
        32   -> AT26_SendCommand
        32   -> printf
       8   ISR_Spi
         8   -> SPID_Handler
       8   SPI_Init
         8   -> AIC_ConfigureIT
         8   -> AIC_DisableIT
         8   -> AIC_EnableIT
         8   -> AT26_Configure
         8   -> PIO_Configure
         8   -> SPID_Configure
         8   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable11_10
       4  ??DataTable11_11
       4  ??DataTable11_12
       4  ??DataTable11_13
       4  ??DataTable11_14
       4  ??DataTable11_2
       4  ??DataTable11_3
       4  ??DataTable11_4
       4  ??DataTable11_5
       4  ??DataTable11_6
       4  ??DataTable11_7
       4  ??DataTable11_8
       4  ??DataTable11_9
      16  ?_0
      32  ?_1
      36  ?_10
     152  ?_2
      52  ?_3
      48  ?_4
      44  ?_5
      48  ?_6
      44  ?_7
      48  ?_8
      44  ?_9
     132  AT26_EnableWrite
     256  AT26_EraseBlock
     220  AT26_EraseChip
     128  AT26_Read
     180  AT26_ReadJedecId
     136  AT26_ReadStatus
     156  AT26_Unprotect
      96  AT26_WaitReady
     228  AT26_Write
     168  AT26_WriteStatus
      20  ISR_Spi
     100  SPI_Init
      48  Spi_pins
      40  at26
      16  spid

 
    56 bytes in section .bss
    48 bytes in section .data
   564 bytes in section .rodata
 1 880 bytes in section .text
 
 1 880 bytes of CODE  memory
   564 bytes of CONST memory
   104 bytes of DATA  memory

Errors: none
Warnings: 4
