###############################################################################
#
# IAR ANSI C/C++ Compiler V7.30.4.8167/W32 for ARM        02/Jul/2015  09:27:34
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  arm
#    Endian       =  little
#    Source file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\nandflash\TranslatedNandFlash.c
#    Command line =  
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\nandflash\TranslatedNandFlash.c"
#        -D at91sam7se512 -D flash -D TRACE_LEVEL=4 -lC
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\"
#        --remarks --diag_suppress Pe826,Pe1375 -o
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\"
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little --cpu=ARM7TDMI
#        -e --fpu=None --dlib_config "C:\Program Files\IAR Systems\Embedded
#        Workbench 7.0\arm\INC\c\DLib_Config_Full.h" -I
#        "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/peripherals\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/memories\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/components\"
#        -I "F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\..\..\..\at91lib/boards/at91sam7se-ek\"
#        --interwork --cpu_mode arm -On --use_c++_inline
#    List file    =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\List\TranslatedNandFlash.lst
#    Object file  =  
#        F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구
#        모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91sam7se-ek\basic-usart-hw-handshaking-project\ewp\at91sam7se512_flash\Obj\TranslatedNandFlash.o
#
###############################################################################

F:\Dropbox\회사\JDS_PRO\국내 프로젝트\대구 모노레일\프로그램\ARM_AT91sam7se512_Dagu_LED(FDI)\at91lib\memories\nandflash\TranslatedNandFlash.c
      1          /* ----------------------------------------------------------------------------
      2           *         ATMEL Microcontroller Software Support 
      3           * ----------------------------------------------------------------------------
      4           * Copyright (c) 2008, Atmel Corporation
      5           *
      6           * All rights reserved.
      7           *
      8           * Redistribution and use in source and binary forms, with or without
      9           * modification, are permitted provided that the following conditions are met:
     10           *
     11           * - Redistributions of source code must retain the above copyright notice,
     12           * this list of conditions and the disclaimer below.
     13           *
     14           * Atmel's name may not be used to endorse or promote products derived from
     15           * this software without specific prior written permission.
     16           *
     17           * DISCLAIMER: THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR
     18           * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     19           * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
     20           * DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR ANY DIRECT, INDIRECT,
     21           * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
     22           * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
     23           * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
     24           * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     25           * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
     26           * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     27           * ----------------------------------------------------------------------------
     28           */
     29          
     30          //------------------------------------------------------------------------------
     31          //         Headers
     32          //------------------------------------------------------------------------------
     33          
     34          #include "TranslatedNandFlash.h"
     35          #include <utility/trace.h>
     36          #include <utility/assert.h>
     37          #include <utility/math.h>
     38          
     39          #include <string.h>
     40          
     41          //------------------------------------------------------------------------------
     42          //         Internal definitions
     43          //------------------------------------------------------------------------------
     44          
     45          /// Casts
     46          #define MAPPED(translated)          ((struct MappedNandFlash *) translated)
     47          #define MANAGED(translated)         ((struct ManagedNandFlash *) translated)
     48          #define ECC(translated)             ((struct EccNandFlash *) translated)
     49          #define RAW(translated)             ((struct RawNandFlash *) translated)
     50          #define MODEL(translated)           ((struct NandFlashModel *) translated)
     51          
     52          /// Minimum number of blocks that should be kept unallocated
     53          #define MINNUMUNALLOCATEDBLOCKS     32
     54          
     55          /// Maximum allowed erase count difference
     56          #define MAXERASEDIFFERENCE          5
     57          
     58          //------------------------------------------------------------------------------
     59          //         Internal functions
     60          //------------------------------------------------------------------------------
     61          
     62          //------------------------------------------------------------------------------
     63          /// Returns 1 if there are enough free blocks to perform a single block
     64          /// allocation; otherwise returns 0.
     65          /// \param translated  Pointer to a TranslatedNandFlash instance.
     66          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     67          static unsigned char BlockCanBeAllocated(
     68              const struct TranslatedNandFlash *translated)
     69          {
   \                     BlockCanBeAllocated:
   \   00000000   0xE92D4070         PUSH     {R4-R6,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
     70              unsigned short count;
     71          
     72              // Count number of free and dirty blocks (unallocated blocks)
     73              count = ManagedNandFlash_CountBlocks(MANAGED(translated), NandBlockStatus_DIRTY)
     74                      + ManagedNandFlash_CountBlocks(MANAGED(translated), NandBlockStatus_FREE);
   \   00000008   0xE3A01008         MOV      R1,#+8
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       ManagedNandFlash_CountBlocks
   \   00000014   0xE1B06000         MOVS     R6,R0
   \   00000018   0xE3A0100E         MOV      R1,#+14
   \   0000001C   0xE1B00004         MOVS     R0,R4
   \   00000020   0x........         BL       ManagedNandFlash_CountBlocks
   \   00000024   0xE0900006         ADDS     R0,R0,R6
   \   00000028   0xE1B05000         MOVS     R5,R0
     75          
     76              // Check that count is greater than minimum number of unallocated blocks
     77              if (count > MINNUMUNALLOCATEDBLOCKS) {
   \   0000002C   0xE1B00005         MOVS     R0,R5
   \   00000030   0xE1A00800         LSL      R0,R0,#+16
   \   00000034   0xE1B00820         LSRS     R0,R0,#+16
   \   00000038   0xE3500021         CMP      R0,#+33
   \   0000003C   0xBA000001         BLT      ??BlockCanBeAllocated_0
     78          
     79                  return 1;
   \   00000040   0xE3A00001         MOV      R0,#+1
   \   00000044   0xEA000000         B        ??BlockCanBeAllocated_1
     80              }
     81              else {
     82          
     83                  return 0;
   \                     ??BlockCanBeAllocated_0:
   \   00000048   0xE3A00000         MOV      R0,#+0
   \                     ??BlockCanBeAllocated_1:
   \   0000004C   0xE8BD4070         POP      {R4-R6,LR}
   \   00000050   0xE12FFF1E         BX       LR               ;; return
     84              }
     85          }
     86          
     87          //------------------------------------------------------------------------------
     88          /// Returns 1 if the given page inside the currently written block is clean (has
     89          /// not been written yet); otherwise returns 0.
     90          /// \param translated  Pointer to a TranslatedNandFlash instance.
     91          /// \param page  Page number.
     92          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
     93          static unsigned char PageIsClean(
     94              const struct TranslatedNandFlash *translated,
     95              unsigned short page)
     96          {
   \                     PageIsClean:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
     97              ASSERT(page < NandFlashModel_GetBlockSizeInPages(MODEL(translated)),
     98                     "PageIsClean: Page out-of-bounds\n\r");
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       NandFlashModel_GetBlockSizeInPages
   \   00000014   0xE1A05805         LSL      R5,R5,#+16
   \   00000018   0xE1B05825         LSRS     R5,R5,#+16
   \   0000001C   0xE1550000         CMP      R5,R0
   \   00000020   0x3A000004         BCC      ??PageIsClean_0
   \   00000024   0x........         LDR      R0,??DataTable6
   \   00000028   0x........         BL       printf
   \   0000002C   0x........         LDR      R0,??DataTable6_1
   \   00000030   0x........         BL       printf
   \                     ??PageIsClean_1:
   \   00000034   0xEAFFFFFE         B        ??PageIsClean_1
     99          
    100              return ((translated->currentBlockPageStatuses[page / 8] >> (page % 8)) & 1) == 0;
   \                     ??PageIsClean_0:
   \   00000038   0xE1B00005         MOVS     R0,R5
   \   0000003C   0xE1A00800         LSL      R0,R0,#+16
   \   00000040   0xE1B00820         LSRS     R0,R0,#+16
   \   00000044   0xE3A01008         MOV      R1,#+8
   \   00000048   0x........         BL       __aeabi_idiv
   \   0000004C   0xE0900004         ADDS     R0,R0,R4
   \   00000050   0xE3A0103C         MOV      R1,#+60
   \   00000054   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000058   0xE7D14000         LDRB     R4,[R1, +R0]
   \   0000005C   0xE1A05805         LSL      R5,R5,#+16
   \   00000060   0xE1B05825         LSRS     R5,R5,#+16
   \   00000064   0xE1B00005         MOVS     R0,R5
   \   00000068   0xE3A01008         MOV      R1,#+8
   \   0000006C   0x........         BL       __aeabi_idivmod
   \   00000070   0xE1B00154         ASRS     R0,R4,R1
   \   00000074   0xE2100001         ANDS     R0,R0,#0x1
   \   00000078   0xE2300001         EORS     R0,R0,#0x1
   \   0000007C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000080   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   00000084   0xE12FFF1E         BX       LR               ;; return
    101          }
    102          
    103          //------------------------------------------------------------------------------
    104          /// Marks the given page as being dirty (i.e. written).
    105          /// \param translated  Pointer to a TranslatedNandFlash instance.
    106          /// \param page  Page number.
    107          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    108          static void MarkPageDirty(
    109              struct TranslatedNandFlash *translated,
    110              unsigned short page)
    111          {
   \                     MarkPageDirty:
   \   00000000   0xE92D43F8         PUSH     {R3-R9,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    112              ASSERT(page < NandFlashModel_GetBlockSizeInPages(MODEL(translated)),
    113                     "PageIsClean: Page out-of-bounds\n\r");
   \   0000000C   0xE1B00004         MOVS     R0,R4
   \   00000010   0x........         BL       NandFlashModel_GetBlockSizeInPages
   \   00000014   0xE1A05805         LSL      R5,R5,#+16
   \   00000018   0xE1B05825         LSRS     R5,R5,#+16
   \   0000001C   0xE1550000         CMP      R5,R0
   \   00000020   0x3A000004         BCC      ??MarkPageDirty_0
   \   00000024   0x........         LDR      R0,??DataTable6
   \   00000028   0x........         BL       printf
   \   0000002C   0x........         LDR      R0,??DataTable6_1
   \   00000030   0x........         BL       printf
   \                     ??MarkPageDirty_1:
   \   00000034   0xEAFFFFFE         B        ??MarkPageDirty_1
    114          
    115              translated->currentBlockPageStatuses[page / 8] |= 1 << (page % 8);
   \                     ??MarkPageDirty_0:
   \   00000038   0xE1B00005         MOVS     R0,R5
   \   0000003C   0xE1A00800         LSL      R0,R0,#+16
   \   00000040   0xE1B00820         LSRS     R0,R0,#+16
   \   00000044   0xE3A01008         MOV      R1,#+8
   \   00000048   0x........         BL       __aeabi_idiv
   \   0000004C   0xE0906004         ADDS     R6,R0,R4
   \   00000050   0xE3A0703C         MOV      R7,#+60
   \   00000054   0xE3877D60         ORR      R7,R7,#0x1800
   \   00000058   0xE1B00005         MOVS     R0,R5
   \   0000005C   0xE1A00800         LSL      R0,R0,#+16
   \   00000060   0xE1B00820         LSRS     R0,R0,#+16
   \   00000064   0xE3A01008         MOV      R1,#+8
   \   00000068   0x........         BL       __aeabi_idiv
   \   0000006C   0xE0900004         ADDS     R0,R0,R4
   \   00000070   0xE3A0103C         MOV      R1,#+60
   \   00000074   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000078   0xE7D18000         LDRB     R8,[R1, +R0]
   \   0000007C   0xE3A09001         MOV      R9,#+1
   \   00000080   0xE1B00005         MOVS     R0,R5
   \   00000084   0xE1A00800         LSL      R0,R0,#+16
   \   00000088   0xE1B00820         LSRS     R0,R0,#+16
   \   0000008C   0xE3A01008         MOV      R1,#+8
   \   00000090   0x........         BL       __aeabi_idivmod
   \   00000094   0xE1B00119         LSLS     R0,R9,R1
   \   00000098   0xE1900008         ORRS     R0,R0,R8
   \   0000009C   0xE7C70006         STRB     R0,[R7, +R6]
    116          }
   \   000000A0   0xE8BD43F1         POP      {R0,R4-R9,LR}
   \   000000A4   0xE12FFF1E         BX       LR               ;; return
    117          
    118          //------------------------------------------------------------------------------
    119          /// Marks all pages as being clean.
    120          /// \param translated  Pointer to a TranslatedNandFlash instance.
    121          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    122          static void MarkAllPagesClean(struct TranslatedNandFlash *translated)
    123          {
   \                     MarkAllPagesClean:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    124              memset(translated->currentBlockPageStatuses, 0,
    125                     sizeof(translated->currentBlockPageStatuses));
   \   00000008   0xE3A05008         MOV      R5,#+8
   \   0000000C   0xE3A06000         MOV      R6,#+0
   \   00000010   0xE3A0003C         MOV      R0,#+60
   \   00000014   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000018   0xE0907004         ADDS     R7,R0,R4
   \   0000001C   0xE1B02006         MOVS     R2,R6
   \   00000020   0xE1B01005         MOVS     R1,R5
   \   00000024   0xE1B00007         MOVS     R0,R7
   \   00000028   0x........         BL       __aeabi_memset
    126          }
   \   0000002C   0xE8BD40F1         POP      {R0,R4-R7,LR}
   \   00000030   0xE12FFF1E         BX       LR               ;; return
    127          
    128          //------------------------------------------------------------------------------
    129          /// Allocates the best-fitting physical block for the given logical block.
    130          /// Returns 0 if successful; otherwise returns NandCommon_ERROR_NOBLOCKFOUND if
    131          /// there are no more free blocks, or a NandCommon_ERROR code.
    132          /// \param translated  Pointer to a TranslatedNandFlash instance.
    133          /// \param block  Logical block number.
    134          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    135          static unsigned char AllocateBlock(
    136              struct TranslatedNandFlash *translated,
    137              unsigned short block)
    138          {
   \                     AllocateBlock:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    139              unsigned short freeBlock, liveBlock;
    140              unsigned char error;
    141              signed int eraseDifference;
    142          
    143              TRACE_DEBUG("Allocating a new block\n\r");
    144          
    145              // Find youngest free block and youngest live block
    146              if (ManagedNandFlash_FindYoungestBlock(MANAGED(translated),
    147                                                     NandBlockStatus_FREE,
    148                                                     &freeBlock)) {
   \   0000000C   0xE1B0200D         MOVS     R2,SP
   \   00000010   0xE3A0100E         MOV      R1,#+14
   \   00000014   0xE1B00004         MOVS     R0,R4
   \   00000018   0x........         BL       ManagedNandFlash_FindYoungestBlock
   \   0000001C   0xE3500000         CMP      R0,#+0
   \   00000020   0x0A000003         BEQ      ??AllocateBlock_0
    149          
    150                  TRACE_ERROR("AllocateBlock: Could not find a free block\n\r");
   \   00000024   0x........         LDR      R0,??DataTable6_2
   \   00000028   0x........         BL       printf
    151                  return NandCommon_ERROR_NOBLOCKFOUND;
   \   0000002C   0xE3A00004         MOV      R0,#+4
   \   00000030   0xEA000053         B        ??AllocateBlock_1
    152              }
    153          
    154              // If this is the last free block, save the logical mapping in it and
    155              // clean dirty blocks
    156              TRACE_DEBUG("Number of FREE blocks: %d\n\r",
    157                        ManagedNandFlash_CountBlocks(MANAGED(translated), NandBlockStatus_FREE));
    158              if (ManagedNandFlash_CountBlocks(MANAGED(translated),
    159                                               NandBlockStatus_FREE) == 1) {
   \                     ??AllocateBlock_0:
   \   00000034   0xE3A0100E         MOV      R1,#+14
   \   00000038   0xE1B00004         MOVS     R0,R4
   \   0000003C   0x........         BL       ManagedNandFlash_CountBlocks
   \   00000040   0xE3500001         CMP      R0,#+1
   \   00000044   0x1A00001E         BNE      ??AllocateBlock_2
    160          
    161                  // Save mapping and clean dirty blocks
    162                  TRACE_DEBUG("Last FREE block, cleaning up ...\n\r");
    163          
    164                  error = MappedNandFlash_SaveLogicalMapping(MAPPED(translated), freeBlock);
   \   00000048   0xE1DD10B0         LDRH     R1,[SP, #+0]
   \   0000004C   0xE1B00004         MOVS     R0,R4
   \   00000050   0x........         BL       MappedNandFlash_SaveLogicalMapping
   \   00000054   0xE1B07000         MOVS     R7,R0
    165                  if (error) {
   \   00000058   0xE1B00007         MOVS     R0,R7
   \   0000005C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000060   0xE3500000         CMP      R0,#+0
   \   00000064   0x0A000004         BEQ      ??AllocateBlock_3
    166          
    167                      TRACE_ERROR("AllocateBlock: Failed to save mapping\n\r");
   \   00000068   0x........         LDR      R0,??DataTable6_3
   \   0000006C   0x........         BL       printf
    168                      return error;
   \   00000070   0xE1B00007         MOVS     R0,R7
   \   00000074   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000078   0xEA000041         B        ??AllocateBlock_1
    169                  }
    170                  error = ManagedNandFlash_EraseDirtyBlocks(MANAGED(translated));
   \                     ??AllocateBlock_3:
   \   0000007C   0xE1B00004         MOVS     R0,R4
   \   00000080   0x........         BL       ManagedNandFlash_EraseDirtyBlocks
   \   00000084   0xE1B07000         MOVS     R7,R0
    171                  if (error) {
   \   00000088   0xE1B00007         MOVS     R0,R7
   \   0000008C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000090   0xE3500000         CMP      R0,#+0
   \   00000094   0x0A000004         BEQ      ??AllocateBlock_4
    172          
    173                      TRACE_ERROR("AllocatedBlock: Failed to erase dirty blocks\n\r");
   \   00000098   0x........         LDR      R0,??DataTable6_4
   \   0000009C   0x........         BL       printf
    174                      return error;
   \   000000A0   0xE1B00007         MOVS     R0,R7
   \   000000A4   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000A8   0xEA000035         B        ??AllocateBlock_1
    175                  }
    176          
    177                  // Allocate new block
    178                  return AllocateBlock(translated, block);
   \                     ??AllocateBlock_4:
   \   000000AC   0xE1B01005         MOVS     R1,R5
   \   000000B0   0xE1A01801         LSL      R1,R1,#+16
   \   000000B4   0xE1B01821         LSRS     R1,R1,#+16
   \   000000B8   0xE1B00004         MOVS     R0,R4
   \   000000BC   0x........         BL       AllocateBlock
   \   000000C0   0xEA00002F         B        ??AllocateBlock_1
    179              }
    180          
    181              // Find youngest LIVE block to check the erase count difference
    182              if (!ManagedNandFlash_FindYoungestBlock(MANAGED(translated),
    183                                                      NandBlockStatus_LIVE,
    184                                                      &liveBlock)) {
   \                     ??AllocateBlock_2:
   \   000000C4   0xE28D2002         ADD      R2,SP,#+2
   \   000000C8   0xE3A0100C         MOV      R1,#+12
   \   000000CC   0xE1B00004         MOVS     R0,R4
   \   000000D0   0x........         BL       ManagedNandFlash_FindYoungestBlock
   \   000000D4   0xE3500000         CMP      R0,#+0
   \   000000D8   0x1A000022         BNE      ??AllocateBlock_5
    185          
    186                  // Calculate erase count difference
    187                  TRACE_DEBUG("Free block erase count = %d\n\r", MANAGED(translated)->blockStatuses[freeBlock].eraseCount);
    188                  TRACE_DEBUG("Live block erase count = %d\n\r", MANAGED(translated)->blockStatuses[liveBlock].eraseCount);
    189                  eraseDifference = absv(MANAGED(translated)->blockStatuses[freeBlock].eraseCount
    190                                        - MANAGED(translated)->blockStatuses[liveBlock].eraseCount);
   \   000000DC   0xE1DD00B0         LDRH     R0,[SP, #+0]
   \   000000E0   0xE1B00100         LSLS     R0,R0,#+2
   \   000000E4   0xE0900004         ADDS     R0,R0,R4
   \   000000E8   0xE5900030         LDR      R0,[R0, #+48]
   \   000000EC   0xE1B00220         LSRS     R0,R0,#+4
   \   000000F0   0xE1DD10B2         LDRH     R1,[SP, #+2]
   \   000000F4   0xE1B01101         LSLS     R1,R1,#+2
   \   000000F8   0xE0911004         ADDS     R1,R1,R4
   \   000000FC   0xE5911030         LDR      R1,[R1, #+48]
   \   00000100   0xE0500221         SUBS     R0,R0,R1, LSR #+4
   \   00000104   0x........         BL       absv
   \   00000108   0xE1B06000         MOVS     R6,R0
    191          
    192                  // Check if it is too big
    193                  if (eraseDifference > MAXERASEDIFFERENCE) {
   \   0000010C   0xE3560006         CMP      R6,#+6
   \   00000110   0xBA000014         BLT      ??AllocateBlock_5
    194          
    195                      TRACE_WARNING("Erase difference too big, switching blocks\n\r");
   \   00000114   0x........         LDR      R0,??DataTable6_5
   \   00000118   0x........         BL       printf
    196                      MappedNandFlash_Map(
    197                          MAPPED(translated),
    198                          MappedNandFlash_PhysicalToLogical(
    199                              MAPPED(translated),
    200                              liveBlock),
    201                          freeBlock);
   \   0000011C   0xE1DD10B2         LDRH     R1,[SP, #+2]
   \   00000120   0xE1B00004         MOVS     R0,R4
   \   00000124   0x........         BL       MappedNandFlash_PhysicalToLogical
   \   00000128   0xE1DD20B0         LDRH     R2,[SP, #+0]
   \   0000012C   0xE1B01000         MOVS     R1,R0
   \   00000130   0xE1A01801         LSL      R1,R1,#+16
   \   00000134   0xE1B01821         LSRS     R1,R1,#+16
   \   00000138   0xE1B00004         MOVS     R0,R4
   \   0000013C   0x........         BL       MappedNandFlash_Map
    202                      ManagedNandFlash_CopyBlock(MANAGED(translated),
    203                                                 liveBlock,
    204                                                 freeBlock);
   \   00000140   0xE1DD20B0         LDRH     R2,[SP, #+0]
   \   00000144   0xE1DD10B2         LDRH     R1,[SP, #+2]
   \   00000148   0xE1B00004         MOVS     R0,R4
   \   0000014C   0x........         BL       ManagedNandFlash_CopyBlock
    205          
    206                      // Allocate a new block
    207                      return AllocateBlock(translated, block);
   \   00000150   0xE1B01005         MOVS     R1,R5
   \   00000154   0xE1A01801         LSL      R1,R1,#+16
   \   00000158   0xE1B01821         LSRS     R1,R1,#+16
   \   0000015C   0xE1B00004         MOVS     R0,R4
   \   00000160   0x........         BL       AllocateBlock
   \   00000164   0xEA000006         B        ??AllocateBlock_1
    208                  }
    209              }
    210          
    211              // Map block
    212              TRACE_DEBUG("Allocating PB#%d for LB#%d\n\r", freeBlock, block);
    213              MappedNandFlash_Map(MAPPED(translated), block, freeBlock);
   \                     ??AllocateBlock_5:
   \   00000168   0xE1DD20B0         LDRH     R2,[SP, #+0]
   \   0000016C   0xE1B01005         MOVS     R1,R5
   \   00000170   0xE1A01801         LSL      R1,R1,#+16
   \   00000174   0xE1B01821         LSRS     R1,R1,#+16
   \   00000178   0xE1B00004         MOVS     R0,R4
   \   0000017C   0x........         BL       MappedNandFlash_Map
    214          
    215              return 0;
   \   00000180   0xE3A00000         MOV      R0,#+0
   \                     ??AllocateBlock_1:
   \   00000184   0xE8BD40F2         POP      {R1,R4-R7,LR}
   \   00000188   0xE12FFF1E         BX       LR               ;; return
    216          }
    217          
    218          //------------------------------------------------------------------------------
    219          //         Exported functions
    220          //------------------------------------------------------------------------------
    221          
    222          //------------------------------------------------------------------------------
    223          /// Initializes a TranslatedNandFlash instance.
    224          /// Returns 0 if successful; otherwise returns a NandCommon_ERROR_xxx code.
    225          /// \param translated  Pointer to a TranslatedNandFlash instance.
    226          /// \param model  Pointer to the underlying nand chip model. Can be 0.
    227          /// \param commandAddress  Address at which commands are sent.
    228          /// \param addressAddress  Address at which addresses are sent.
    229          /// \param dataAddress  Address at which data is sent.
    230          /// \param pinChipEnable  Pin controlling the CE signal of the NandFlash.
    231          /// \param pinReadyBusy  Pin used to monitor the ready/busy signal of the Nand.
    232          /// \param baseBlock Basic physical block address of mapped area.
    233          /// \param sizeInBlocks Number of blocks that is mapped.
    234          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    235          unsigned char TranslatedNandFlash_Initialize(
    236              struct TranslatedNandFlash *translated,
    237              const struct NandFlashModel *model,
    238              unsigned int commandAddress,
    239              unsigned int addressAddress,
    240              unsigned int dataAddress,
    241              const Pin pinChipEnable,
    242              const Pin pinReadyBusy,
    243              unsigned short baseBlock,
    244              unsigned short sizeInBlocks)
    245          {
   \                     TranslatedNandFlash_Initialize:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE24DD028         SUB      SP,SP,#+40
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05001         MOVS     R5,R1
   \   00000010   0xE1B06002         MOVS     R6,R2
   \   00000014   0xE1B07003         MOVS     R7,R3
   \   00000018   0xE59D8048         LDR      R8,[SP, #+72]
   \   0000001C   0xE1DD96B4         LDRH     R9,[SP, #+100]
   \   00000020   0xE1DDA6B8         LDRH     R10,[SP, #+104]
    246              translated->currentLogicalBlock = -1;
   \   00000024   0xE3E00000         MVN      R0,#+0
   \   00000028   0xE3A01038         MOV      R1,#+56
   \   0000002C   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000030   0xE18100B4         STRH     R0,[R1, +R4]
    247              translated->previousPhysicalBlock = -1;
   \   00000034   0xE3E00000         MVN      R0,#+0
   \   00000038   0xE3A0103A         MOV      R1,#+58
   \   0000003C   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000040   0xE18100B4         STRH     R0,[R1, +R4]
    248              MarkAllPagesClean(translated);
   \   00000044   0xE1B00004         MOVS     R0,R4
   \   00000048   0x........         BL       MarkAllPagesClean
    249          
    250              // Initialize MappedNandFlash
    251              return MappedNandFlash_Initialize(MAPPED(translated),
    252                                                model,
    253                                                commandAddress,
    254                                                addressAddress,
    255                                                dataAddress,
    256                                                pinChipEnable,
    257                                                pinReadyBusy,
    258                                                baseBlock,
    259                                                sizeInBlocks);
   \   0000004C   0xE1B0000A         MOVS     R0,R10
   \   00000050   0xE1A00800         LSL      R0,R0,#+16
   \   00000054   0xE1B00820         LSRS     R0,R0,#+16
   \   00000058   0xE58D0020         STR      R0,[SP, #+32]
   \   0000005C   0xE1B00009         MOVS     R0,R9
   \   00000060   0xE1A00800         LSL      R0,R0,#+16
   \   00000064   0xE1B00820         LSRS     R0,R0,#+16
   \   00000068   0xE58D001C         STR      R0,[SP, #+28]
   \   0000006C   0xE28D0058         ADD      R0,SP,#+88
   \   00000070   0xE28D2010         ADD      R2,SP,#+16
   \   00000074   0xE8B0000A         LDM      R0!,{R1,R3}
   \   00000078   0xE8A2000A         STM      R2!,{R1,R3}
   \   0000007C   0xE5903000         LDR      R3,[R0, #0]
   \   00000080   0xE5823000         STR      R3,[R2, #+0]
   \   00000084   0xE2500008         SUBS     R0,R0,#+8
   \   00000088   0xE2522008         SUBS     R2,R2,#+8
   \   0000008C   0xE28D004C         ADD      R0,SP,#+76
   \   00000090   0xE28D2004         ADD      R2,SP,#+4
   \   00000094   0xE8B0000A         LDM      R0!,{R1,R3}
   \   00000098   0xE8A2000A         STM      R2!,{R1,R3}
   \   0000009C   0xE5903000         LDR      R3,[R0, #0]
   \   000000A0   0xE5823000         STR      R3,[R2, #+0]
   \   000000A4   0xE2500008         SUBS     R0,R0,#+8
   \   000000A8   0xE2522008         SUBS     R2,R2,#+8
   \   000000AC   0xE58D8000         STR      R8,[SP, #+0]
   \   000000B0   0xE1B03007         MOVS     R3,R7
   \   000000B4   0xE1B02006         MOVS     R2,R6
   \   000000B8   0xE1B01005         MOVS     R1,R5
   \   000000BC   0xE1B00004         MOVS     R0,R4
   \   000000C0   0x........         BL       MappedNandFlash_Initialize
   \   000000C4   0xE28DD028         ADD      SP,SP,#+40       ;; stack cleaning
   \   000000C8   0xE8BD47F0         POP      {R4-R10,LR}
   \   000000CC   0xE12FFF1E         BX       LR               ;; return
    260          }
    261          
    262          //------------------------------------------------------------------------------
    263          /// Reads the data and/or the spare area of a page on a translated nandflash.
    264          /// If the block is not currently mapped but could be (i.e. there are available
    265          /// physical blocks), then the data/spare is filled with 0xFF.
    266          /// Returns 0 if successful; otherwise returns NandCommon_ERROR_NOMOREBLOCKS
    267          /// if no more block can be allocated, or a NandCommon_ERROR code.
    268          /// \param translated  Pointer to a TranslatedNandFlash instance.
    269          /// \param block  Logical block number.
    270          /// \param page  Number of page to read inside logical block.
    271          /// \param data  Data area buffer, can be 0.
    272          /// \param spare  Spare area buffer, can be 0.
    273          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    274          unsigned char TranslatedNandFlash_ReadPage(
    275              const struct TranslatedNandFlash *translated,
    276              unsigned short block,
    277              unsigned short page,
    278              void *data,
    279              void *spare)
    280          {
   \                     TranslatedNandFlash_ReadPage:
   \   00000000   0xE92D4FF8         PUSH     {R3-R11,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
   \   0000000C   0xE1B06002         MOVS     R6,R2
   \   00000010   0xE1B07003         MOVS     R7,R3
   \   00000014   0xE59DB028         LDR      R11,[SP, #+40]
    281              unsigned char error;
    282          
    283              TRACE_INFO("TranslatedNandFlash_ReadPage(B#%d:P#%d)\n\r", block, page);
   \   00000018   0xE1B02006         MOVS     R2,R6
   \   0000001C   0xE1A02802         LSL      R2,R2,#+16
   \   00000020   0xE1B02822         LSRS     R2,R2,#+16
   \   00000024   0xE1B01005         MOVS     R1,R5
   \   00000028   0xE1A01801         LSL      R1,R1,#+16
   \   0000002C   0xE1B01821         LSRS     R1,R1,#+16
   \   00000030   0x........         LDR      R0,??DataTable6_6
   \   00000034   0x........         BL       printf
    284          
    285              // If the page to read is in the current block, there is a previous physical
    286              // block and the page is clean -> read the page in the old block since the
    287              // new one does not contain meaningful data
    288              if ((block == translated->currentLogicalBlock)
    289                  && (translated->previousPhysicalBlock != -1)
    290                  && (PageIsClean(translated, page))) {
   \   00000038   0xE1B00005         MOVS     R0,R5
   \   0000003C   0xE1A00800         LSL      R0,R0,#+16
   \   00000040   0xE1B00820         LSRS     R0,R0,#+16
   \   00000044   0xE3A01038         MOV      R1,#+56
   \   00000048   0xE3811D60         ORR      R1,R1,#0x1800
   \   0000004C   0xE19110F4         LDRSH    R1,[R1, +R4]
   \   00000050   0xE1500001         CMP      R0,R1
   \   00000054   0x1A000018         BNE      ??TranslatedNandFlash_ReadPage_0
   \   00000058   0xE3A0003A         MOV      R0,#+58
   \   0000005C   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000060   0xE19000F4         LDRSH    R0,[R0, +R4]
   \   00000064   0xE3700001         CMN      R0,#+1
   \   00000068   0x0A000013         BEQ      ??TranslatedNandFlash_ReadPage_0
   \   0000006C   0xE1B01006         MOVS     R1,R6
   \   00000070   0xE1A01801         LSL      R1,R1,#+16
   \   00000074   0xE1B01821         LSRS     R1,R1,#+16
   \   00000078   0xE1B00004         MOVS     R0,R4
   \   0000007C   0x........         BL       PageIsClean
   \   00000080   0xE3500000         CMP      R0,#+0
   \   00000084   0x0A00000C         BEQ      ??TranslatedNandFlash_ReadPage_0
    291          
    292                  TRACE_DEBUG("Reading page from current block\n\r");
    293                  return ManagedNandFlash_ReadPage(MANAGED(translated),
    294                                                   translated->previousPhysicalBlock,
    295                                                   page,
    296                                                   data,
    297                                                   spare);
   \   00000088   0xE58DB000         STR      R11,[SP, #+0]
   \   0000008C   0xE1B03007         MOVS     R3,R7
   \   00000090   0xE1B02006         MOVS     R2,R6
   \   00000094   0xE1A02802         LSL      R2,R2,#+16
   \   00000098   0xE1B02822         LSRS     R2,R2,#+16
   \   0000009C   0xE3A0003A         MOV      R0,#+58
   \   000000A0   0xE3800D60         ORR      R0,R0,#0x1800
   \   000000A4   0xE19010B4         LDRH     R1,[R0, +R4]
   \   000000A8   0xE1A01801         LSL      R1,R1,#+16
   \   000000AC   0xE1B01821         LSRS     R1,R1,#+16
   \   000000B0   0xE1B00004         MOVS     R0,R4
   \   000000B4   0x........         BL       ManagedNandFlash_ReadPage
   \   000000B8   0xEA00003D         B        ??TranslatedNandFlash_ReadPage_1
    298              }
    299              else {
    300          
    301                  // Try to read the page from the logical block
    302                  error = MappedNandFlash_ReadPage(MAPPED(translated), block, page, data, spare);
   \                     ??TranslatedNandFlash_ReadPage_0:
   \   000000BC   0xE58DB000         STR      R11,[SP, #+0]
   \   000000C0   0xE1B03007         MOVS     R3,R7
   \   000000C4   0xE1B02006         MOVS     R2,R6
   \   000000C8   0xE1A02802         LSL      R2,R2,#+16
   \   000000CC   0xE1B02822         LSRS     R2,R2,#+16
   \   000000D0   0xE1B01005         MOVS     R1,R5
   \   000000D4   0xE1A01801         LSL      R1,R1,#+16
   \   000000D8   0xE1B01821         LSRS     R1,R1,#+16
   \   000000DC   0xE1B00004         MOVS     R0,R4
   \   000000E0   0x........         BL       MappedNandFlash_ReadPage
   \   000000E4   0xE1B08000         MOVS     R8,R0
    303              
    304                  // Block was not mapped
    305                  if (error == NandCommon_ERROR_BLOCKNOTMAPPED) {
   \   000000E8   0xE1B00008         MOVS     R0,R8
   \   000000EC   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000F0   0xE3500002         CMP      R0,#+2
   \   000000F4   0x1A000026         BNE      ??TranslatedNandFlash_ReadPage_2
    306              
    307                      ASSERT(!spare, "Cannot read the spare information of an unmapped block\n\r");
   \   000000F8   0xE35B0000         CMP      R11,#+0
   \   000000FC   0x0A000004         BEQ      ??TranslatedNandFlash_ReadPage_3
   \   00000100   0x........         LDR      R0,??DataTable6
   \   00000104   0x........         BL       printf
   \   00000108   0x........         LDR      R0,??DataTable6_7
   \   0000010C   0x........         BL       printf
   \                     ??TranslatedNandFlash_ReadPage_4:
   \   00000110   0xEAFFFFFE         B        ??TranslatedNandFlash_ReadPage_4
    308              
    309                      // Check if a block can be allocated
    310                      if (BlockCanBeAllocated(translated)) {
   \                     ??TranslatedNandFlash_ReadPage_3:
   \   00000114   0xE1B00004         MOVS     R0,R4
   \   00000118   0x........         BL       BlockCanBeAllocated
   \   0000011C   0xE3500000         CMP      R0,#+0
   \   00000120   0x0A000014         BEQ      ??TranslatedNandFlash_ReadPage_5
    311              
    312                          // Return 0xFF in buffers with no error
    313                          TRACE_DEBUG("Block #%d is not mapped but can be allocated, filling buffer with 0xFF\n\r", block);
    314                          if (data) {
   \   00000124   0xE3570000         CMP      R7,#+0
   \   00000128   0x0A000007         BEQ      ??TranslatedNandFlash_ReadPage_6
    315              
    316                              memset(data, 0xFF, NandFlashModel_GetPageDataSize(MODEL(translated)));
   \   0000012C   0xE1B00004         MOVS     R0,R4
   \   00000130   0x........         BL       NandFlashModel_GetPageDataSize
   \   00000134   0xE1B09000         MOVS     R9,R0
   \   00000138   0xE3A0A0FF         MOV      R10,#+255
   \   0000013C   0xE1B0200A         MOVS     R2,R10
   \   00000140   0xE1B01009         MOVS     R1,R9
   \   00000144   0xE1B00007         MOVS     R0,R7
   \   00000148   0x........         BL       __aeabi_memset
    317                          }
    318                          if (spare) {
   \                     ??TranslatedNandFlash_ReadPage_6:
   \   0000014C   0xE35B0000         CMP      R11,#+0
   \   00000150   0x0A000016         BEQ      ??TranslatedNandFlash_ReadPage_7
    319              
    320                              memset(spare, 0xFF, NandFlashModel_GetPageSpareSize(MODEL(translated)));
   \   00000154   0xE1B00004         MOVS     R0,R4
   \   00000158   0x........         BL       NandFlashModel_GetPageSpareSize
   \   0000015C   0xE1B09000         MOVS     R9,R0
   \   00000160   0xE3A0A0FF         MOV      R10,#+255
   \   00000164   0xE1B0200A         MOVS     R2,R10
   \   00000168   0xE1B01009         MOVS     R1,R9
   \   0000016C   0xE1B0000B         MOVS     R0,R11
   \   00000170   0x........         BL       __aeabi_memset
    321                          }
    322                      }
   \   00000174   0xEA00000D         B        ??TranslatedNandFlash_ReadPage_7
    323                      else {
    324          
    325                          TRACE_ERROR("Block #%d is not mapped and there are no more blocks available\n\r", block);
   \                     ??TranslatedNandFlash_ReadPage_5:
   \   00000178   0xE1B01005         MOVS     R1,R5
   \   0000017C   0xE1A01801         LSL      R1,R1,#+16
   \   00000180   0xE1B01821         LSRS     R1,R1,#+16
   \   00000184   0x........         LDR      R0,??DataTable6_8
   \   00000188   0x........         BL       printf
    326                          return NandCommon_ERROR_NOMOREBLOCKS;
   \   0000018C   0xE3A00001         MOV      R0,#+1
   \   00000190   0xEA000007         B        ??TranslatedNandFlash_ReadPage_1
    327                      }
    328                  }
    329                  // Error
    330                  else if (error) {
   \                     ??TranslatedNandFlash_ReadPage_2:
   \   00000194   0xE1B00008         MOVS     R0,R8
   \   00000198   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000019C   0xE3500000         CMP      R0,#+0
   \   000001A0   0x0A000002         BEQ      ??TranslatedNandFlash_ReadPage_7
    331              
    332                      return error;
   \   000001A4   0xE1B00008         MOVS     R0,R8
   \   000001A8   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000001AC   0xEA000000         B        ??TranslatedNandFlash_ReadPage_1
    333                  }
    334              }
    335          
    336              return 0;
   \                     ??TranslatedNandFlash_ReadPage_7:
   \   000001B0   0xE3A00000         MOV      R0,#+0
   \                     ??TranslatedNandFlash_ReadPage_1:
   \   000001B4   0xE8BD4FF2         POP      {R1,R4-R11,LR}
   \   000001B8   0xE12FFF1E         BX       LR               ;; return
    337          }
    338          
    339          //------------------------------------------------------------------------------
    340          /// Writes the data and/or spare area of a page on a translated nandflash.
    341          /// Allocates block has needed to keep the wear even between all blocks.
    342          /// \param translated  Pointer to a TranslatedNandFlash instance.
    343          /// \param block  Logical block number.
    344          /// \param page  Number of page to write inside logical block.
    345          /// \param data  Data area buffer, can be 0.
    346          /// \param spare  Spare area buffer, can be 0.
    347          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    348          unsigned char TranslatedNandFlash_WritePage(
    349              struct TranslatedNandFlash *translated,
    350              unsigned short block,
    351              unsigned short page,
    352              void *data,
    353              void *spare)
    354          {
   \                     TranslatedNandFlash_WritePage:
   \   00000000   0xE92D47F0         PUSH     {R4-R10,LR}
   \   00000004   0xE24DD008         SUB      SP,SP,#+8
   \   00000008   0xE1B04000         MOVS     R4,R0
   \   0000000C   0xE1B05001         MOVS     R5,R1
   \   00000010   0xE1B06002         MOVS     R6,R2
   \   00000014   0xE1B07003         MOVS     R7,R3
   \   00000018   0xE59D8028         LDR      R8,[SP, #+40]
    355              unsigned char allocate = 1;
   \   0000001C   0xE3A09001         MOV      R9,#+1
    356              unsigned char error;
    357          
    358              TRACE_INFO("TranslatedNandFlash_WritePage(B#%d:P#%d)\n\r", block, page);
   \   00000020   0xE1B02006         MOVS     R2,R6
   \   00000024   0xE1A02802         LSL      R2,R2,#+16
   \   00000028   0xE1B02822         LSRS     R2,R2,#+16
   \   0000002C   0xE1B01005         MOVS     R1,R5
   \   00000030   0xE1A01801         LSL      R1,R1,#+16
   \   00000034   0xE1B01821         LSRS     R1,R1,#+16
   \   00000038   0x........         LDR      R0,??DataTable6_9
   \   0000003C   0x........         BL       printf
    359          
    360              // A new block must be allocated unless:
    361              // 1. the block is not mapped and there are no more blocks to allocate
    362              if (MappedNandFlash_LogicalToPhysical(MAPPED(translated), block) == -1) {
   \   00000040   0xE1B01005         MOVS     R1,R5
   \   00000044   0xE1A01801         LSL      R1,R1,#+16
   \   00000048   0xE1B01821         LSRS     R1,R1,#+16
   \   0000004C   0xE1B00004         MOVS     R0,R4
   \   00000050   0x........         BL       MappedNandFlash_LogicalToPhysical
   \   00000054   0xE3700001         CMN      R0,#+1
   \   00000058   0x1A000007         BNE      ??TranslatedNandFlash_WritePage_0
    363          
    364                  // Block is not mapped, check if it can be
    365                  if (!BlockCanBeAllocated(translated)) {
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       BlockCanBeAllocated
   \   00000064   0xE3500000         CMP      R0,#+0
   \   00000068   0x1A000014         BNE      ??TranslatedNandFlash_WritePage_1
    366          
    367                      TRACE_ERROR("TranslatedNandFlash_WritePage: Not enough free blocks\n\r");
   \   0000006C   0x........         LDR      R0,??DataTable6_10
   \   00000070   0x........         BL       printf
    368                      return NandCommon_ERROR_NOMOREBLOCKS;
   \   00000074   0xE3A00001         MOV      R0,#+1
   \   00000078   0xEA000050         B        ??TranslatedNandFlash_WritePage_2
    369                  }
    370                  TRACE_DEBUG("Allocate because block not mapped\n\r");
    371              }
    372              // or 2. the block to write is the current one and the page to write is
    373              // clean
    374              else if (translated->currentLogicalBlock == block) {
   \                     ??TranslatedNandFlash_WritePage_0:
   \   0000007C   0xE3A00038         MOV      R0,#+56
   \   00000080   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000084   0xE19000F4         LDRSH    R0,[R0, +R4]
   \   00000088   0xE1B01005         MOVS     R1,R5
   \   0000008C   0xE1A01801         LSL      R1,R1,#+16
   \   00000090   0xE1B01821         LSRS     R1,R1,#+16
   \   00000094   0xE1500001         CMP      R0,R1
   \   00000098   0x1A000008         BNE      ??TranslatedNandFlash_WritePage_1
    375          
    376                  if (PageIsClean(translated, page)) {
   \   0000009C   0xE1B01006         MOVS     R1,R6
   \   000000A0   0xE1A01801         LSL      R1,R1,#+16
   \   000000A4   0xE1B01821         LSRS     R1,R1,#+16
   \   000000A8   0xE1B00004         MOVS     R0,R4
   \   000000AC   0x........         BL       PageIsClean
   \   000000B0   0xE3500000         CMP      R0,#+0
   \   000000B4   0x0A000001         BEQ      ??TranslatedNandFlash_WritePage_1
    377          
    378                      TRACE_DEBUG("NO allocate because write in current block\n\r");
    379                      allocate = 0;
   \   000000B8   0xE3A00000         MOV      R0,#+0
   \   000000BC   0xE1B09000         MOVS     R9,R0
    380                  }
    381                  else {
    382          
    383                      TRACE_DEBUG("Allocate because page DIRTY in current block\n\r");
    384                  }
    385              }
    386              else {
    387          
    388                  TRACE_DEBUG("Allocate because block is mapped and different from current block\n\r");
    389              }
    390          
    391              // Allocate block if needed
    392              if (allocate) {
   \                     ??TranslatedNandFlash_WritePage_1:
   \   000000C0   0xE1B00009         MOVS     R0,R9
   \   000000C4   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000C8   0xE3500000         CMP      R0,#+0
   \   000000CC   0x0A000023         BEQ      ??TranslatedNandFlash_WritePage_3
    393          
    394                  // Flush current block write (if any) and then allocate block
    395                  error = TranslatedNandFlash_Flush(translated);
   \   000000D0   0xE1B00004         MOVS     R0,R4
   \   000000D4   0x........         BL       TranslatedNandFlash_Flush
   \   000000D8   0xE1B0A000         MOVS     R10,R0
    396                  if (error) {
   \   000000DC   0xE1B0000A         MOVS     R0,R10
   \   000000E0   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000E4   0xE3500000         CMP      R0,#+0
   \   000000E8   0x0A000002         BEQ      ??TranslatedNandFlash_WritePage_4
    397          
    398                      return error;
   \   000000EC   0xE1B0000A         MOVS     R0,R10
   \   000000F0   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000F4   0xEA000031         B        ??TranslatedNandFlash_WritePage_2
    399                  }
    400                  translated->previousPhysicalBlock = MappedNandFlash_LogicalToPhysical(
    401                                                          MAPPED(translated),
    402                                                          block);
   \                     ??TranslatedNandFlash_WritePage_4:
   \   000000F8   0xE1B01005         MOVS     R1,R5
   \   000000FC   0xE1A01801         LSL      R1,R1,#+16
   \   00000100   0xE1B01821         LSRS     R1,R1,#+16
   \   00000104   0xE1B00004         MOVS     R0,R4
   \   00000108   0x........         BL       MappedNandFlash_LogicalToPhysical
   \   0000010C   0xE3A0103A         MOV      R1,#+58
   \   00000110   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000114   0xE18100B4         STRH     R0,[R1, +R4]
    403                  TRACE_DEBUG("Previous physical block is now #%d\n\r",
    404                            translated->previousPhysicalBlock);
    405                  error = AllocateBlock(translated, block);
   \   00000118   0xE1B01005         MOVS     R1,R5
   \   0000011C   0xE1A01801         LSL      R1,R1,#+16
   \   00000120   0xE1B01821         LSRS     R1,R1,#+16
   \   00000124   0xE1B00004         MOVS     R0,R4
   \   00000128   0x........         BL       AllocateBlock
   \   0000012C   0xE1B0A000         MOVS     R10,R0
    406                  if (error) {
   \   00000130   0xE1B0000A         MOVS     R0,R10
   \   00000134   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000138   0xE3500000         CMP      R0,#+0
   \   0000013C   0x0A000002         BEQ      ??TranslatedNandFlash_WritePage_5
    407          
    408                      return error;
   \   00000140   0xE1B0000A         MOVS     R0,R10
   \   00000144   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000148   0xEA00001C         B        ??TranslatedNandFlash_WritePage_2
    409                  }
    410          
    411                  // Block becomes the current block with all pages clean
    412                  translated->currentLogicalBlock = block;
   \                     ??TranslatedNandFlash_WritePage_5:
   \   0000014C   0xE3A00038         MOV      R0,#+56
   \   00000150   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000154   0xE18050B4         STRH     R5,[R0, +R4]
    413                  MarkAllPagesClean(translated);
   \   00000158   0xE1B00004         MOVS     R0,R4
   \   0000015C   0x........         BL       MarkAllPagesClean
    414              }
    415          
    416              // Start writing page
    417              error = MappedNandFlash_WritePage(MAPPED(translated),
    418                                                block,
    419                                                page,
    420                                                data,
    421                                                spare);
   \                     ??TranslatedNandFlash_WritePage_3:
   \   00000160   0xE58D8000         STR      R8,[SP, #+0]
   \   00000164   0xE1B03007         MOVS     R3,R7
   \   00000168   0xE1B02006         MOVS     R2,R6
   \   0000016C   0xE1A02802         LSL      R2,R2,#+16
   \   00000170   0xE1B02822         LSRS     R2,R2,#+16
   \   00000174   0xE1B01005         MOVS     R1,R5
   \   00000178   0xE1A01801         LSL      R1,R1,#+16
   \   0000017C   0xE1B01821         LSRS     R1,R1,#+16
   \   00000180   0xE1B00004         MOVS     R0,R4
   \   00000184   0x........         BL       MappedNandFlash_WritePage
   \   00000188   0xE1B0A000         MOVS     R10,R0
    422              if (error) {
   \   0000018C   0xE1B0000A         MOVS     R0,R10
   \   00000190   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000194   0xE3500000         CMP      R0,#+0
   \   00000198   0x0A000002         BEQ      ??TranslatedNandFlash_WritePage_6
    423          
    424                  return error;
   \   0000019C   0xE1B0000A         MOVS     R0,R10
   \   000001A0   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000001A4   0xEA000005         B        ??TranslatedNandFlash_WritePage_2
    425              }
    426          
    427              // If write went through, mark page as written
    428              MarkPageDirty(translated, page);
   \                     ??TranslatedNandFlash_WritePage_6:
   \   000001A8   0xE1B01006         MOVS     R1,R6
   \   000001AC   0xE1A01801         LSL      R1,R1,#+16
   \   000001B0   0xE1B01821         LSRS     R1,R1,#+16
   \   000001B4   0xE1B00004         MOVS     R0,R4
   \   000001B8   0x........         BL       MarkPageDirty
    429              return 0;
   \   000001BC   0xE3A00000         MOV      R0,#+0
   \                     ??TranslatedNandFlash_WritePage_2:
   \   000001C0   0xE8BD47F6         POP      {R1,R2,R4-R10,LR}
   \   000001C4   0xE12FFF1E         BX       LR               ;; return
    430          }
    431          
    432          //------------------------------------------------------------------------------
    433          /// Terminates the current write operation by copying all the missing pages from
    434          /// the previous physical block.
    435          /// \param translated  Pointer to a TranslatedNandFlash instance.
    436          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    437          unsigned char TranslatedNandFlash_Flush(struct TranslatedNandFlash *translated)
    438          {
   \                     TranslatedNandFlash_Flush:
   \   00000000   0xE92D40F8         PUSH     {R3-R7,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    439              unsigned int i;
    440              unsigned char error;
    441              unsigned int currentPhysicalBlock;
    442          
    443              // Check if there is a current block and a previous block
    444              if ((translated->currentLogicalBlock == -1)
    445                  || (translated->previousPhysicalBlock == -1)) {
   \   00000008   0xE3A00038         MOV      R0,#+56
   \   0000000C   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000010   0xE19000F4         LDRSH    R0,[R0, +R4]
   \   00000014   0xE3700001         CMN      R0,#+1
   \   00000018   0x0A000004         BEQ      ??TranslatedNandFlash_Flush_0
   \   0000001C   0xE3A0003A         MOV      R0,#+58
   \   00000020   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000024   0xE19000F4         LDRSH    R0,[R0, +R4]
   \   00000028   0xE3700001         CMN      R0,#+1
   \   0000002C   0x1A000001         BNE      ??TranslatedNandFlash_Flush_1
    446          
    447                  return 0;
   \                     ??TranslatedNandFlash_Flush_0:
   \   00000030   0xE3A00000         MOV      R0,#+0
   \   00000034   0xEA000043         B        ??TranslatedNandFlash_Flush_2
    448              }
    449          
    450              TRACE_INFO("TranslatedNandFlash_Flush(PB#%d -> LB#%d)\n\r",
    451                        translated->previousPhysicalBlock, translated->currentLogicalBlock);
   \                     ??TranslatedNandFlash_Flush_1:
   \   00000038   0xE3A00038         MOV      R0,#+56
   \   0000003C   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000040   0xE19020F4         LDRSH    R2,[R0, +R4]
   \   00000044   0xE3A0003A         MOV      R0,#+58
   \   00000048   0xE3800D60         ORR      R0,R0,#0x1800
   \   0000004C   0xE19010F4         LDRSH    R1,[R0, +R4]
   \   00000050   0x........         LDR      R0,??DataTable6_11
   \   00000054   0x........         BL       printf
    452          
    453              // Copy missing pages in the current block
    454              currentPhysicalBlock = MappedNandFlash_LogicalToPhysical(
    455                                          MAPPED(translated),
    456                                          translated->currentLogicalBlock);
   \   00000058   0xE3A00038         MOV      R0,#+56
   \   0000005C   0xE3800D60         ORR      R0,R0,#0x1800
   \   00000060   0xE19010B4         LDRH     R1,[R0, +R4]
   \   00000064   0xE1A01801         LSL      R1,R1,#+16
   \   00000068   0xE1B01821         LSRS     R1,R1,#+16
   \   0000006C   0xE1B00004         MOVS     R0,R4
   \   00000070   0x........         BL       MappedNandFlash_LogicalToPhysical
   \   00000074   0xE1B07000         MOVS     R7,R0
    457          
    458              for (i=0; i < NandFlashModel_GetBlockSizeInPages(MODEL(translated)); i++) {
   \   00000078   0xE3A00000         MOV      R0,#+0
   \   0000007C   0xE1B05000         MOVS     R5,R0
   \                     ??TranslatedNandFlash_Flush_3:
   \   00000080   0xE1B00004         MOVS     R0,R4
   \   00000084   0x........         BL       NandFlashModel_GetBlockSizeInPages
   \   00000088   0xE1550000         CMP      R5,R0
   \   0000008C   0x2A000024         BCS      ??TranslatedNandFlash_Flush_4
    459          
    460                  if (PageIsClean(translated, i)) {
   \   00000090   0xE1B01005         MOVS     R1,R5
   \   00000094   0xE1A01801         LSL      R1,R1,#+16
   \   00000098   0xE1B01821         LSRS     R1,R1,#+16
   \   0000009C   0xE1B00004         MOVS     R0,R4
   \   000000A0   0x........         BL       PageIsClean
   \   000000A4   0xE3500000         CMP      R0,#+0
   \   000000A8   0x0A00001B         BEQ      ??TranslatedNandFlash_Flush_5
    461          
    462                      TRACE_DEBUG("Copying back page #%d of block #%d\n\r", i,
    463                                translated->previousPhysicalBlock);
    464          
    465                      // Copy page
    466                      error = ManagedNandFlash_CopyPage(MANAGED(translated),
    467                                                        translated->previousPhysicalBlock,
    468                                                        i,
    469                                                        currentPhysicalBlock,
    470                                                        i);
   \   000000AC   0xE1B00005         MOVS     R0,R5
   \   000000B0   0xE1A00800         LSL      R0,R0,#+16
   \   000000B4   0xE1B00820         LSRS     R0,R0,#+16
   \   000000B8   0xE58D0000         STR      R0,[SP, #+0]
   \   000000BC   0xE1B03007         MOVS     R3,R7
   \   000000C0   0xE1A03803         LSL      R3,R3,#+16
   \   000000C4   0xE1B03823         LSRS     R3,R3,#+16
   \   000000C8   0xE1B02005         MOVS     R2,R5
   \   000000CC   0xE1A02802         LSL      R2,R2,#+16
   \   000000D0   0xE1B02822         LSRS     R2,R2,#+16
   \   000000D4   0xE3A0003A         MOV      R0,#+58
   \   000000D8   0xE3800D60         ORR      R0,R0,#0x1800
   \   000000DC   0xE19010B4         LDRH     R1,[R0, +R4]
   \   000000E0   0xE1A01801         LSL      R1,R1,#+16
   \   000000E4   0xE1B01821         LSRS     R1,R1,#+16
   \   000000E8   0xE1B00004         MOVS     R0,R4
   \   000000EC   0x........         BL       ManagedNandFlash_CopyPage
   \   000000F0   0xE1B06000         MOVS     R6,R0
    471                      if (error) {
   \   000000F4   0xE1B00006         MOVS     R0,R6
   \   000000F8   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000FC   0xE3500000         CMP      R0,#+0
   \   00000100   0x0A000005         BEQ      ??TranslatedNandFlash_Flush_5
    472          
    473                          TRACE_ERROR("FinishCurrentWrite: copy page #%d\n\r", i);
                                 ^
Remark[Pe181]: argument is incompatible with corresponding format string
          conversion
   \   00000104   0xE1B01005         MOVS     R1,R5
   \   00000108   0x........         LDR      R0,??DataTable6_12
   \   0000010C   0x........         BL       printf
    474                          return error;
   \   00000110   0xE1B00006         MOVS     R0,R6
   \   00000114   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000118   0xEA00000A         B        ??TranslatedNandFlash_Flush_2
    475                      }
    476                  }
    477              }
   \                     ??TranslatedNandFlash_Flush_5:
   \   0000011C   0xE2955001         ADDS     R5,R5,#+1
   \   00000120   0xEAFFFFD6         B        ??TranslatedNandFlash_Flush_3
    478          
    479              translated->currentLogicalBlock = -1;
   \                     ??TranslatedNandFlash_Flush_4:
   \   00000124   0xE3E00000         MVN      R0,#+0
   \   00000128   0xE3A01038         MOV      R1,#+56
   \   0000012C   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000130   0xE18100B4         STRH     R0,[R1, +R4]
    480              translated->previousPhysicalBlock = -1;
   \   00000134   0xE3E00000         MVN      R0,#+0
   \   00000138   0xE3A0103A         MOV      R1,#+58
   \   0000013C   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000140   0xE18100B4         STRH     R0,[R1, +R4]
    481              return 0;
   \   00000144   0xE3A00000         MOV      R0,#+0
   \                     ??TranslatedNandFlash_Flush_2:
   \   00000148   0xE8BD40F2         POP      {R1,R4-R7,LR}
   \   0000014C   0xE12FFF1E         BX       LR               ;; return
    482          }
    483          
    484          //------------------------------------------------------------------------------
    485          /// Erase all blocks in the tranalated area of nand flash.
    486          /// \param managed  Pointer to a TranslatedNandFlash instance.
    487          /// \param level    Erase level.
    488          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    489          unsigned char TranslatedNandFlash_EraseAll(
    490              struct TranslatedNandFlash *translated,
    491              unsigned char level)
    492          {
   \                     TranslatedNandFlash_EraseAll:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
   \   00000008   0xE1B05001         MOVS     R5,R1
    493              MappedNandFlash_EraseAll(MAPPED(translated), level);
   \   0000000C   0xE1B01005         MOVS     R1,R5
   \   00000010   0xE21110FF         ANDS     R1,R1,#0xFF      ;; Zero extend
   \   00000014   0xE1B00004         MOVS     R0,R4
   \   00000018   0x........         BL       MappedNandFlash_EraseAll
    494              if (level > NandEraseDIRTY) {
   \   0000001C   0xE1B00005         MOVS     R0,R5
   \   00000020   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000024   0xE3500000         CMP      R0,#+0
   \   00000028   0x0A000009         BEQ      ??TranslatedNandFlash_EraseAll_0
    495                  translated->currentLogicalBlock = -1;
   \   0000002C   0xE3E00000         MVN      R0,#+0
   \   00000030   0xE3A01038         MOV      R1,#+56
   \   00000034   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000038   0xE18100B4         STRH     R0,[R1, +R4]
    496                  translated->previousPhysicalBlock = -1;
   \   0000003C   0xE3E00000         MVN      R0,#+0
   \   00000040   0xE3A0103A         MOV      R1,#+58
   \   00000044   0xE3811D60         ORR      R1,R1,#0x1800
   \   00000048   0xE18100B4         STRH     R0,[R1, +R4]
    497                  MarkAllPagesClean(translated);
   \   0000004C   0xE1B00004         MOVS     R0,R4
   \   00000050   0x........         BL       MarkAllPagesClean
    498              }
    499              return 0;
   \                     ??TranslatedNandFlash_EraseAll_0:
   \   00000054   0xE3A00000         MOV      R0,#+0
   \   00000058   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   0000005C   0xE12FFF1E         BX       LR               ;; return
    500          }
    501          
    502          //------------------------------------------------------------------------------
    503          /// Allocates a free block to save the current logical mapping on it.
    504          /// Returns 0 if successful; otherwise returns a NandCommon_ERROR code.
    505          /// \param translated  Pointer to a TranslatedNandFlash instance.
    506          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    507          unsigned char TranslatedNandFlash_SaveLogicalMapping(
    508              struct TranslatedNandFlash *translated)
    509          {
   \                     TranslatedNandFlash_SaveLogicalMapping:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    510              unsigned char error;
    511              unsigned short freeBlock;
    512          
    513              TRACE_INFO("TranslatedNandFlash_SaveLogicalMapping()\n\r");
   \   00000008   0x........         LDR      R0,??DataTable6_13
   \   0000000C   0x........         BL       printf
    514          
    515              // Save logical mapping in the youngest free block
    516              // Find the youngest block
    517              error = ManagedNandFlash_FindYoungestBlock(MANAGED(translated),
    518                                                         NandBlockStatus_FREE,
    519                                                         &freeBlock);
   \   00000010   0xE1B0200D         MOVS     R2,SP
   \   00000014   0xE3A0100E         MOV      R1,#+14
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       ManagedNandFlash_FindYoungestBlock
   \   00000020   0xE1B05000         MOVS     R5,R0
    520              if (error) {
   \   00000024   0xE1B00005         MOVS     R0,R5
   \   00000028   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   0000002C   0xE3500000         CMP      R0,#+0
   \   00000030   0x0A000004         BEQ      ??TranslatedNandFlash_SaveLogicalMapping_0
    521          
    522                  TRACE_ERROR("TranNF_SaveLogicalMapping: No free block\n\r");
   \   00000034   0x........         LDR      R0,??DataTable6_14
   \   00000038   0x........         BL       printf
    523                  return error;
   \   0000003C   0xE1B00005         MOVS     R0,R5
   \   00000040   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000044   0xEA000021         B        ??TranslatedNandFlash_SaveLogicalMapping_1
    524              }
    525          
    526              // Check if this is the last free block, in which case dirty blocks are wiped
    527              // prior to saving the mapping
    528              if (ManagedNandFlash_CountBlocks(MANAGED(translated),
    529                                               NandBlockStatus_FREE) == 1) {
   \                     ??TranslatedNandFlash_SaveLogicalMapping_0:
   \   00000048   0xE3A0100E         MOV      R1,#+14
   \   0000004C   0xE1B00004         MOVS     R0,R4
   \   00000050   0x........         BL       ManagedNandFlash_CountBlocks
   \   00000054   0xE3500001         CMP      R0,#+1
   \   00000058   0x1A00000D         BNE      ??TranslatedNandFlash_SaveLogicalMapping_2
    530          
    531                  TranslatedNandFlash_Flush(translated);
   \   0000005C   0xE1B00004         MOVS     R0,R4
   \   00000060   0x........         BL       TranslatedNandFlash_Flush
    532                  error = ManagedNandFlash_EraseDirtyBlocks(MANAGED(translated));
   \   00000064   0xE1B00004         MOVS     R0,R4
   \   00000068   0x........         BL       ManagedNandFlash_EraseDirtyBlocks
   \   0000006C   0xE1B05000         MOVS     R5,R0
    533                  if (error) {
   \   00000070   0xE1B00005         MOVS     R0,R5
   \   00000074   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000078   0xE3500000         CMP      R0,#+0
   \   0000007C   0x0A000004         BEQ      ??TranslatedNandFlash_SaveLogicalMapping_2
    534                  
    535                      TRACE_ERROR("TranNF_Flush: Could not erase dirty blocks\n\r");
   \   00000080   0x........         LDR      R0,??DataTable6_15
   \   00000084   0x........         BL       printf
    536                      return error;
   \   00000088   0xE1B00005         MOVS     R0,R5
   \   0000008C   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   00000090   0xEA00000E         B        ??TranslatedNandFlash_SaveLogicalMapping_1
    537                  }
    538              }
    539          
    540              // Save the mapping
    541              error = MappedNandFlash_SaveLogicalMapping(MAPPED(translated), freeBlock);
   \                     ??TranslatedNandFlash_SaveLogicalMapping_2:
   \   00000094   0xE1DD10B0         LDRH     R1,[SP, #+0]
   \   00000098   0xE1B00004         MOVS     R0,R4
   \   0000009C   0x........         BL       MappedNandFlash_SaveLogicalMapping
   \   000000A0   0xE1B05000         MOVS     R5,R0
    542              if (error) {
   \   000000A4   0xE1B00005         MOVS     R0,R5
   \   000000A8   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000AC   0xE3500000         CMP      R0,#+0
   \   000000B0   0x0A000005         BEQ      ??TranslatedNandFlash_SaveLogicalMapping_3
    543          
    544                  TRACE_ERROR("TranNF_Flush: Failed to save mapping in #%d\n\r",
    545                              freeBlock);
   \   000000B4   0xE1DD10B0         LDRH     R1,[SP, #+0]
   \   000000B8   0x........         LDR      R0,??DataTable6_16
   \   000000BC   0x........         BL       printf
    546                  return error;
   \   000000C0   0xE1B00005         MOVS     R0,R5
   \   000000C4   0xE21000FF         ANDS     R0,R0,#0xFF      ;; Zero extend
   \   000000C8   0xEA000000         B        ??TranslatedNandFlash_SaveLogicalMapping_1
    547              }
    548          
    549              return 0;
   \                     ??TranslatedNandFlash_SaveLogicalMapping_3:
   \   000000CC   0xE3A00000         MOV      R0,#+0
   \                     ??TranslatedNandFlash_SaveLogicalMapping_1:
   \   000000D0   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   000000D4   0xE12FFF1E         BX       LR               ;; return
    550          }
    551          
    552          //------------------------------------------------------------------------------
    553          /// Returns the number of available blocks in a translated nandflash.
    554          /// \param translated  Pointer to a TranslatedNandFlash instance.
    555          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    556          unsigned short TranslatedNandFlash_GetDeviceSizeInBlocks(
    557             const struct TranslatedNandFlash *translated)
    558          {
   \                     TranslatedNandFlash_GetDeviceSizeInBlocks:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    559              return ManagedNandFlash_GetDeviceSizeInBlocks(MANAGED(translated))
    560                     - MINNUMUNALLOCATEDBLOCKS
    561                     - ManagedNandFlash_CountBlocks(MANAGED(translated),
    562                                                    NandBlockStatus_BAD)
    563                     - 1; // Logical mapping block
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0x........         BL       ManagedNandFlash_GetDeviceSizeInBlocks
   \   00000010   0xE2505020         SUBS     R5,R0,#+32
   \   00000014   0xE3A01000         MOV      R1,#+0
   \   00000018   0xE1B00004         MOVS     R0,R4
   \   0000001C   0x........         BL       ManagedNandFlash_CountBlocks
   \   00000020   0xE0550000         SUBS     R0,R5,R0
   \   00000024   0xE2500001         SUBS     R0,R0,#+1
   \   00000028   0xE1A00800         LSL      R0,R0,#+16
   \   0000002C   0xE1B00820         LSRS     R0,R0,#+16
   \   00000030   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   00000034   0xE12FFF1E         BX       LR               ;; return
    564          }
    565          
    566          //------------------------------------------------------------------------------
    567          /// Returns the number of available pages in a translated nandflash.
    568          /// \param translated  Pointer to a TranslatedNandFlash instance.
    569          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    570          unsigned int TranslatedNandFlash_GetDeviceSizeInPages(
    571             const struct TranslatedNandFlash *translated)
    572          {
   \                     TranslatedNandFlash_GetDeviceSizeInPages:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    573              return TranslatedNandFlash_GetDeviceSizeInBlocks(translated)
    574                     * NandFlashModel_GetBlockSizeInPages(MODEL(translated));
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0x........         BL       TranslatedNandFlash_GetDeviceSizeInBlocks
   \   00000010   0xE1B05000         MOVS     R5,R0
   \   00000014   0xE1A05805         LSL      R5,R5,#+16
   \   00000018   0xE1B05825         LSRS     R5,R5,#+16
   \   0000001C   0xE1B00004         MOVS     R0,R4
   \   00000020   0x........         BL       NandFlashModel_GetBlockSizeInPages
   \   00000024   0xE0110590         MULS     R1,R0,R5
   \   00000028   0xE1B00001         MOVS     R0,R1
   \   0000002C   0xE8BD4032         POP      {R1,R4,R5,LR}
   \   00000030   0xE12FFF1E         BX       LR               ;; return
    575          }
    576          
    577          //------------------------------------------------------------------------------
    578          /// Returns the number of available data bytes in a translated nandflash.
    579          /// \param translated  Pointer to a TranslatedNandFlash instance.
    580          //------------------------------------------------------------------------------

   \                                 In section .text, align 4, keep-with-next
    581          unsigned long long TranslatedNandFlash_GetDeviceSizeInBytes(
    582             const struct TranslatedNandFlash *translated)
    583          {
   \                     TranslatedNandFlash_GetDeviceSizeInBytes:
   \   00000000   0xE92D4038         PUSH     {R3-R5,LR}
   \   00000004   0xE1B04000         MOVS     R4,R0
    584              return TranslatedNandFlash_GetDeviceSizeInPages(translated)
    585                     * NandFlashModel_GetPageDataSize(MODEL(translated));
   \   00000008   0xE1B00004         MOVS     R0,R4
   \   0000000C   0x........         BL       TranslatedNandFlash_GetDeviceSizeInPages
   \   00000010   0xE1B05000         MOVS     R5,R0
   \   00000014   0xE1B00004         MOVS     R0,R4
   \   00000018   0x........         BL       NandFlashModel_GetPageDataSize
   \   0000001C   0xE0120590         MULS     R2,R0,R5
   \   00000020   0xE1B00002         MOVS     R0,R2
   \   00000024   0xE3B01000         MOVS     R1,#+0
   \   00000028   0xE8BD4034         POP      {R2,R4,R5,LR}
   \   0000002C   0xE12FFF1E         BX       LR               ;; return
    586          }

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     ?_2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     ?_3

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     ?_4

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     ?_5

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x........         DC32     ?_6

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x........         DC32     ?_7

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x........         DC32     ?_16

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x2D 0x46          DC8 "-F- ASSERT: "
   \              0x2D 0x20    
   \              0x41 0x53    
   \              0x53 0x45    
   \              0x52 0x54    
   \              0x3A 0x20    
   \              0x00         
   \   0000000D   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x50 0x61          DC8 "PageIsClean: Page out-of-bounds\012\015"
   \              0x67 0x65    
   \              0x49 0x73    
   \              0x43 0x6C    
   \              0x65 0x61    
   \              0x6E 0x3A    
   \              0x20 0x50    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x6F 0x75    
   \              0x74 0x2D    
   \              0x6F 0x66    
   \              0x2D 0x62    
   \              0x6F 0x75    
   \              0x6E 0x64    
   \              0x73 0x0A    
   \              0x0D 0x00    
   \   00000022   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x2D 0x45          DC8 "-E- AllocateBlock: Could not find a free block\012\015"
   \              0x2D 0x20    
   \              0x41 0x6C    
   \              0x6C 0x6F    
   \              0x63 0x61    
   \              0x74 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x43    
   \              0x6F 0x75    
   \              0x6C 0x64    
   \              0x20 0x6E    
   \              0x6F 0x74    
   \              0x20 0x66    
   \              0x69 0x6E    
   \              0x64 0x20    
   \              0x61 0x20    
   \              0x66 0x72    
   \              0x65 0x65    
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x2D 0x45          DC8 "-E- AllocateBlock: Failed to save mapping\012\015"
   \              0x2D 0x20    
   \              0x41 0x6C    
   \              0x6C 0x6F    
   \              0x63 0x61    
   \              0x74 0x65    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x3A    
   \              0x20 0x46    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x74 0x6F    
   \              0x20 0x73    
   \              0x61 0x76    
   \              0x65 0x20    
   \              0x6D 0x61    
   \              0x70 0x70    
   \              0x69 0x6E    
   \              0x67 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x2D 0x45          DC8 2DH, 45H, 2DH, 20H, 41H, 6CH, 6CH, 6FH
   \              0x2D 0x20    
   \              0x41 0x6C    
   \              0x6C 0x6F    
   \   00000008   0x63 0x61          DC8 63H, 61H, 74H, 65H, 64H, 42H, 6CH, 6FH
   \              0x74 0x65    
   \              0x64 0x42    
   \              0x6C 0x6F    
   \   00000010   0x63 0x6B          DC8 63H, 6BH, 3AH, 20H, 46H, 61H, 69H, 6CH
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \   00000018   0x65 0x64          DC8 65H, 64H, 20H, 74H, 6FH, 20H, 65H, 72H
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x65 0x72    
   \   00000020   0x61 0x73          DC8 61H, 73H, 65H, 20H, 64H, 69H, 72H, 74H
   \              0x65 0x20    
   \              0x64 0x69    
   \              0x72 0x74    
   \   00000028   0x79 0x20          DC8 79H, 20H, 62H, 6CH, 6FH, 63H, 6BH, 73H
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x73    
   \   00000030   0x0A 0x0D          DC8 0AH, 0DH, 0
   \              0x00         
   \   00000033   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x2D 0x57          DC8 "-W- Erase difference too big, switching blocks\012\015"
   \              0x2D 0x20    
   \              0x45 0x72    
   \              0x61 0x73    
   \              0x65 0x20    
   \              0x64 0x69    
   \              0x66 0x66    
   \              0x65 0x72    
   \              0x65 0x6E    
   \              0x63 0x65    
   \              0x20 0x74    
   \              0x6F 0x6F    
   \              0x20 0x62    
   \              0x69 0x67    
   \              0x2C 0x20    
   \              0x73 0x77    
   \              0x69 0x74    
   \              0x63 0x68    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x73    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x2D 0x49          DC8 "-I- TranslatedNandFlash_ReadPage(B#%d:P#%d)\012\015"
   \              0x2D 0x20    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6C    
   \              0x61 0x74    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x52 0x65    
   \              0x61 0x64    
   \              0x50 0x61    
   \              0x67 0x65    
   \              0x28 0x42    
   \              0x23 0x25    
   \              0x64 0x3A    
   \              0x50 0x23    
   \              0x25 0x64    
   \              0x29 0x0A    
   \              0x0D 0x00    
   \   0000002E   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x43 0x61          DC8 43H, 61H, 6EH, 6EH, 6FH, 74H, 20H, 72H
   \              0x6E 0x6E    
   \              0x6F 0x74    
   \              0x20 0x72    
   \   00000008   0x65 0x61          DC8 65H, 61H, 64H, 20H, 74H, 68H, 65H, 20H
   \              0x64 0x20    
   \              0x74 0x68    
   \              0x65 0x20    
   \   00000010   0x73 0x70          DC8 73H, 70H, 61H, 72H, 65H, 20H, 69H, 6EH
   \              0x61 0x72    
   \              0x65 0x20    
   \              0x69 0x6E    
   \   00000018   0x66 0x6F          DC8 66H, 6FH, 72H, 6DH, 61H, 74H, 69H, 6FH
   \              0x72 0x6D    
   \              0x61 0x74    
   \              0x69 0x6F    
   \   00000020   0x6E 0x20          DC8 6EH, 20H, 6FH, 66H, 20H, 61H, 6EH, 20H
   \              0x6F 0x66    
   \              0x20 0x61    
   \              0x6E 0x20    
   \   00000028   0x75 0x6E          DC8 75H, 6EH, 6DH, 61H, 70H, 70H, 65H, 64H
   \              0x6D 0x61    
   \              0x70 0x70    
   \              0x65 0x64    
   \   00000030   0x20 0x62          DC8 20H, 62H, 6CH, 6FH, 63H, 6BH, 0AH, 0DH
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x0A 0x0D    
   \   00000038   0x00               DC8 0
   \   00000039   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_8:
   \   00000000   0x2D 0x45          DC8 2DH, 45H, 2DH, 20H, 42H, 6CH, 6FH, 63H
   \              0x2D 0x20    
   \              0x42 0x6C    
   \              0x6F 0x63    
   \   00000008   0x6B 0x20          DC8 6BH, 20H, 23H, 25H, 64H, 20H, 69H, 73H
   \              0x23 0x25    
   \              0x64 0x20    
   \              0x69 0x73    
   \   00000010   0x20 0x6E          DC8 20H, 6EH, 6FH, 74H, 20H, 6DH, 61H, 70H
   \              0x6F 0x74    
   \              0x20 0x6D    
   \              0x61 0x70    
   \   00000018   0x70 0x65          DC8 70H, 65H, 64H, 20H, 61H, 6EH, 64H, 20H
   \              0x64 0x20    
   \              0x61 0x6E    
   \              0x64 0x20    
   \   00000020   0x74 0x68          DC8 74H, 68H, 65H, 72H, 65H, 20H, 61H, 72H
   \              0x65 0x72    
   \              0x65 0x20    
   \              0x61 0x72    
   \   00000028   0x65 0x20          DC8 65H, 20H, 6EH, 6FH, 20H, 6DH, 6FH, 72H
   \              0x6E 0x6F    
   \              0x20 0x6D    
   \              0x6F 0x72    
   \   00000030   0x65 0x20          DC8 65H, 20H, 62H, 6CH, 6FH, 63H, 6BH, 73H
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x73    
   \   00000038   0x20 0x61          DC8 20H, 61H, 76H, 61H, 69H, 6CH, 61H, 62H
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \   00000040   0x6C 0x65          DC8 6CH, 65H, 0AH, 0DH, 0
   \              0x0A 0x0D    
   \              0x00         
   \   00000045   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x2D 0x49          DC8 "-I- TranslatedNandFlash_WritePage(B#%d:P#%d)\012\015"
   \              0x2D 0x20    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6C    
   \              0x61 0x74    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x57 0x72    
   \              0x69 0x74    
   \              0x65 0x50    
   \              0x61 0x67    
   \              0x65 0x28    
   \              0x42 0x23    
   \              0x25 0x64    
   \              0x3A 0x50    
   \              0x23 0x25    
   \              0x64 0x29    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x2D 0x45          DC8 2DH, 45H, 2DH, 20H, 54H, 72H, 61H, 6EH
   \              0x2D 0x20    
   \              0x54 0x72    
   \              0x61 0x6E    
   \   00000008   0x73 0x6C          DC8 73H, 6CH, 61H, 74H, 65H, 64H, 4EH, 61H
   \              0x61 0x74    
   \              0x65 0x64    
   \              0x4E 0x61    
   \   00000010   0x6E 0x64          DC8 6EH, 64H, 46H, 6CH, 61H, 73H, 68H, 5FH
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \   00000018   0x57 0x72          DC8 57H, 72H, 69H, 74H, 65H, 50H, 61H, 67H
   \              0x69 0x74    
   \              0x65 0x50    
   \              0x61 0x67    
   \   00000020   0x65 0x3A          DC8 65H, 3AH, 20H, 4EH, 6FH, 74H, 20H, 65H
   \              0x20 0x4E    
   \              0x6F 0x74    
   \              0x20 0x65    
   \   00000028   0x6E 0x6F          DC8 6EH, 6FH, 75H, 67H, 68H, 20H, 66H, 72H
   \              0x75 0x67    
   \              0x68 0x20    
   \              0x66 0x72    
   \   00000030   0x65 0x65          DC8 65H, 65H, 20H, 62H, 6CH, 6FH, 63H, 6BH
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \   00000038   0x73 0x0A          DC8 73H, 0AH, 0DH, 0
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x2D 0x49          DC8 "-I- TranslatedNandFlash_Flush(PB#%d -> LB#%d)\012\015"
   \              0x2D 0x20    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6C    
   \              0x61 0x74    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x46 0x6C    
   \              0x75 0x73    
   \              0x68 0x28    
   \              0x50 0x42    
   \              0x23 0x25    
   \              0x64 0x20    
   \              0x2D 0x3E    
   \              0x20 0x4C    
   \              0x42 0x23    
   \              0x25 0x64    
   \              0x29 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x2D 0x45          DC8 "-E- FinishCurrentWrite: copy page #%d\012\015"
   \              0x2D 0x20    
   \              0x46 0x69    
   \              0x6E 0x69    
   \              0x73 0x68    
   \              0x43 0x75    
   \              0x72 0x72    
   \              0x65 0x6E    
   \              0x74 0x57    
   \              0x72 0x69    
   \              0x74 0x65    
   \              0x3A 0x20    
   \              0x63 0x6F    
   \              0x70 0x79    
   \              0x20 0x70    
   \              0x61 0x67    
   \              0x65 0x20    
   \              0x23 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x2D 0x49          DC8 "-I- TranslatedNandFlash_SaveLogicalMapping()\012\015"
   \              0x2D 0x20    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x73 0x6C    
   \              0x61 0x74    
   \              0x65 0x64    
   \              0x4E 0x61    
   \              0x6E 0x64    
   \              0x46 0x6C    
   \              0x61 0x73    
   \              0x68 0x5F    
   \              0x53 0x61    
   \              0x76 0x65    
   \              0x4C 0x6F    
   \              0x67 0x69    
   \              0x63 0x61    
   \              0x6C 0x4D    
   \              0x61 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x28 0x29    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x2D 0x45          DC8 "-E- TranNF_SaveLogicalMapping: No free block\012\015"
   \              0x2D 0x20    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x4E 0x46    
   \              0x5F 0x53    
   \              0x61 0x76    
   \              0x65 0x4C    
   \              0x6F 0x67    
   \              0x69 0x63    
   \              0x61 0x6C    
   \              0x4D 0x61    
   \              0x70 0x70    
   \              0x69 0x6E    
   \              0x67 0x3A    
   \              0x20 0x4E    
   \              0x6F 0x20    
   \              0x66 0x72    
   \              0x65 0x65    
   \              0x20 0x62    
   \              0x6C 0x6F    
   \              0x63 0x6B    
   \              0x0A 0x0D    
   \              0x00         
   \   0000002F   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x2D 0x45          DC8 "-E- TranNF_Flush: Could not erase dirty blocks\012\015"
   \              0x2D 0x20    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x4E 0x46    
   \              0x5F 0x46    
   \              0x6C 0x75    
   \              0x73 0x68    
   \              0x3A 0x20    
   \              0x43 0x6F    
   \              0x75 0x6C    
   \              0x64 0x20    
   \              0x6E 0x6F    
   \              0x74 0x20    
   \              0x65 0x72    
   \              0x61 0x73    
   \              0x65 0x20    
   \              0x64 0x69    
   \              0x72 0x74    
   \              0x79 0x20    
   \              0x62 0x6C    
   \              0x6F 0x63    
   \              0x6B 0x73    
   \              0x0A 0x0D    
   \              0x00         
   \   00000031   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x2D 0x45          DC8 "-E- TranNF_Flush: Failed to save mapping in #%d\012\015"
   \              0x2D 0x20    
   \              0x54 0x72    
   \              0x61 0x6E    
   \              0x4E 0x46    
   \              0x5F 0x46    
   \              0x6C 0x75    
   \              0x73 0x68    
   \              0x3A 0x20    
   \              0x46 0x61    
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \              0x6F 0x20    
   \              0x73 0x61    
   \              0x76 0x65    
   \              0x20 0x6D    
   \              0x61 0x70    
   \              0x70 0x69    
   \              0x6E 0x67    
   \              0x20 0x69    
   \              0x6E 0x20    
   \              0x23 0x25    
   \              0x64 0x0A    
   \              0x0D 0x00    
   \   00000032   0x00 0x00          DC8 0, 0
    587          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   AllocateBlock
        24   -> AllocateBlock
        24   -> ManagedNandFlash_CopyBlock
        24   -> ManagedNandFlash_CountBlocks
        24   -> ManagedNandFlash_EraseDirtyBlocks
        24   -> ManagedNandFlash_FindYoungestBlock
        24   -> MappedNandFlash_Map
        24   -> MappedNandFlash_PhysicalToLogical
        24   -> MappedNandFlash_SaveLogicalMapping
        24   -> absv
        24   -> printf
      16   BlockCanBeAllocated
        16   -> ManagedNandFlash_CountBlocks
      24   MarkAllPagesClean
        24   -> __aeabi_memset
      32   MarkPageDirty
        32   -> NandFlashModel_GetBlockSizeInPages
        32   -> printf
        32 __aeabi_idiv
        32 __aeabi_idivmod
      16   PageIsClean
        16   -> NandFlashModel_GetBlockSizeInPages
        16   -> printf
        16 __aeabi_idiv
        16 __aeabi_idivmod
      16   TranslatedNandFlash_EraseAll
        16   -> MappedNandFlash_EraseAll
        16   -> MarkAllPagesClean
      24   TranslatedNandFlash_Flush
        24   -> ManagedNandFlash_CopyPage
        24   -> MappedNandFlash_LogicalToPhysical
        24   -> NandFlashModel_GetBlockSizeInPages
        24   -> PageIsClean
        24   -> printf
      16   TranslatedNandFlash_GetDeviceSizeInBlocks
        16   -> ManagedNandFlash_CountBlocks
        16   -> ManagedNandFlash_GetDeviceSizeInBlocks
      16   TranslatedNandFlash_GetDeviceSizeInBytes
        16   -> NandFlashModel_GetPageDataSize
        16   -> TranslatedNandFlash_GetDeviceSizeInPages
      16   TranslatedNandFlash_GetDeviceSizeInPages
        16   -> NandFlashModel_GetBlockSizeInPages
        16   -> TranslatedNandFlash_GetDeviceSizeInBlocks
      72   TranslatedNandFlash_Initialize
        72   -> MappedNandFlash_Initialize
        72   -> MarkAllPagesClean
      40   TranslatedNandFlash_ReadPage
        40   -> BlockCanBeAllocated
        40   -> ManagedNandFlash_ReadPage
        40   -> MappedNandFlash_ReadPage
        40   -> NandFlashModel_GetPageDataSize
        40   -> NandFlashModel_GetPageSpareSize
        40   -> PageIsClean
        40   -> __aeabi_memset
        40   -> printf
      16   TranslatedNandFlash_SaveLogicalMapping
        16   -> ManagedNandFlash_CountBlocks
        16   -> ManagedNandFlash_EraseDirtyBlocks
        16   -> ManagedNandFlash_FindYoungestBlock
        16   -> MappedNandFlash_SaveLogicalMapping
        16   -> TranslatedNandFlash_Flush
        16   -> printf
      40   TranslatedNandFlash_WritePage
        40   -> AllocateBlock
        40   -> BlockCanBeAllocated
        40   -> MappedNandFlash_LogicalToPhysical
        40   -> MappedNandFlash_WritePage
        40   -> MarkAllPagesClean
        40   -> MarkPageDirty
        40   -> PageIsClean
        40   -> TranslatedNandFlash_Flush
        40   -> printf


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      16  ?_0
      36  ?_1
      60  ?_10
      48  ?_11
      40  ?_12
      48  ?_13
      48  ?_14
      52  ?_15
      52  ?_16
      52  ?_2
      44  ?_3
      52  ?_4
      52  ?_5
      48  ?_6
      60  ?_7
      72  ?_8
      48  ?_9
     396  AllocateBlock
      84  BlockCanBeAllocated
      52  MarkAllPagesClean
     168  MarkPageDirty
     136  PageIsClean
      96  TranslatedNandFlash_EraseAll
     336  TranslatedNandFlash_Flush
      56  TranslatedNandFlash_GetDeviceSizeInBlocks
      48  TranslatedNandFlash_GetDeviceSizeInBytes
      52  TranslatedNandFlash_GetDeviceSizeInPages
     208  TranslatedNandFlash_Initialize
     444  TranslatedNandFlash_ReadPage
     216  TranslatedNandFlash_SaveLogicalMapping
     456  TranslatedNandFlash_WritePage

 
   828 bytes in section .rodata
 2 816 bytes in section .text
 
 2 816 bytes of CODE  memory
   828 bytes of CONST memory

Errors: none
Warnings: none
